<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>317 | Nguyễn Khánk&#39;s Wiki</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="apple-touch-icon" sizes="180x180" href="../public/favicons/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="../public/favicons/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="../public/favicons/favicon-16x16.png">
    <link rel="manifest" href="../public/favicons/manifest.json">
    <link rel="mask-icon" href="../public/favicons/safari-pinned-tab.svg" color="#3a0839">
    <link rel="shortcut icon" href="../public/favicons/favicon.ico">
    <meta name="description" content="Wikipedia của tui">
    <meta name="msapplication-TileColor" content="#3a0839">
    <meta name="msapplication-config" content="../public/favicons/browserconfig.xml">
    <meta name="theme-color" content="#ffffff">
    
    <link rel="preload" href="/docs/assets/css/0.styles.5d974432.css" as="style"><link rel="preload" href="/docs/assets/js/app.c1419c2e.js" as="script"><link rel="preload" href="/docs/assets/js/2.0631070b.js" as="script"><link rel="preload" href="/docs/assets/js/247.14de355b.js" as="script"><link rel="preload" href="/docs/assets/js/29.9e31a33a.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.2209d5f8.js"><link rel="prefetch" href="/docs/assets/js/100.66292609.js"><link rel="prefetch" href="/docs/assets/js/101.528403ff.js"><link rel="prefetch" href="/docs/assets/js/102.a39e539c.js"><link rel="prefetch" href="/docs/assets/js/103.f6f41453.js"><link rel="prefetch" href="/docs/assets/js/104.704c7f52.js"><link rel="prefetch" href="/docs/assets/js/105.ca8acaab.js"><link rel="prefetch" href="/docs/assets/js/106.ff5700fd.js"><link rel="prefetch" href="/docs/assets/js/107.f30fdfbd.js"><link rel="prefetch" href="/docs/assets/js/108.0b10e638.js"><link rel="prefetch" href="/docs/assets/js/109.9384e67f.js"><link rel="prefetch" href="/docs/assets/js/11.d957f018.js"><link rel="prefetch" href="/docs/assets/js/110.6b9ae74f.js"><link rel="prefetch" href="/docs/assets/js/111.1e44f2a0.js"><link rel="prefetch" href="/docs/assets/js/112.12504359.js"><link rel="prefetch" href="/docs/assets/js/113.52c9cf20.js"><link rel="prefetch" href="/docs/assets/js/114.58e67f33.js"><link rel="prefetch" href="/docs/assets/js/115.3426a51b.js"><link rel="prefetch" href="/docs/assets/js/116.1a9a4c57.js"><link rel="prefetch" href="/docs/assets/js/117.279d3665.js"><link rel="prefetch" href="/docs/assets/js/118.9ff63e65.js"><link rel="prefetch" href="/docs/assets/js/119.4a599115.js"><link rel="prefetch" href="/docs/assets/js/12.92d7b968.js"><link rel="prefetch" href="/docs/assets/js/120.d700baf1.js"><link rel="prefetch" href="/docs/assets/js/121.2876291d.js"><link rel="prefetch" href="/docs/assets/js/122.c29818a0.js"><link rel="prefetch" href="/docs/assets/js/123.5dca65e2.js"><link rel="prefetch" href="/docs/assets/js/124.e9371457.js"><link rel="prefetch" href="/docs/assets/js/125.67e61d62.js"><link rel="prefetch" href="/docs/assets/js/126.5921e8c3.js"><link rel="prefetch" href="/docs/assets/js/127.41691d60.js"><link rel="prefetch" href="/docs/assets/js/128.50429607.js"><link rel="prefetch" href="/docs/assets/js/129.b36d3fcf.js"><link rel="prefetch" href="/docs/assets/js/13.33891f7b.js"><link rel="prefetch" href="/docs/assets/js/130.3ab5d356.js"><link rel="prefetch" href="/docs/assets/js/131.c492ab77.js"><link rel="prefetch" href="/docs/assets/js/132.cdffe102.js"><link rel="prefetch" href="/docs/assets/js/133.b8ddabfe.js"><link rel="prefetch" href="/docs/assets/js/134.b620b9d4.js"><link rel="prefetch" href="/docs/assets/js/135.319d46ae.js"><link rel="prefetch" href="/docs/assets/js/136.ad49e98a.js"><link rel="prefetch" href="/docs/assets/js/137.6c08b95a.js"><link rel="prefetch" href="/docs/assets/js/138.749f3bd8.js"><link rel="prefetch" href="/docs/assets/js/139.b47ccbe5.js"><link rel="prefetch" href="/docs/assets/js/14.07679cb7.js"><link rel="prefetch" href="/docs/assets/js/140.5312ba60.js"><link rel="prefetch" href="/docs/assets/js/141.1408bb95.js"><link rel="prefetch" href="/docs/assets/js/142.7bf3cf9e.js"><link rel="prefetch" href="/docs/assets/js/143.7217628b.js"><link rel="prefetch" href="/docs/assets/js/144.a7d93a0b.js"><link rel="prefetch" href="/docs/assets/js/145.c39216ff.js"><link rel="prefetch" href="/docs/assets/js/146.97697718.js"><link rel="prefetch" href="/docs/assets/js/147.5aa792cc.js"><link rel="prefetch" href="/docs/assets/js/148.20064994.js"><link rel="prefetch" href="/docs/assets/js/149.c3741c9e.js"><link rel="prefetch" href="/docs/assets/js/15.900e8e52.js"><link rel="prefetch" href="/docs/assets/js/150.0a15016f.js"><link rel="prefetch" href="/docs/assets/js/151.93f93478.js"><link rel="prefetch" href="/docs/assets/js/152.27901f63.js"><link rel="prefetch" href="/docs/assets/js/153.a2ee3001.js"><link rel="prefetch" href="/docs/assets/js/154.0ad769a7.js"><link rel="prefetch" href="/docs/assets/js/155.122ec937.js"><link rel="prefetch" href="/docs/assets/js/156.dc8c2784.js"><link rel="prefetch" href="/docs/assets/js/157.dadc3a73.js"><link rel="prefetch" href="/docs/assets/js/158.f1b18e58.js"><link rel="prefetch" href="/docs/assets/js/159.345ae097.js"><link rel="prefetch" href="/docs/assets/js/16.d847cafd.js"><link rel="prefetch" href="/docs/assets/js/160.48bb50b7.js"><link rel="prefetch" href="/docs/assets/js/161.41f7c5fd.js"><link rel="prefetch" href="/docs/assets/js/162.c49506b7.js"><link rel="prefetch" href="/docs/assets/js/163.73d9030f.js"><link rel="prefetch" href="/docs/assets/js/164.b3de694e.js"><link rel="prefetch" href="/docs/assets/js/165.fbcc3898.js"><link rel="prefetch" href="/docs/assets/js/166.ceeff642.js"><link rel="prefetch" href="/docs/assets/js/167.93d4b29d.js"><link rel="prefetch" href="/docs/assets/js/168.6ea54abc.js"><link rel="prefetch" href="/docs/assets/js/169.d31eb302.js"><link rel="prefetch" href="/docs/assets/js/17.bcf6bc1c.js"><link rel="prefetch" href="/docs/assets/js/170.bf54ded9.js"><link rel="prefetch" href="/docs/assets/js/171.74673a4b.js"><link rel="prefetch" href="/docs/assets/js/172.0473f907.js"><link rel="prefetch" href="/docs/assets/js/173.a6600c37.js"><link rel="prefetch" href="/docs/assets/js/174.45130bdf.js"><link rel="prefetch" href="/docs/assets/js/175.fab02b59.js"><link rel="prefetch" href="/docs/assets/js/176.ccae12ea.js"><link rel="prefetch" href="/docs/assets/js/177.d0e1556b.js"><link rel="prefetch" href="/docs/assets/js/178.3b85d348.js"><link rel="prefetch" href="/docs/assets/js/179.c420c4ab.js"><link rel="prefetch" href="/docs/assets/js/18.735c1059.js"><link rel="prefetch" href="/docs/assets/js/180.aaac8151.js"><link rel="prefetch" href="/docs/assets/js/181.85324139.js"><link rel="prefetch" href="/docs/assets/js/182.26a0b38f.js"><link rel="prefetch" href="/docs/assets/js/183.fce33668.js"><link rel="prefetch" href="/docs/assets/js/184.002740c1.js"><link rel="prefetch" href="/docs/assets/js/185.4a153923.js"><link rel="prefetch" href="/docs/assets/js/186.2cf312bc.js"><link rel="prefetch" href="/docs/assets/js/187.80950751.js"><link rel="prefetch" href="/docs/assets/js/188.c4aa36c7.js"><link rel="prefetch" href="/docs/assets/js/189.542ba5d9.js"><link rel="prefetch" href="/docs/assets/js/19.c78a01c3.js"><link rel="prefetch" href="/docs/assets/js/190.5fbba984.js"><link rel="prefetch" href="/docs/assets/js/191.bf2d0f98.js"><link rel="prefetch" href="/docs/assets/js/192.ffa32980.js"><link rel="prefetch" href="/docs/assets/js/193.ab95bde4.js"><link rel="prefetch" href="/docs/assets/js/194.dc1df407.js"><link rel="prefetch" href="/docs/assets/js/195.adb346a3.js"><link rel="prefetch" href="/docs/assets/js/196.4c2eae86.js"><link rel="prefetch" href="/docs/assets/js/197.2dbe570a.js"><link rel="prefetch" href="/docs/assets/js/198.99de4551.js"><link rel="prefetch" href="/docs/assets/js/199.9f5f9016.js"><link rel="prefetch" href="/docs/assets/js/20.58d0649e.js"><link rel="prefetch" href="/docs/assets/js/200.9f23f2eb.js"><link rel="prefetch" href="/docs/assets/js/201.c0a43a8a.js"><link rel="prefetch" href="/docs/assets/js/202.db70f5a3.js"><link rel="prefetch" href="/docs/assets/js/203.e66c722c.js"><link rel="prefetch" href="/docs/assets/js/204.2353953d.js"><link rel="prefetch" href="/docs/assets/js/205.fa71faac.js"><link rel="prefetch" href="/docs/assets/js/206.6a6ced7e.js"><link rel="prefetch" href="/docs/assets/js/207.6906c12a.js"><link rel="prefetch" href="/docs/assets/js/208.723014bd.js"><link rel="prefetch" href="/docs/assets/js/209.c2811971.js"><link rel="prefetch" href="/docs/assets/js/21.57537d24.js"><link rel="prefetch" href="/docs/assets/js/210.9b8b33ff.js"><link rel="prefetch" href="/docs/assets/js/211.18aab1c6.js"><link rel="prefetch" href="/docs/assets/js/212.54c3c15f.js"><link rel="prefetch" href="/docs/assets/js/213.2857d1fb.js"><link rel="prefetch" href="/docs/assets/js/214.4a9f2369.js"><link rel="prefetch" href="/docs/assets/js/215.9894ab1e.js"><link rel="prefetch" href="/docs/assets/js/216.41fbd9bf.js"><link rel="prefetch" href="/docs/assets/js/217.0db94502.js"><link rel="prefetch" href="/docs/assets/js/218.09d20294.js"><link rel="prefetch" href="/docs/assets/js/219.e0dbfc8f.js"><link rel="prefetch" href="/docs/assets/js/22.87795c35.js"><link rel="prefetch" href="/docs/assets/js/220.ed57ff1a.js"><link rel="prefetch" href="/docs/assets/js/221.4da422e7.js"><link rel="prefetch" href="/docs/assets/js/222.3e4a3d66.js"><link rel="prefetch" href="/docs/assets/js/223.06ae174d.js"><link rel="prefetch" href="/docs/assets/js/224.12197d84.js"><link rel="prefetch" href="/docs/assets/js/225.3d1891d6.js"><link rel="prefetch" href="/docs/assets/js/226.d05cf1f6.js"><link rel="prefetch" href="/docs/assets/js/227.6a5fce3d.js"><link rel="prefetch" href="/docs/assets/js/228.c72eb1f3.js"><link rel="prefetch" href="/docs/assets/js/229.5e68aa69.js"><link rel="prefetch" href="/docs/assets/js/23.81ed76f3.js"><link rel="prefetch" href="/docs/assets/js/230.ab0b8597.js"><link rel="prefetch" href="/docs/assets/js/231.f3b6948a.js"><link rel="prefetch" href="/docs/assets/js/232.fa1b3f66.js"><link rel="prefetch" href="/docs/assets/js/233.838e703c.js"><link rel="prefetch" href="/docs/assets/js/234.ca86cc33.js"><link rel="prefetch" href="/docs/assets/js/235.822cf437.js"><link rel="prefetch" href="/docs/assets/js/236.bf6774ae.js"><link rel="prefetch" href="/docs/assets/js/237.60dddcca.js"><link rel="prefetch" href="/docs/assets/js/238.27758d6c.js"><link rel="prefetch" href="/docs/assets/js/239.5a70c12f.js"><link rel="prefetch" href="/docs/assets/js/24.d2370ee2.js"><link rel="prefetch" href="/docs/assets/js/240.12d901a8.js"><link rel="prefetch" href="/docs/assets/js/241.a1e835e5.js"><link rel="prefetch" href="/docs/assets/js/242.363d5175.js"><link rel="prefetch" href="/docs/assets/js/243.8747c6ff.js"><link rel="prefetch" href="/docs/assets/js/244.430113a4.js"><link rel="prefetch" href="/docs/assets/js/245.c89b39b3.js"><link rel="prefetch" href="/docs/assets/js/246.6febca34.js"><link rel="prefetch" href="/docs/assets/js/248.2d4f5d30.js"><link rel="prefetch" href="/docs/assets/js/249.fc1c94f3.js"><link rel="prefetch" href="/docs/assets/js/25.8ad77d9e.js"><link rel="prefetch" href="/docs/assets/js/250.48b23fbc.js"><link rel="prefetch" href="/docs/assets/js/251.2a20c8fb.js"><link rel="prefetch" href="/docs/assets/js/252.c91b6f23.js"><link rel="prefetch" href="/docs/assets/js/253.e308c5e0.js"><link rel="prefetch" href="/docs/assets/js/254.6b0c43c0.js"><link rel="prefetch" href="/docs/assets/js/255.1a47f4e3.js"><link rel="prefetch" href="/docs/assets/js/256.a7e2052d.js"><link rel="prefetch" href="/docs/assets/js/257.0e1a5068.js"><link rel="prefetch" href="/docs/assets/js/258.a0d6b6ff.js"><link rel="prefetch" href="/docs/assets/js/259.474af441.js"><link rel="prefetch" href="/docs/assets/js/26.635d8053.js"><link rel="prefetch" href="/docs/assets/js/260.6838bb79.js"><link rel="prefetch" href="/docs/assets/js/261.e9069cba.js"><link rel="prefetch" href="/docs/assets/js/262.36756892.js"><link rel="prefetch" href="/docs/assets/js/263.e7d5d197.js"><link rel="prefetch" href="/docs/assets/js/264.e096ff4d.js"><link rel="prefetch" href="/docs/assets/js/265.77ccfa7f.js"><link rel="prefetch" href="/docs/assets/js/266.6c345dac.js"><link rel="prefetch" href="/docs/assets/js/267.4ba2d9f4.js"><link rel="prefetch" href="/docs/assets/js/268.68b74f9d.js"><link rel="prefetch" href="/docs/assets/js/269.26d6f3f7.js"><link rel="prefetch" href="/docs/assets/js/27.aca0df3b.js"><link rel="prefetch" href="/docs/assets/js/270.7e0f5a12.js"><link rel="prefetch" href="/docs/assets/js/271.76ce4b1c.js"><link rel="prefetch" href="/docs/assets/js/272.6d3764a7.js"><link rel="prefetch" href="/docs/assets/js/273.5f7b6490.js"><link rel="prefetch" href="/docs/assets/js/274.91c64234.js"><link rel="prefetch" href="/docs/assets/js/275.59ad7ebc.js"><link rel="prefetch" href="/docs/assets/js/276.acd5263a.js"><link rel="prefetch" href="/docs/assets/js/277.5df95550.js"><link rel="prefetch" href="/docs/assets/js/278.ea7805bf.js"><link rel="prefetch" href="/docs/assets/js/279.30d689f9.js"><link rel="prefetch" href="/docs/assets/js/28.cb80dd59.js"><link rel="prefetch" href="/docs/assets/js/280.bf8cf3e0.js"><link rel="prefetch" href="/docs/assets/js/281.c038ce3e.js"><link rel="prefetch" href="/docs/assets/js/282.8702b9ea.js"><link rel="prefetch" href="/docs/assets/js/283.5088b4d8.js"><link rel="prefetch" href="/docs/assets/js/284.f1584b44.js"><link rel="prefetch" href="/docs/assets/js/285.d834587c.js"><link rel="prefetch" href="/docs/assets/js/286.7039cb07.js"><link rel="prefetch" href="/docs/assets/js/287.c026d47d.js"><link rel="prefetch" href="/docs/assets/js/288.1e0ac287.js"><link rel="prefetch" href="/docs/assets/js/289.79029861.js"><link rel="prefetch" href="/docs/assets/js/290.a1669ad8.js"><link rel="prefetch" href="/docs/assets/js/291.e204722f.js"><link rel="prefetch" href="/docs/assets/js/292.7bc42395.js"><link rel="prefetch" href="/docs/assets/js/293.f54c4960.js"><link rel="prefetch" href="/docs/assets/js/294.0fa3645e.js"><link rel="prefetch" href="/docs/assets/js/295.b52d215c.js"><link rel="prefetch" href="/docs/assets/js/296.9fd8ad49.js"><link rel="prefetch" href="/docs/assets/js/297.1a4684a0.js"><link rel="prefetch" href="/docs/assets/js/298.3ef4da17.js"><link rel="prefetch" href="/docs/assets/js/299.e7d5bfa9.js"><link rel="prefetch" href="/docs/assets/js/3.f573405e.js"><link rel="prefetch" href="/docs/assets/js/30.fa4666aa.js"><link rel="prefetch" href="/docs/assets/js/300.1a24d773.js"><link rel="prefetch" href="/docs/assets/js/301.f37bd4e4.js"><link rel="prefetch" href="/docs/assets/js/302.1864286f.js"><link rel="prefetch" href="/docs/assets/js/303.fc25a2a5.js"><link rel="prefetch" href="/docs/assets/js/304.e2154134.js"><link rel="prefetch" href="/docs/assets/js/305.4ad273ab.js"><link rel="prefetch" href="/docs/assets/js/306.7ec42f5d.js"><link rel="prefetch" href="/docs/assets/js/307.cb991f3e.js"><link rel="prefetch" href="/docs/assets/js/308.b467ec0d.js"><link rel="prefetch" href="/docs/assets/js/309.6189aeea.js"><link rel="prefetch" href="/docs/assets/js/31.7b270c48.js"><link rel="prefetch" href="/docs/assets/js/310.68810fe6.js"><link rel="prefetch" href="/docs/assets/js/311.99f08daa.js"><link rel="prefetch" href="/docs/assets/js/312.9c69deab.js"><link rel="prefetch" href="/docs/assets/js/313.a5138bd2.js"><link rel="prefetch" href="/docs/assets/js/314.75e21e9d.js"><link rel="prefetch" href="/docs/assets/js/315.91f23467.js"><link rel="prefetch" href="/docs/assets/js/316.34f3b60e.js"><link rel="prefetch" href="/docs/assets/js/317.9182a681.js"><link rel="prefetch" href="/docs/assets/js/318.97118792.js"><link rel="prefetch" href="/docs/assets/js/319.2d90c5c2.js"><link rel="prefetch" href="/docs/assets/js/32.494d1a1e.js"><link rel="prefetch" href="/docs/assets/js/320.aa2c4af0.js"><link rel="prefetch" href="/docs/assets/js/321.2d69b637.js"><link rel="prefetch" href="/docs/assets/js/322.47fceb9f.js"><link rel="prefetch" href="/docs/assets/js/323.c445afc6.js"><link rel="prefetch" href="/docs/assets/js/324.a193ec6c.js"><link rel="prefetch" href="/docs/assets/js/325.5b502ace.js"><link rel="prefetch" href="/docs/assets/js/326.f1840e03.js"><link rel="prefetch" href="/docs/assets/js/327.d2534b23.js"><link rel="prefetch" href="/docs/assets/js/328.cb9b3c38.js"><link rel="prefetch" href="/docs/assets/js/329.5547b3ce.js"><link rel="prefetch" href="/docs/assets/js/33.7f058ceb.js"><link rel="prefetch" href="/docs/assets/js/330.11490c6a.js"><link rel="prefetch" href="/docs/assets/js/331.0e1ec937.js"><link rel="prefetch" href="/docs/assets/js/332.ba325e75.js"><link rel="prefetch" href="/docs/assets/js/333.1adfbf32.js"><link rel="prefetch" href="/docs/assets/js/334.507e4f13.js"><link rel="prefetch" href="/docs/assets/js/335.5a483a7d.js"><link rel="prefetch" href="/docs/assets/js/336.b6608aab.js"><link rel="prefetch" href="/docs/assets/js/337.2ff35851.js"><link rel="prefetch" href="/docs/assets/js/338.ee2bddd1.js"><link rel="prefetch" href="/docs/assets/js/339.86112c1d.js"><link rel="prefetch" href="/docs/assets/js/34.425b6840.js"><link rel="prefetch" href="/docs/assets/js/340.2418439c.js"><link rel="prefetch" href="/docs/assets/js/341.5f94fd9d.js"><link rel="prefetch" href="/docs/assets/js/342.4e0cda19.js"><link rel="prefetch" href="/docs/assets/js/343.413436d6.js"><link rel="prefetch" href="/docs/assets/js/344.ca6ffdf8.js"><link rel="prefetch" href="/docs/assets/js/345.15daa7b8.js"><link rel="prefetch" href="/docs/assets/js/346.4a29d7e4.js"><link rel="prefetch" href="/docs/assets/js/347.c23877ef.js"><link rel="prefetch" href="/docs/assets/js/348.23b63085.js"><link rel="prefetch" href="/docs/assets/js/349.363c0f6b.js"><link rel="prefetch" href="/docs/assets/js/35.0c39e54a.js"><link rel="prefetch" href="/docs/assets/js/350.e16f06bd.js"><link rel="prefetch" href="/docs/assets/js/351.14a1bb66.js"><link rel="prefetch" href="/docs/assets/js/352.621e20e9.js"><link rel="prefetch" href="/docs/assets/js/353.fdf17b6d.js"><link rel="prefetch" href="/docs/assets/js/354.05108263.js"><link rel="prefetch" href="/docs/assets/js/355.b7de2e8d.js"><link rel="prefetch" href="/docs/assets/js/356.84cbdb60.js"><link rel="prefetch" href="/docs/assets/js/357.45e1a2b7.js"><link rel="prefetch" href="/docs/assets/js/358.2e0e6656.js"><link rel="prefetch" href="/docs/assets/js/36.d3c135e6.js"><link rel="prefetch" href="/docs/assets/js/37.874de59a.js"><link rel="prefetch" href="/docs/assets/js/38.1962fc4a.js"><link rel="prefetch" href="/docs/assets/js/39.6a260188.js"><link rel="prefetch" href="/docs/assets/js/4.2b88aac7.js"><link rel="prefetch" href="/docs/assets/js/40.47d632a8.js"><link rel="prefetch" href="/docs/assets/js/41.2c5bdc8c.js"><link rel="prefetch" href="/docs/assets/js/42.00a5ecbf.js"><link rel="prefetch" href="/docs/assets/js/43.0c9a2e4b.js"><link rel="prefetch" href="/docs/assets/js/44.cb465731.js"><link rel="prefetch" href="/docs/assets/js/45.4896f3f5.js"><link rel="prefetch" href="/docs/assets/js/46.3f8f8288.js"><link rel="prefetch" href="/docs/assets/js/47.4a19ef83.js"><link rel="prefetch" href="/docs/assets/js/48.5ccaba9e.js"><link rel="prefetch" href="/docs/assets/js/49.50fe6149.js"><link rel="prefetch" href="/docs/assets/js/5.e960e10b.js"><link rel="prefetch" href="/docs/assets/js/50.6dc428c2.js"><link rel="prefetch" href="/docs/assets/js/51.db99cd55.js"><link rel="prefetch" href="/docs/assets/js/52.fcbfb1d0.js"><link rel="prefetch" href="/docs/assets/js/53.96a4068d.js"><link rel="prefetch" href="/docs/assets/js/54.d214c465.js"><link rel="prefetch" href="/docs/assets/js/55.089feb14.js"><link rel="prefetch" href="/docs/assets/js/56.aa7775e2.js"><link rel="prefetch" href="/docs/assets/js/57.80488c74.js"><link rel="prefetch" href="/docs/assets/js/58.62f5cd45.js"><link rel="prefetch" href="/docs/assets/js/59.9fd2c826.js"><link rel="prefetch" href="/docs/assets/js/6.89ffc59a.js"><link rel="prefetch" href="/docs/assets/js/60.8ed33fb9.js"><link rel="prefetch" href="/docs/assets/js/61.1575f067.js"><link rel="prefetch" href="/docs/assets/js/62.0b6ac41e.js"><link rel="prefetch" href="/docs/assets/js/63.74551334.js"><link rel="prefetch" href="/docs/assets/js/64.6db70e6f.js"><link rel="prefetch" href="/docs/assets/js/65.541cd3bf.js"><link rel="prefetch" href="/docs/assets/js/66.3ba21e1d.js"><link rel="prefetch" href="/docs/assets/js/67.993533bf.js"><link rel="prefetch" href="/docs/assets/js/68.69f45f6b.js"><link rel="prefetch" href="/docs/assets/js/69.d4736f3c.js"><link rel="prefetch" href="/docs/assets/js/7.1a93e7b7.js"><link rel="prefetch" href="/docs/assets/js/70.f42adebf.js"><link rel="prefetch" href="/docs/assets/js/71.320a284e.js"><link rel="prefetch" href="/docs/assets/js/72.607e43e9.js"><link rel="prefetch" href="/docs/assets/js/73.6a1a899a.js"><link rel="prefetch" href="/docs/assets/js/74.d74f0b47.js"><link rel="prefetch" href="/docs/assets/js/75.4274e520.js"><link rel="prefetch" href="/docs/assets/js/76.7a8f3d72.js"><link rel="prefetch" href="/docs/assets/js/77.9a06a773.js"><link rel="prefetch" href="/docs/assets/js/78.64cdb317.js"><link rel="prefetch" href="/docs/assets/js/79.1d3efe73.js"><link rel="prefetch" href="/docs/assets/js/8.68d11745.js"><link rel="prefetch" href="/docs/assets/js/80.24fa033a.js"><link rel="prefetch" href="/docs/assets/js/81.98bc4f83.js"><link rel="prefetch" href="/docs/assets/js/82.569b6933.js"><link rel="prefetch" href="/docs/assets/js/83.c5dd16c3.js"><link rel="prefetch" href="/docs/assets/js/84.23af47b9.js"><link rel="prefetch" href="/docs/assets/js/85.529fb7c3.js"><link rel="prefetch" href="/docs/assets/js/86.f98430df.js"><link rel="prefetch" href="/docs/assets/js/87.0b4f0613.js"><link rel="prefetch" href="/docs/assets/js/88.1b4c8cfa.js"><link rel="prefetch" href="/docs/assets/js/89.c41fdccf.js"><link rel="prefetch" href="/docs/assets/js/9.6a89a7f5.js"><link rel="prefetch" href="/docs/assets/js/90.5face7f5.js"><link rel="prefetch" href="/docs/assets/js/91.1a530310.js"><link rel="prefetch" href="/docs/assets/js/92.e3dace04.js"><link rel="prefetch" href="/docs/assets/js/93.0d0ae41c.js"><link rel="prefetch" href="/docs/assets/js/94.ae112242.js"><link rel="prefetch" href="/docs/assets/js/95.14837e23.js"><link rel="prefetch" href="/docs/assets/js/96.67801895.js"><link rel="prefetch" href="/docs/assets/js/97.b8db2483.js"><link rel="prefetch" href="/docs/assets/js/98.0f1aaf01.js"><link rel="prefetch" href="/docs/assets/js/99.8d25df0f.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.5d974432.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">Nguyễn Khánk's Wiki</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/docs/architect/" class="nav-link">
  Architecture
</a></div><div class="nav-item"><a href="/docs/kungfu/letsgo.html" class="nav-link">
  Kungfu
</a></div><div class="nav-item"><a href="https://nguyenngockhank.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Home
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/docs/architect/" class="nav-link">
  Architecture
</a></div><div class="nav-item"><a href="/docs/kungfu/letsgo.html" class="nav-link">
  Kungfu
</a></div><div class="nav-item"><a href="https://nguyenngockhank.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Home
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>The Art of Readable Code</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/kungfu/artofcode/c1.html" class="sidebar-link">1. Code Should Be Easy to Understand</a></li><li><a href="/docs/kungfu/artofcode/c2.html" class="sidebar-link">2. Packing Information into Names</a></li><li><a href="/docs/kungfu/artofcode/c3.html" class="sidebar-link">3. Names That Can’t Be Misconstrued</a></li><li><a href="/docs/kungfu/artofcode/c4.html" class="sidebar-link">4. Aesthetics</a></li><li><a href="/docs/kungfu/artofcode/c5.html" class="sidebar-link">5. Knowing What to Comment</a></li><li><a href="/docs/kungfu/artofcode/c6.html" class="sidebar-link">6. Making Comments Precise and Compact</a></li><li><a href="/docs/kungfu/artofcode/c7.html" class="sidebar-link">7. Making Control Flow Easy to Read</a></li><li><a href="/docs/kungfu/artofcode/c8.html" class="sidebar-link">8. Breaking Down Giant Expressions</a></li><li><a href="/docs/kungfu/artofcode/c9.html" class="sidebar-link">9. Variables and Readability</a></li><li><a href="/docs/kungfu/artofcode/c10.html" class="sidebar-link">10. Extracting Unrelated Subproblems</a></li><li><a href="/docs/kungfu/artofcode/c11.html" class="sidebar-link">11. One Task at a Time</a></li><li><a href="/docs/kungfu/artofcode/c12.html" class="sidebar-link">12. Turning Thoughts into Code</a></li><li><a href="/docs/kungfu/artofcode/c13.html" class="sidebar-link">13. Writing Less Code</a></li><li><a href="/docs/kungfu/artofcode/c14.html" class="sidebar-link">14. Testing and Readability</a></li><li><a href="/docs/kungfu/artofcode/c15.html" class="sidebar-link">15. Designing and Implementing a “Minute/Hour Counter”</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Clean Code</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>A Philosophy of Software Design</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Building Microservices</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>97 Things Every Programmer Should Know</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>NoSql Distilled</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Others</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h5 id="_317"><a href="#_317" class="header-anchor">#</a> 317</h5> <h1 id="appendix-a"><a href="#appendix-a" class="header-anchor">#</a> Appendix A</h1> <h2 id="concurrency-ii"><a href="#concurrency-ii" class="header-anchor">#</a> Concurrency II</h2> <div class="language- extra-class"><pre class="language-text"><code>by Brett L. Schuchert
</code></pre></div><p>This appendix supports and amplifies the <em>Concurrency</em> chapter on page 177. It is written
as a series of independent topics and you can generally read them in any order. There is
some duplication between sections to allow for such reading.</p> <h3 id="client-server-example"><a href="#client-server-example" class="header-anchor">#</a> Client/Server Example ..</h3> <p>Imagine a simple client/server application. A server sits and waits listening on a socket for
a client to connect. A client connects and sends a request.</p> <h4 id="the-server"><a href="#the-server" class="header-anchor">#</a> The Server ..</h4> <p>Here is a simplified version of a server application. Full source for this example is avail-
able starting on page 343, <em>Client/Server Nonthreaded</em>.</p> <div class="language- extra-class"><pre class="language-text"><code>ServerSocket serverSocket = new ServerSocket(8009);
while (keepProcessing) {
try {
Socket socket = serverSocket.accept();
process(socket);
} catch (Exception e) {
handle(e);
}
}
</code></pre></div><p>318 <strong>Appendix A: Concurrency II</strong></p> <p>This simple application waits for a connection, processes an incoming message, and then
again waits for the next client request to come in. Here’s client code that connects to this
server:</p> <div class="language- extra-class"><pre class="language-text"><code>private void connectSendReceive(int i) {
try {
Socket socket = new Socket(&quot;localhost&quot;, PORT);
MessageUtils.sendMessage(socket, Integer.toString(i));
MessageUtils.getMessage(socket);
socket.close();
} catch (Exception e) {
e.printStackTrace();
}
}
</code></pre></div><p>How well does this client/server pair perform? How can we formally describe that perfor-
mance? Here’s a test that asserts that the performance is “acceptable”:</p> <div class="language- extra-class"><pre class="language-text"><code>@Test(timeout = 10000)
public void shouldRunInUnder10Seconds() throws Exception {
Thread[] threads = createThreads();
startAllThreadsw(threads);
waitForAllThreadsToFinish(threads);
}
</code></pre></div><p>The setup is left out to keep the example simple (see “ClientTest.java” on page 344). This
test asserts that it should complete within 10,000 milliseconds.</p> <p>This is a classic example of validating the throughput of a system. This system should
complete a series of client requests in ten seconds. So long as the server can process each
individual client request in time, the test will pass.</p> <p>What happens if the test fails? Short of developing some kind of event polling loop,
there is not much to do within a single thread that will make this code any faster. Will
using multiple threads solve the problem? It might, but we need to know where the time is
being spent. There are two possibilities:</p> <p><strong>-</strong> I/O—using a socket, connecting to a database, waiting for virtual memory swapping,
and so on.
<strong>-</strong> Processor—numerical calculations, regular expression processing, garbage collection,
and so on.</p> <p>Systems typically have some of each, but for a given operation one tends to dominate. If
the code is processor bound, more processing hardware can improve throughput, making
our test pass. But there are only so many CPU cycles available, so adding threads to a
processor-bound problem will not make it go faster.</p> <p>On the other hand, if the process is I/O bound, then concurrency can increase effi-
ciency. When one part of the system is waiting for I/O, another part can use that wait time
to process something else, making more effective use of the available CPU.</p> <p><strong>Client/Server Example</strong> 319</p> <h4 id="adding-threading"><a href="#adding-threading" class="header-anchor">#</a> Adding Threading...</h4> <p>Assume for the moment that the performance test fails. How can we improve the through-
put so that the performance test passes? If the process method of the server is I/O bound,
then here is one way to make the server use threads (just change the processMessage):</p> <div class="language- extra-class"><pre class="language-text"><code>void process(final Socket socket) {
if (socket == null)
return;
Runnable clientHandler = new Runnable() {
public void run() {
try {
String message = MessageUtils.getMessage(socket);
MessageUtils.sendMessage(socket, &quot;Processed: &quot; + message);
closeIgnoringException(socket);
} catch (Exception e) {
e.printStackTrace();
}
}
};
Thread clientConnection = new Thread(clientHandler);
clientConnection.start();
}
</code></pre></div><p>Assume that this change causes the test to pass;^1 the code is complete, correct?</p> <h4 id="server-observations"><a href="#server-observations" class="header-anchor">#</a> Server Observations ...</h4> <p>The updated server completes the test successfully in just over one second. Unfortunately,
this solution is a bit naive and introduces some new problems.</p> <p>How many threads might our server create? The code sets no limit, so the we could
feasibly hit the limit imposed by the Java Virtual Machine (JVM). For many simple sys-
tems this may suffice. But what if the system is meant to support many users on the public
net? If too many users connect at the same time, the system might grind to a halt.</p> <p>But set the behavioral problem aside for the moment. The solution shown has prob-
lems of cleanliness and structure. How many responsibilities does the server code have?</p> <p><strong>-</strong> Socket connection management
<strong>-</strong> Client processing
<strong>-</strong> Threading policy
<strong>-</strong> Server shutdown policy</p> <p>Unfortunately, all these responsibilities live in the process function. In addition, the
code crosses many different levels of abstraction. So, small as the process function is, it
needs to be repartitioned.</p> <ol><li>You can verify that for yourself by trying out the before and after code. Review the nonthreaded code starting on page 343.
Review the threaded code starting on page 346.</li></ol> <p>320 <strong>Appendix A: Concurrency II</strong></p> <p>The server has several reasons to change; therefore it violates the Single Responsibility
Principle. To keep concurrent systems clean, thread management should be kept to a few,
well-controlled places. What’s more, any code that manages threads should do nothing
other than thread management. Why? If for no other reason than that tracking down con-
currency issues is hard enough without having to unwind other nonconcurrency issues at
the same time.</p> <p>If we create a separate class for each of the responsibilities listed above, including the
thread management responsibility, then when we change the thread management strategy,
the change will impact less overall code and will not pollute the other responsibilities. This
also makes it much easier to test all the other responsibilities without having to worry
about threading. Here is an updated version that does just that:</p> <div class="language- extra-class"><pre class="language-text"><code>public void run() {
while (keepProcessing) {
try {
ClientConnection clientConnection = connectionManager.awaitClient();
ClientRequestProcessor requestProcessor
= new ClientRequestProcessor(clientConnection);
clientScheduler.schedule(requestProcessor);
} catch (Exception e) {
e.printStackTrace();
}
}
connectionManager.shutdown();
}
</code></pre></div><p>This now focuses all things thread-related into one place, clientScheduler. If there are
concurrency problems, there is just one place to look:</p> <div class="language- extra-class"><pre class="language-text"><code>public interface ClientScheduler {
void schedule(ClientRequestProcessor requestProcessor);
}
</code></pre></div><p>The current policy is easy to implement:</p> <div class="language- extra-class"><pre class="language-text"><code>public class ThreadPerRequestScheduler implements ClientScheduler {
public void schedule(final ClientRequestProcessor requestProcessor) {
Runnable runnable = new Runnable() {
public void run() {
requestProcessor.process();
}
};
Thread thread = new Thread(runnable);
thread.start();
}
}
</code></pre></div><p>Having isolated all the thread management into a single place, it is much easier to change
the way we control threads. For example, moving to the Java 5 Executor framework
involves writing a new class and plugging it in (Listing A-1).</p> <p><strong>Possible Paths of Execution</strong> 321</p> <h4 id="conclusion"><a href="#conclusion" class="header-anchor">#</a> Conclusion..</h4> <p>Introducing concurrency in this particular example demonstrates a way to improve the
throughput of a system and one way of validating that throughput through a testing frame-
work. Focusing all concurrency code into a small number of classes is an example of
applying the Single Responsibility Principle. In the case of concurrent programming, this
becomes especially important because of its complexity.</p> <h3 id="possible-paths-of-execution"><a href="#possible-paths-of-execution" class="header-anchor">#</a> Possible Paths of Execution ..</h3> <p>Review the method incrementValue, a one-line Java method with no looping or branching:</p> <div class="language- extra-class"><pre class="language-text"><code>public class IdGenerator {
int lastIdUsed;
public int incrementValue() {
return ++lastIdUsed;
}
}
</code></pre></div><p>Ignore integer overflow and assume that only one thread has access to a single instance
of IdGenerator. In this case there is a single path of execution and a single guaranteed
result:</p> <p><strong>-</strong> The value returned is equal to the value of lastIdUsed, both of which are one greater
than just before calling the method.</p> <div class="language- extra-class"><pre class="language-text"><code>Listing A-1
ExecutorClientScheduler.java
import java.util.concurrent.Executor;
import java.util.concurrent.Executors;
public class ExecutorClientScheduler implements ClientScheduler {
Executor executor;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>public ExecutorClientScheduler(int availableThreads) {
executor = Executors.newFixedThreadPool(availableThreads);
}
public void schedule(final ClientRequestProcessor requestProcessor) {
Runnable runnable = new Runnable() {
public void run() {
requestProcessor.process();
}
};
executor.execute(runnable);
}
}
</code></pre></div><p>322 <strong>Appendix A: Concurrency II</strong></p> <p>What happens if we use two threads and leave the method unchanged? What are the
possible outcomes if each thread calls incrementValue once? How many possible paths of
execution are there? First, the outcomes (assume lastIdUsed starts with a value of 93):</p> <p><strong>-</strong> Thread 1 gets the value of 94, thread 2 gets the value of 95, and lastIdUsed is now 95.
<strong>-</strong> Thread 1 gets the value of 95, thread 2 gets the value of 94, and lastIdUsed is now 95.
<strong>-</strong> Thread 1 gets the value of 94, thread 2 gets the value of 94, and lastIdUsed is now 94.</p> <p>The final result, while surprising, is possible. To see how these different results are possi-
ble, we need to understand the number of possible paths of execution and how the Java
Virtual Machine executes them.</p> <h4 id="number-of-paths"><a href="#number-of-paths" class="header-anchor">#</a> Number of Paths .</h4> <p>To calculate the number of possible execution paths, we’ll start with the generated byte-
code. The one line of java (return ++lastIdUsed;) becomes eight byte-code instructions. It
is possible for the two threads to interleave the execution of these eight instructions the
way a card dealer interleaves cards as he shuffles a deck.^2 Even with only eight cards in
each hand, there are a remarkable number of shuffled outcomes.</p> <p>For this simple case of <em>N</em> instructions in a sequence, no looping or conditionals, and <em>T</em>
threads, the total number of possible execution paths is equal to</p> <ol start="2"><li>This is a bit of a simplification. However, for the purpose of this discussion, we can use this simplifying model.</li></ol> <div class="language- extra-class"><pre class="language-text"><code>Calculating the Possible Orderings
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>This comes from an email from Uncle Bob to Brett:
With N steps and T threads there are T * N total steps. Prior to each step
there is a context switch that chooses between the T threads. Each path can
thus be represented as a string of digits denoting the context switches.
Given steps A and B and threads 1 and 2, the six possible paths are 1122,
1212, 1221, 2112, 2121, and 2211. Or, in terms of steps it is A1B1A2B2,
A1A2B1B2, A1A2B2B1, A2A1B1B2, A2A1B2B1, and A2B2A1B1. For
three threads the sequence is 112233, 112323, 113223, 113232, 112233,
121233, 121323, 121332, 123132, 123123,
One characteristic of these strings is that there must always be N
instances of each T. So the string 111111 is invalid because it has six
instances of 1 and zero instances of 2 and 3.
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>() NT!
N! T
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>--------------
</code></pre></div><p><strong>Possible Paths of Execution</strong> 323</p> <p>For our simple case of one line of Java code, which equates to eight lines of byte-code
and two threads, the total number of possible paths of execution is 12,870. If the type of
lastIdUsed is a long, then every read/write becomes two operations instead of one, and the
number of possible orderings becomes 2,704,156.</p> <div class="language- extra-class"><pre class="language-text"><code>What happens if we make one change to this method?
public synchronized void incrementValue() {
++lastIdUsed;
}
</code></pre></div><p>The number of possible execution pathways becomes two for two threads and N! in the
general case.</p> <h4 id="digging-deeper"><a href="#digging-deeper" class="header-anchor">#</a> Digging Deeper ..</h4> <p>What about the surprising result that two threads could both call the method once (before
we added synchronized) and get the same numeric result? How is that possible? First
things first.</p> <p>What is an atomic operation? We can define an atomic operation as any operation that
is uninterruptable. For example, in the following code, line 5, where 0 is assigned to
lastid, is atomic because according to the Java Memory model, assignment to a 32-bit
value is uninterruptable.</p> <div class="language- extra-class"><pre class="language-text"><code>So we want the permutations of N 1’s, N 2’s,... and N T’ s. This is
really just the permutations of N * T things taken N * T at a time, which is
( N * T )!, but with all the duplicates removed. So the trick is to count the
duplicates and subtract that from ( N * T )!.
Given two steps and two threads, how many duplicates are there? Each
four-digit string has two 1s and two 2s. Each of those pairs could be
swapped without changing the sense of the string. You could swap the 1s or
the 2s both, or neither. So there are four isomorphs for each string, which
means that there are three duplicates. So three out of four of the options are
duplicates; alternatively one of four of the permutations are NOT dupli-
cates. 4! * .25 = 6. So this reasoning seems to work.
How many duplicates are there? In the case where N = 2 and T = 2, I
could swap the 1s, the 2s, or both. In the case where N = 2 and T = 3, I
could swap the 1s, the 2s, the 3s, 1s and 2s, 1s and 3s, or 2s and 3s. Swap-
ping is just the permutations of N. Let’s say there are P permutations of N.
The number of different ways to arrange those permutations are P ** T.
So the number of possible isomorphs is N !** T. And so the number of
paths is ( T * N )!/( N !** T ). Again, in our T = 2, N = 2 case we get 6 (24/4).
For N = 2 and T = 3 we get 720/8 = 90.
For N = 3 and T = 3 we get 9!/6^3 = 1680.
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>Calculating the Possible Orderings (continued)
</code></pre></div><p>324 <strong>Appendix A: Concurrency II</strong></p> <p>01: public class Example {
02: int lastId;
03:
04: public void resetId() {
05: value = 0;
06: }
07:
08: public int getNextId() {
09: ++value;
10: }
11:}
What happens if we change type of lastId from int to long? Is line 5 still atomic?
Not according to the JVM specification. It could be atomic on a particular processor,
but according to the JVM specification, assignment to any 64-bit value requires two
32-bit assignments. This means that between the first 32-bit assignment and the second
32-bit assignment, some other thread could sneak in and change one of the values.</p> <p>What about the pre-increment operator, ++, on line 9? The pre-increment operator can
be interrupted, so it is not atomic. To understand, let’s review the byte-code of both of these
methods in detail.</p> <div class="language- extra-class"><pre class="language-text"><code>Before we go any further, here are three definitions that will be important:
</code></pre></div><p><strong>-</strong> Frame—Every method invocation requires a frame. The frame includes the return
address, any parameters passed into the method and the local variables defined in the
method. This is a standard technique used to define a call stack, which is used by
modern languages to allow for basic function/method invocation and to allow for
recursive invocation.
<strong>-</strong> Local variable—Any variables defined in the scope of the method. All nonstatic meth-
ods have at least one variable, <strong>this</strong> , which represents the current object, the object
that received the most recent message (in the current thread), which caused the
method invocation.
<strong>-</strong> Operand stack—Many of the instructions in the Java Virtual Machine take parame-
ters. The operand stack is where those parameters are put. The stack is a standard
last-in, first-out (LIFO) data structure.</p> <div class="language- extra-class"><pre class="language-text"><code>Here is the byte-code generated for resetId():
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>Mnemonic Description Operand
Stack After
ALOAD 0 Load the 0th variable onto the operand stack.
What is the 0th variable? It is this ., the current
object. When the method was called, the
receiver of the message, an instance of Example,
was pushed into the local variable array of the
frame created for method invocation. This is
always the first variable put in every instance
method.
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>this
</code></pre></div><p><strong>Possible Paths of Execution</strong> 325</p> <p>These three instructions are guaranteed to be atomic because, although the thread
executing them could be interrupted after any one of them, the information for the
PUTFIELD instruction (the constant value 0 on the top of the stack and the reference to
this one below the top, along with the field value) cannot be touched by another thread.
So when the assignment occurs, we are guaranteed that the value 0 will be stored in the
field value. The operation is atomic. The operands all deal with information local to the
method, so there is no interference between multiple threads.</p> <p>So if these three instructions are executed by ten threads, there are 4.38679733629e+24
possible orderings. However, there is only one possible outcome, so the different orderings
are irrelevant. It just so happens that the same outcome is guaranteed for longs in this case
as well. Why? All ten threads are assigning a constant value. Even if they interleave with
each other, the end result is the same.</p> <p>With the ++ operation in the getNextId method, there are going to be problems.
Assume that lastId holds 42 at the beginning of this method. Here is the byte-code for this
new method:</p> <div class="language- extra-class"><pre class="language-text"><code>ICONST_0 Put the constant value 0 onto the operand stack. this, 0
PUTFIELD lastId Store the top value on the stack (which is 0) into
the field value of the object referred to by the
object reference one away from the top of the
stack, this.
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>&lt;empty&gt;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>Mnemonic Description Operand
Stack After
ALOAD 0 Load this onto the operand stack this
DUP Copy the top of the stack. We now have two
copies of this on the operand stack.
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>this, this
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>GETFIELD lastId Retrieve the value of the field lastId from the
object pointed to on the top of the stack (this) and
store that value back on to the stack.
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>this, 42
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>ICONST_1 Push the integer constant 1 on the stack. this, 42, 1
IADD Integer add the top two values on the operand
stack and store the result back on to the operand
stack.
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>this, 43
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>DUP_X1 Duplicate the value 43 and put it before this. 43, this, 43
PUTFIELD value Store the top value on the operand stack, 43, into
the field value of the current object, represented by
the next-to-top value on the operand stack, this.
</code></pre></div><h5 id="_43"><a href="#_43" class="header-anchor">#</a> 43</h5> <div class="language- extra-class"><pre class="language-text"><code>IRETURN return the top (and only) value on the stack. &lt;empty&gt;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>Mnemonic Description Operand
Stack After
</code></pre></div><p>326 <strong>Appendix A: Concurrency II</strong></p> <p>Imagine the case where the first thread completes the first three instructions, up to and
including GETFIELD, and then it is interrupted. A second thread takes over and performs
the entire method, incrementing lastId by one; it gets 43 back. Then the first thread picks up
where it left off; 42 is still on the operand stack because that was the value of lastId when it
executed GETFIELD. It adds one to get 43 again and stores the result. The value 43 is
returned to the first thread as well. The result is that one of the increments is lost because the
first thread stepped on the second thread after the second thread interrupted the first thread.</p> <div class="language- extra-class"><pre class="language-text"><code>Making the getNexId() method synchronized fixes this problem.
</code></pre></div><h4 id="conclusion-2"><a href="#conclusion-2" class="header-anchor">#</a> Conclusion..</h4> <p>An intimate understanding of byte-code is not necessary to understand how threads can
step on each other. If you can understand this one example, it should demonstrate the pos-
sibility of multiple threads stepping on each other, which is enough knowledge.</p> <p>That being said, what this trivial example demonstrates is a need to understand the
memory model enough to know what is and is not safe. It is a common misconception that
the ++ (pre- or post-increment) operator is atomic, and it clearly is not. This means you
need to know:</p> <p><strong>-</strong> Where there are shared objects/values
<strong>-</strong> The code that can cause concurrent read/update issues
<strong>-</strong> How to guard such concurrent issues from happening</p> <h3 id="knowing-your-library"><a href="#knowing-your-library" class="header-anchor">#</a> Knowing Your Library ..</h3> <h4 id="executor-framework"><a href="#executor-framework" class="header-anchor">#</a> Executor Framework ..</h4> <p>As demonstrated in the ExecutorClientScheduler.java on page 321, the Executor frame-
work introduced in Java 5 allows for sophisticated execution using thread pools. This is a
class in the java.util.concurrent package.</p> <p>If you are creating threads and are not using a thread pool or <em>are</em> using a hand-written
one, you should consider using the Executor. It will make your code cleaner, easier to fol-
low, and smaller.</p> <p>The Executor framework will pool threads, resize automatically, and recreate threads
if necessary. It also supports <em>futures,</em> a common concurrent programming construct. The
Executor framework works with classes that implement Runnable and also works with
classes that implement the Callable interface. A Callable looks like a Runnable, but it can
return a result, which is a common need in multithreaded solutions.</p> <p>A <em>future</em> is handy when code needs to execute multiple, independent operations and
wait for both to finish:</p> <div class="language- extra-class"><pre class="language-text"><code>public String processRequest(String message) throws Exception {
Callable&lt;String&gt; makeExternalCall = new Callable&lt;String&gt;() {
</code></pre></div><p><strong>Knowing Your Library</strong> 327</p> <div class="language- extra-class"><pre class="language-text"><code>public String call() throws Exception {
String result = &quot;&quot;;
// make external request
return result;
}
};
Future&lt;String&gt; result = executorService.submit(makeExternalCall);
String partialResult = doSomeLocalProcessing();
return result.get() + partialResult;
}
</code></pre></div><p>In this example, the method starts executing the makeExternalCall object. The method con-
tinues other processing. The final line calls result.get(), which blocks until the future
completes.</p> <h4 id="nonblocking-solutions"><a href="#nonblocking-solutions" class="header-anchor">#</a> Nonblocking Solutions ...</h4> <p>The Java 5 VM takes advantage of modern processor design, which supports reliable,
nonblocking updates. Consider, for example, a class that uses synchronization (and there-
fore blocking) to provide a thread-safe update of a value:</p> <p>public class ObjectWithValue {
private int value;
public void synchronized incrementValue() { ++value; }
public int getValue() { return value; }
}
Java 5 has a series of new classes for situations like this: AtomicBoolean,
AtomicInteger, and AtomicReference are three examples; there are several more. We can
rewrite the above code to use a nonblocking approach as follows:</p> <div class="language- extra-class"><pre class="language-text"><code>public class ObjectWithValue {
private AtomicInteger value = new AtomicInteger(0);
public void incrementValue() {
value.incrementAndGet();
}
public int getValue() {
return value.get();
}
}
</code></pre></div><p>Even though this uses an object instead of a primitive and sends messages like
incrementAndGet() instead of ++, the performance of this class will nearly always beat the
previous version. In some cases it will only be slightly faster, but the cases where it will be
slower are virtually nonexistent.</p> <p>How is this possible? Modern processors have an operation typically called <em>Compare
and Swap (CAS)</em>. This operation is analogous to optimistic locking in databases, whereas
the synchronized version is analogous to pessimistic locking.</p> <p>328 <strong>Appendix A: Concurrency II</strong></p> <p>The synchronized keyword always acquires a lock, even when a second thread is not
trying to update the same value. Even though the performance of intrinsic locks has
improved from version to version, they are still costly.</p> <p>The nonblocking version starts with the assumption that multiple threads generally do
not modify the same value often enough that a problem will arise. Instead, it efficiently
detects whether such a situation has occurred and retries until the update happens success-
fully. This detection is almost always less costly than acquiring a lock, even in moderate to
high contention situations.</p> <p>How does the Virtual Machine accomplish this? The CAS operation is atomic. Logi-
cally, the CAS operation looks something like the following:</p> <p>int variableBeingSet;
void simulateNonBlockingSet(int newValue) {
int currentValue;
do {
currentValue = variableBeingSet
} while(currentValue != compareAndSwap(currentValue, newValue));
}
int synchronized compareAndSwap(int currentValue, int newValue) {
if(variableBeingSet == currentValue) {
variableBeingSet = newValue;
return currentValue;
}
return variableBeingSet;
}
When a method attempts to update a shared variable, the CAS operation verifies that
the variable getting set still has the last known value. If so, then the variable is changed. If
not, then the variable is not set because another thread managed to get in the way. The
method making the attempt (using the CAS operation) sees that the change was not made
and retries.</p> <h4 id="nonthread-safe-classes"><a href="#nonthread-safe-classes" class="header-anchor">#</a> Nonthread-Safe Classes..</h4> <p>There are some classes that are inherently not thread safe. Here are a few examples:</p> <p><strong>-</strong> SimpleDateFormat
<strong>-</strong> Database Connections
<strong>-</strong> Containers in java.util
<strong>-</strong> Servlets</p> <p>Note that some collection classes have individual methods that are thread-safe. However,
any operation that involves calling more than one method is not. For example, if you do
not want to replace something in a HashTable because it is already there, you might write
the following code:</p> <div class="language- extra-class"><pre class="language-text"><code>if(!hashTable.containsKey(someKey)) {
hashTable.put(someKey, new SomeValue());
}
</code></pre></div><p><strong>Dependencies Between Methods Can Break Concurrent Code</strong> 329</p> <p>Each individual method is thread-safe. However, another thread might add a value in
between the containsKey and put calls. There are several options to fix this problem.</p> <p><strong>-</strong> Lock the HashTable first, and make sure all other users of the HashTable do the same—
client-based locking:
synchronized(map) {
if(!map.conainsKey(key))
map.put(key,value);
}
<strong>-</strong> Wrap the HashTable in its own object and use a different API—server-based locking
using an ADAPTER:
public class WrappedHashtable&lt;K, V&gt; {
private Map&lt;K, V&gt; map = new Hashtable&lt;K, V&gt;();
public synchronized void putIfAbsent(K key, V value) {
if (map.containsKey(key))
map.put(key, value);
}
}
<strong>-</strong> Use the thread-safe collections:</p> <div class="language- extra-class"><pre class="language-text"><code>ConcurrentHashMap&lt;Integer, String&gt; map = new ConcurrentHashMap&lt;Integer,
String&gt;();
map.putIfAbsent(key, value);
</code></pre></div><p>The collections in java.util.concurrent have operations like putIfAbsent() to accommo-
date such operations.</p> <h3 id="dependencies-between-methods"><a href="#dependencies-between-methods" class="header-anchor">#</a> Dependencies Between Methods</h3> <h3 id="can-break-concurrent-code"><a href="#can-break-concurrent-code" class="header-anchor">#</a> Can Break Concurrent Code</h3> <p>Here is a trivial example of a way to introduce dependencies between methods:</p> <div class="language- extra-class"><pre class="language-text"><code>public class IntegerIterator implements Iterator&lt;Integer&gt;
private Integer nextValue = 0;
public synchronized boolean hasNext() {
return nextValue &lt; 100000;
}
public synchronized Integer next() {
if (nextValue == 100000)
throw new IteratorPastEndException();
return nextValue++;
}
public synchronized Integer getNextValue() {
return nextValue;
}
}
</code></pre></div><p>Here is some code to use this IntegerIterator:</p> <div class="language- extra-class"><pre class="language-text"><code>IntegerIterator iterator = new IntegerIterator();
while(iterator.hasNext()) {
</code></pre></div><p>330 <strong>Appendix A: Concurrency II</strong></p> <div class="language- extra-class"><pre class="language-text"><code>int nextValue = iterator.next();
// do something with nextValue
}
</code></pre></div><p>If one thread executes this code, there will be no problem. But what happens if two threads
attempt to share a single instance of IngeterIterator with the intent that each thread will
process the values it gets, but that each element of the list is processed only once? Most of
the time, nothing bad happens; the threads happily share the list, processing the elements
they are given by the iterator and stopping when the iterator is complete. However, there is
a small chance that, at the end of the iteration, the two threads will interfere with each
other and cause one thread to go beyond the end of the iterator and throw an exception.</p> <p>Here’s the problem: Thread 1 asks the question hasNext(), which returns true. Thread
1 gets preempted and then Thread 2 asks the same question, which is still true. Thread 2
then calls next(), which returns a value as expected but has a side effect of making
hasNext() return false. Thread 1 starts up again, thinking hasNext() is still true, and then
calls next(). Even though the individual methods are synchronized, the client uses <strong><em>two</em></strong>
methods.</p> <p>This is a real problem and an example of the kinds of problems that crop up in con-
current code. In this particular situation this problem is especially subtle because the only
time where this causes a fault is when it happens during the final iteration of the iterator.
If the threads happen to break just right, then one of the threads could go beyond the end
of the iterator. This is the kind of bug that happens long after a system has been in pro-
duction, and it is hard to track down.</p> <div class="language- extra-class"><pre class="language-text"><code>You have three options:
</code></pre></div><p><strong>-</strong> Tolerate the failure.
<strong>-</strong> Solve the problem by changing the client: client-based locking
<strong>-</strong> Solve the problem by changing the server, which additionally changes the client:
server-based locking</p> <h4 id="tolerate-the-failure"><a href="#tolerate-the-failure" class="header-anchor">#</a> Tolerate the Failure .</h4> <p>Sometimes you can set things up such that the failure causes no harm. For example, the
above client could catch the exception and clean up. Frankly, this is a bit sloppy. It’s rather
like cleaning up memory leaks by rebooting at midnight.</p> <h4 id="client-based-locking"><a href="#client-based-locking" class="header-anchor">#</a> Client-Based Locking.</h4> <p>To make IntegerIterator work correctly with multiple threads, change this client (and
every other client) as follows:</p> <div class="language- extra-class"><pre class="language-text"><code>IntegerIterator iterator = new IntegerIterator();
while (true) {
int nextValue;
</code></pre></div><p><strong>Dependencies Between Methods Can Break Concurrent Code</strong> 331</p> <div class="language- extra-class"><pre class="language-text"><code>synchronized (iterator) {
if (!iterator.hasNext())
break;
nextValue = iterator.next();
}
doSometingWith(nextValue);
}
</code></pre></div><p>Each client introduces a lock via the synchronized keyword. This duplication violates the
DRY principle, but it might be necessary if the code uses non-thread-safe third-party tools.</p> <p>This strategy is risky because all programmers who use the server must remember to
lock it before using it and unlock it when done. Many (many!) years ago I worked on a
system that employed client-based locking on a shared resource. The resource was used in
hundreds of different places throughout the code. One poor programmer forgot to lock the
resource in one of those places.</p> <p>The system was a multi-terminal time-sharing system running accounting software
for Local 705 of the trucker’s union. The computer was in a raised-floor, environment-
controlled room 50 miles north of the Local 705 headquarters. At the headquarters they
had dozens of data entry clerks typing union dues postings into the terminals. The termi-
nals were connected to the computer using dedicated phone lines and 600bps half-duplex
modems. (This was a very, <em>very</em> long time ago.)</p> <p>About once per day, one of the terminals would “lock up.” There was no rhyme or rea-
son to it. The lock up showed no preference for particular terminals or particular times. It
was as though there were someone rolling dice choosing the time and terminal to lock up.
Sometimes more than one terminal would lock up. Sometimes days would go by without
any lock-ups.</p> <p>At first the only solution was a reboot. But reboots were tough to coordinate. We had
to call the headquarters and get everyone to finish what they were doing on all the termi-
nals. Then we could shut down and restart. If someone was doing something important
that took an hour or two, the locked up terminal simply had to stay locked up.</p> <p>After a few weeks of debugging we found that the cause was a ring-buffer counter that
had gotten out of sync with its pointer. This buffer controlled output to the terminal. The
pointer value indicated that the buffer was empty, but the counter said it was full. Because
it was empty, there was nothing to display; but because it was also full, nothing could be
added to the buffer to be displayed on the screen.</p> <p>So we knew why the terminals were locking, but we didn’t know why the ring buffer
was getting out of sync. So we added a hack to work around the problem. It was possible to
read the front panel switches on the computer. (This was a very, very, <em>very</em> long time ago.)
We wrote a little trap function that detected when one of these switches was thrown and
then looked for a ring buffer that was both empty and full. If one was found, it reset that
buffer to empty. <em>Voila!</em> The locked-up terminal(s) started displaying again.</p> <p>So now we didn’t have to reboot the system when a terminal locked up. The Local
would simply call us and tell us we had a lock-up, and then we just walked into the com-
puter room and flicked a switch.</p> <p>332 <strong>Appendix A: Concurrency II</strong></p> <p>Of course sometimes they worked on the weekends, and we didn’t. So we added a
function to the scheduler that checked all the ring buffers once per minute and reset any
that were both empty and full. This caused the displays to unclog before the Local could
even get on the phone.</p> <p>It was several more weeks of poring over page after page of monolithic assembly lan-
guage code before we found the culprit. We had done the math and calculated that the fre-
quency of the lock-ups was consistent with a single unprotected use of the ring buffer. So
all we had to do was find that one faulty usage. Unfortunately, this was so very long ago
that we didn’t have search tools or cross references or any other kind of automated help.
We simply had to pore over listings.</p> <p>I learned an important lesson that cold Chicago winter of 1971. Client-based locking
really blows.</p> <h4 id="server-based-locking"><a href="#server-based-locking" class="header-anchor">#</a> Server-Based Locking</h4> <p>The duplication can be removed by making the following changes to IntegerIterator:</p> <div class="language- extra-class"><pre class="language-text"><code>public class IntegerIteratorServerLocked {
private Integer nextValue = 0;
public synchronized Integer getNextOrNull() {
if (nextValue &lt; 100000)
return nextValue++;
else
return null;
}
}
</code></pre></div><p>And the client code changes as well:</p> <div class="language- extra-class"><pre class="language-text"><code>while (true) {
Integer nextValue = iterator.getNextOrNull();
if (next == null)
break;
// do something with nextValue
}
</code></pre></div><p>In this case we actually change the API of our class to be multithread aware.^3 The client
needs to perform a null check instead of checking hasNext().</p> <div class="language- extra-class"><pre class="language-text"><code>In general you should prefer server-based locking for these reasons:
</code></pre></div><p><strong>-</strong> It reduces repeated code—Client-based locking forces each client to lock the server
properly. By putting the locking code into the server, clients are free to use the object
and not worry about writing additional locking code.
3. In fact, the Iterator interface is inherently not thread-safe. It was never designed to be used by multiple threads, so this
should come as no surprise.</p> <p><strong>Increasing Throughput</strong> 333</p> <p><strong>-</strong> It allows for better performance—You can swap out a thread-safe server for a non-
thread safe one in the case of single-threaded deployment, thereby avoiding all
overhead.
<strong>-</strong> It reduces the possibility of error—All it takes is for one programmer to forget to lock
properly.
<strong>-</strong> It enforces a single policy—The policy is in one place, the server, rather than many
places, each client.
<strong>-</strong> It reduces the scope of the shared variables—The client is not aware of them or how
they are locked. All of that is hidden in the server. When things break, the number of
places to look is smaller.</p> <div class="language- extra-class"><pre class="language-text"><code>What if you do not own the server code?
</code></pre></div><p><strong>-</strong> Use an ADAPTER to change the API and add locking
public class ThreadSafeIntegerIterator {
private IntegerIterator iterator = new IntegerIterator();
public synchronized Integer getNextOrNull() {
if(iterator.hasNext())
return iterator.next();
return null;
}
}
<strong>-</strong> OR better yet, use the thread-safe collections with extended interfaces</p> <h3 id="increasing-throughput"><a href="#increasing-throughput" class="header-anchor">#</a> Increasing Throughput .</h3> <p>Let’s assume that we want to go out on the net and read the contents of a set of pages from
a list of URLs. As each page is read, we will parse it to accumulate some statistics. Once
all the pages are read, we will print a summary report.</p> <div class="language- extra-class"><pre class="language-text"><code>The following class returns the contents of one page, given a URL.
public class PageReader {
//...
public String getPageFor(String url) {
HttpMethod method = new GetMethod(url);
try {
httpClient.executeMethod(method);
String response = method.getResponseBodyAsString();
return response;
} catch (Exception e) {
handle(e);
} finally {
method.releaseConnection();
}
}
}
</code></pre></div><p>334 <strong>Appendix A: Concurrency II</strong></p> <p>The next class is the iterator that provides the contents of the pages based on an iterator of
URLs:</p> <p>public class PageIterator {
private PageReader reader;
private URLIterator urls;
public PageIterator(PageReader reader, URLIterator urls) {
this.urls = urls;
this.reader = reader;
}
public synchronized String getNextPageOrNull() {
if (urls.hasNext())
getPageFor(urls.next());
else
return null;
}
public String getPageFor(String url) {
return reader.getPageFor(url);
}
}
An instance of the PageIterator can be shared between many different threads, each
one using it’s own instance of the PageReader to read and parse the pages it gets from the
iterator.</p> <p>Notice that we’ve kept the synchronized block very small. It contains just the critical
section deep inside the PageIterator. It is always better to synchronize as little as possible
as opposed to synchronizing as much as possible.</p> <h4 id="single-thread-calculation-of-throughput"><a href="#single-thread-calculation-of-throughput" class="header-anchor">#</a> Single-Thread Calculation of Throughput..</h4> <p>Now lets do some simple calculations. For the purpose of argument, assume the following:</p> <p><strong>-</strong> I/O time to retrieve a page (average): 1 second
<strong>-</strong> Processing time to parse page (average): .5 seconds
<strong>-</strong> I/O requires 0 percent of the CPU while processing requires 100 percent.</p> <p>For <em>N</em> pages being processed by a single thread, the total execution time is 1.5 sec-
onds * <em>N</em>. Figure A-1 shows a snapshot of 13 pages or about 19.5 seconds.</p> <div class="language- extra-class"><pre class="language-text"><code>Figure A-1
Single thread
</code></pre></div><p><strong>Deadlock</strong> 335</p> <h4 id="multithread-calculation-of-throughput"><a href="#multithread-calculation-of-throughput" class="header-anchor">#</a> Multithread Calculation of Throughput..</h4> <p>If it is possible to retrieve pages in any order and process the pages independently, then it
is possible to use multiple threads to increase throughput. What happens if we use three
threads? How many pages can we acquire in the same time?</p> <p>As you can see in Figure A-2, the multithreaded solution allows the process-bound
parsing of the pages to overlap with the I/O-bound reading of the pages. In an idealized
world this means that the processor is fully utilized. Each one-second page read is over-
lapped with two parses. Thus, we can process two pages per second, which is three times
the throughput of the single-threaded solution.</p> <h3 id="deadlock"><a href="#deadlock" class="header-anchor">#</a> Deadlock .</h3> <p>Imagine a Web application with two shared resource pools of some finite size:</p> <p><strong>-</strong> A pool of database connections for local work in process storage
<strong>-</strong> A pool of MQ connections to a master repository</p> <div class="language- extra-class"><pre class="language-text"><code>Assume there are two operations in this application, create and update:
</code></pre></div><p><strong>-</strong> Create—Acquire connection to master repository and database. Talk to service master
repository and then store work in local work in process database.</p> <div class="language- extra-class"><pre class="language-text"><code>Figure A-2
Three concurrent threads
</code></pre></div><p>336 <strong>Appendix A: Concurrency II</strong></p> <p><strong>-</strong> Update—Acquire connection to database and then master repository. Read from work
in process database and then send to the master repository</p> <p>What happens when there are more users than the pool sizes? Consider each pool has
a size of ten.</p> <p><strong>-</strong> Ten users attempt to use create, so all ten database connections are acquired, and each
thread is interrupted after acquiring a database connection but before acquiring a con-
nection to the master repository.
<strong>-</strong> Ten users attempt to use update, so all ten master repository connections are acquired,
and each thread is interrupted after acquiring the master repository but before acquir-
ing a database connection.
<strong>-</strong> Now the ten “create” threads must wait to acquire a master repository connection, but
the ten “update” threads must wait to acquire a database connection.
<strong>-</strong> Deadlock. The system never recovers.</p> <p>This might sound like an unlikely situation, but who wants a system that freezes solid
every other week? Who wants to debug a system with symptoms that are so difficult to
reproduce? This is the kind of problem that happens in the field, then takes weeks to solve.</p> <p>A typical “solution” is to introduce debugging statements to find out what is happen-
ing. Of course, the debug statements change the code enough so that the deadlock happens
in a different situation and takes months to again occur.^4</p> <p>To really solve the problem of deadlock, we need to understand what causes it. There
are four conditions required for deadlock to occur:</p> <p><strong>-</strong> Mutual exclusion
<strong>-</strong> Lock &amp; wait
<strong>-</strong> No preemption
<strong>-</strong> Circular wait</p> <h4 id="mutual-exclusion"><a href="#mutual-exclusion" class="header-anchor">#</a> Mutual Exclusion ...</h4> <p>Mutual exclusion occurs when multiple threads need to use the same resources and those
resources</p> <p><strong>-</strong> Cannot be used by multiple threads at the same time.
<strong>-</strong> Are limited in number.</p> <p>A common example of such a resource is a database connection, a file open for write, a
record lock, or a semaphore.</p> <ol start="4"><li>For example, someone adds some debugging output and the problem “disappears.” The debugging code “fixes” the problem
so it remains in the system.</li></ol> <p><strong>Deadlock</strong> 337</p> <h4 id="lock-wait"><a href="#lock-wait" class="header-anchor">#</a> Lock &amp; Wait ...</h4> <p>Once a thread acquires a resource, it will not release the resource until it has acquired all
of the other resources it requires and has completed its work.</p> <h4 id="no-preemption"><a href="#no-preemption" class="header-anchor">#</a> No Preemption</h4> <p>One thread cannot take resources away from another thread. Once a thread holds a
resource, the only way for another thread to get it is for the holding thread to release it.</p> <h4 id="circular-wait"><a href="#circular-wait" class="header-anchor">#</a> Circular Wait ..</h4> <p>This is also referred to as the deadly embrace. Imagine two threads, T1 and T2, and two
resources, R1 and R2. T1 has R1, T2 has R2. T1 also requires R2, and T2 also requires R1.
This gives something like Figure A-3:</p> <p>All four of these conditions must hold for deadlock to be possible. Break any one of these
conditions and deadlock is not possible.</p> <h4 id="breaking-mutual-exclusion"><a href="#breaking-mutual-exclusion" class="header-anchor">#</a> Breaking Mutual Exclusion</h4> <p>One strategy for avoiding deadlock is to sidestep the mutual exclusion condition. You
might be able to do this by</p> <p><strong>-</strong> Using resources that allow simultaneous use, for example, AtomicInteger.
<strong>-</strong> Increasing the number of resources such that it equals or exceeds the number of com-
peting threads.
<strong>-</strong> Checking that all your resources are free before seizing any.</p> <p>Unfortunately, most resources are limited in number and don’t allow simultaneous
use. And it’s not uncommon for the identity of the second resource to be predicated on the
results of operating on the first. But don’t be discouraged; there are three conditions left.</p> <div class="language- extra-class"><pre class="language-text"><code>Figure A-3
</code></pre></div><p>338 <strong>Appendix A: Concurrency II</strong></p> <h4 id="breaking-lock-wait"><a href="#breaking-lock-wait" class="header-anchor">#</a> Breaking Lock &amp; Wait</h4> <p>You can also eliminate deadlock if you refuse to wait. Check each resource before you
seize it, and release all resources and start over if you run into one that’s busy.</p> <div class="language- extra-class"><pre class="language-text"><code>This approach introduces several potential problems:
</code></pre></div><p><strong>-</strong> Starvation—One thread keeps being unable to acquire the resources it needs (maybe it
has a unique combination of resources that seldom all become available).
<strong>-</strong> Livelock—Several threads might get into lockstep and all acquire one resource and
then release one resource, over and over again. This is especially likely with simplistic
CPU scheduling algorithms (think embedded devices or simplistic hand-written
thread balancing algorithms).</p> <p>Both of these can cause poor throughput. The first results in low CPU utilization,
whereas the second results in high and useless CPU utilization.</p> <p>As inefficient as this strategy sounds, it’s better than nothing. It has the benefit that it
can almost always be implemented if all else fails.</p> <h4 id="breaking-preemption"><a href="#breaking-preemption" class="header-anchor">#</a> Breaking Preemption..</h4> <p>Another strategy for avoiding deadlock is to allow threads to take resources away from
other threads. This is usually done through a simple request mechanism. When a thread
discovers that a resource is busy, it asks the owner to release it. If the owner is also waiting
for some other resource, it releases them all and starts over.</p> <p>This is similar to the previous approach but has the benefit that a thread is allowed to
wait for a resource. This decreases the number of startovers. Be warned, however, that
managing all those requests can be tricky.</p> <h4 id="breaking-circular-wait"><a href="#breaking-circular-wait" class="header-anchor">#</a> Breaking Circular Wait...</h4> <p>This is the most common approach to preventing deadlock. For most systems it requires
no more than a simple convention agreed to by all parties.</p> <p>In the example above with Thread 1 wanting both Resource 1 and Resource 2 and
Thread 2 wanting both Resource 2 and then Resource 1, simply forcing both Thread 1 and
Thread 2 to allocate resources in the same order makes circular wait impossible.</p> <p>More generally, if all threads can agree on a global ordering of resources and if they
all allocate resources in that order, then deadlock is impossible. Like all the other strate-
gies, this can cause problems:</p> <p><strong>-</strong> The order of acquisition might not correspond to the order of use; thus a resource
acquired at the start might not be used until the end. This can cause resources to be
locked longer than strictly necessary.</p> <p><strong>Testing Multithreaded Code</strong> 339</p> <p><strong>-</strong> Sometimes you cannot impose an order on the acquisition of resources. If the ID of
the second resource comes from an operation performed on the first, then ordering is
not feasible.</p> <p>So there are many ways to avoid deadlock. Some lead to starvation, whereas others
make heavy use of the CPU and reduce responsiveness. TANSTAAFL!^5</p> <p>Isolating the thread-related part of your solution to allow for tuning and experimenta-
tion is a powerful way to gain the insights needed to determine the best strategies.</p> <h3 id="testing-multithreaded-code"><a href="#testing-multithreaded-code" class="header-anchor">#</a> Testing Multithreaded Code .</h3> <p>How can we write a test to demonstrate the following code is broken?</p> <div class="language- extra-class"><pre class="language-text"><code>01: public class ClassWithThreadingProblem {
02: int nextId;
03:
04: public int takeNextId() {
05: return nextId++;
06: }
07:}
</code></pre></div><p>Here’s a description of a test that will prove the code is broken:</p> <p><strong>-</strong> Remember the current value of nextId.
<strong>-</strong> Create two threads, both of which call takeNextId() once.
<strong>-</strong> Verify that nextId is two more than what we started with.
<strong>-</strong> Run this until we demonstrate that nextId was only incremented by one instead
of two.</p> <div class="language- extra-class"><pre class="language-text"><code>Listing A-2 shows such a test:
</code></pre></div><ol start="5"><li>There ain’t no such thing as a free lunch.</li></ol> <div class="language- extra-class"><pre class="language-text"><code>Listing A-2
ClassWithThreadingProblemTest.java
01: package example;
02:
03: import static org.junit.Assert.fail;
04:
05: import org.junit.Test;
06:
07: public class ClassWithThreadingProblemTest {
08: @Test
09: public void twoThreadsShouldFailEventually() throws Exception {
10: final ClassWithThreadingProblem classWithThreadingProblem
= new ClassWithThreadingProblem();
11:
</code></pre></div><p>340 <strong>Appendix A: Concurrency II</strong></p> <div class="language- extra-class"><pre class="language-text"><code>12: Runnable runnable = new Runnable() {
13: public void run() {
14: classWithThreadingProblem.takeNextId();
15: }
16: };
17:
18: for (int i = 0; i &lt; 50000; ++i) {
19: int startingId = classWithThreadingProblem.lastId;
20: int expectedResult = 2 + startingId;
21:
22: Thread t1 = new Thread(runnable);
23: Thread t2 = new Thread(runnable);
24: t1.start();
25: t2.start();
26: t1.join();
27: t2.join();
28:
29: int endingId = classWithThreadingProblem.lastId;
30:
31: if (endingId != expectedResult)
32: return;
33: }
34:
35: fail(&quot;Should have exposed a threading issue but it did not.&quot;);
36: }
37: }
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>Line Description
10 Create a single instance of ClassWithThreadingProblem. Note, we must use
the final keyword because we use it below in an anonymous inner class.
12–16 Create an anonymous inner class that uses the single instance of
ClassWithThreadingProblem.
18 Run this code “enough” times to demonstrate that the code failed, but not
so much that the test “takes too long.” This is a balancing act; we don’t
want to wait too long to demonstrate failure. Picking this number is hard—
although later we’ll see that we can greatly reduce this number.
19 Remember the starting value. This test is trying to prove that the code in
ClassWithThreadingProblem is broken. If this test passes, it proved that the
code was broken. If this test fails, the test was unable to prove that the code
is broken.
20 We expect the final value to be two more than the current value.
22–23 Create two threads, both of which use the object we created in lines 12–16.
This gives us the potential of two threads trying to use our single instance
of ClassWithThreadingProblem and interfering with each other.
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>Listing A-2 (continued)
ClassWithThreadingProblemTest.java
</code></pre></div><p><strong>Testing Multithreaded Code</strong> 341</p> <p>This test certainly sets up the conditions for a concurrent update problem. However,
the problem occurs so infrequently that the vast majority of times this test won’t detect it.</p> <p>Indeed, to truly detect the problem we need to set the number of iterations to over one
million. Even then, in ten executions with a loop count of 1,000,000, the problem occurred
only once. That means we probably ought to set the iteration count to well over one hun-
dred million to get reliable failures. How long are we prepared to wait?</p> <p>Even if we tuned the test to get reliable failures on one machine, we’ll probably have
to retune the test with different values to demonstrate the failure on another machine,
operating system, or version of the JVM.</p> <p>And this is a <em>simple</em> problem. If we cannot demonstrate broken code easily with this
problem, how will we ever detect truly complex problems?</p> <p>So what approaches can we take to demonstrate this simple failure? And, more impor-
tantly, how can we write tests that will demonstrate failures in more complex code? How
will we be able to discover if our code has failures when we do not know where to look?</p> <div class="language- extra-class"><pre class="language-text"><code>Here are a few ideas:
</code></pre></div><p><strong>- Monte Carlo Testing.</strong> Make tests flexible, so they can be tuned. Then run the test over
and over—say on a test server—randomly changing the tuning values. If the tests ever
fail, the code is broken. Make sure to start writing those tests early so a continuous
integration server starts running them soon. By the way, make sure you carefully log
the conditions under which the test failed.
<strong>-</strong> Run the test on every one of the target deployment platforms. Repeatedly. Continu-
ously. The longer the tests run without failure, the more likely that
- The production code is correct or
- The tests aren’t adequate to expose problems.
<strong>-</strong> Run the tests on a machine with varying loads. If you can simulate loads close to a
production environment, do so.</p> <div class="language- extra-class"><pre class="language-text"><code>24–25 Make our two threads eligible to run.
26–27 Wait for both threads to finish before we check the results.
29 Record the actual final value.
31–32 Did our endingId differ from what we expected? If so, return end the test—
we’ve proven that the code is broken. If not, try again.
35 If we got to here, our test was unable to prove the production code was bro-
ken in a “reasonable” amount of time; our code has failed. Either the code
is not broken or we didn’t run enough iterations to get the failure condition
to occur.
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>Line Description
</code></pre></div><p>342 <strong>Appendix A: Concurrency II</strong></p> <p>Yet, even if you do all of these things, you still don’t stand a very good chance of find-
ing threading problems with your code. The most insidious problems are the ones that
have such a small cross section that they only occur once in a billion opportunities. Such
problems are the terror of complex systems.</p> <h3 id="tool-support-for-testing-thread-based-code"><a href="#tool-support-for-testing-thread-based-code" class="header-anchor">#</a> Tool Support for Testing Thread-Based Code</h3> <p>IBM has created a tool called ConTest.^6 It instruments classes to make it more likely that
non-thread-safe code fails.</p> <p>We do not have any direct relationship with IBM or the team that developed ConTest.
A colleague of ours pointed us to it. We noticed vast improvement in our ability to find
threading issues after a few minutes of using it.</p> <div class="language- extra-class"><pre class="language-text"><code>Here’s an outline of how to use ConTest:
</code></pre></div><p><strong>-</strong> Write tests and production code, making sure there are tests specifically designed to
simulate multiple users under varying loads, as mentioned above.
<strong>-</strong> Instrument test and production code with ConTest.
<strong>-</strong> Run the tests.</p> <p>When we instrumented code with ConTest, our success rate went from roughly one fail-
ure in ten million iterations to roughly one failure in <em>thirty</em> iterations. Here are the loop values
for several runs of the test after instrumentation: 13, 23, 0, 54, 16, 14, 6, 69, 107, 49, 2. So
clearly the instrumented classes failed much earlier and with much greater reliability.</p> <h3 id="conclusion-3"><a href="#conclusion-3" class="header-anchor">#</a> Conclusion ..</h3> <p>This chapter has been a very brief sojourn through the large and treacherous territory of
concurrent programming. We barely scratched the surface. Our emphasis here was on dis-
ciplines to help keep concurrent code clean, but there is much more you should learn if
you are going to be writing concurrent systems. We recommend you start with Doug Lea’s
wonderful book <em>Concurrent Programming in Java: Design Principles and Patterns.</em>^7</p> <p>In this chapter we talked about concurrent update, and the disciplines of clean syn-
chronization and locking that can prevent it. We talked about how threads can enhance the
throughput of an I/O-bound system and showed the clean techniques for achieving such
improvements. We talked about deadlock and the disciplines for preventing it in a clean</p> <ol start="6"><li><a href="http://www.haifa.ibm.com/projects/verification/contest/index.html" target="_blank" rel="noopener noreferrer">http://www.haifa.ibm.com/projects/verification/contest/index.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>See [Lea99] p. 191.</li></ol> <p><strong>Tutorial: Full Code Examples</strong> 343</p> <p>way. Finally, we talked about strategies for exposing concurrent problems by instrumenting
your code.</p> <h3 id="tutorial-full-code-examples"><a href="#tutorial-full-code-examples" class="header-anchor">#</a> Tutorial: Full Code Examples ..</h3> <h4 id="client-server-nonthreaded"><a href="#client-server-nonthreaded" class="header-anchor">#</a> Client/Server Nonthreaded .</h4> <div class="language- extra-class"><pre class="language-text"><code>Listing A-3
Server.java
package com.objectmentor.clientserver.nonthreaded;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import common.MessageUtils;
public class Server implements Runnable {
ServerSocket serverSocket;
volatile boolean keepProcessing = true;
public Server(int port, int millisecondsTimeout) throws IOException {
serverSocket = new ServerSocket(port);
serverSocket.setSoTimeout(millisecondsTimeout);
}
public void run() {
System.out.printf(&quot;Server Starting\n&quot;);
while (keepProcessing) {
try {
System.out.printf(&quot;accepting client\n&quot;);
Socket socket = serverSocket.accept();
System.out.printf(&quot;got client\n&quot;);
process(socket);
} catch (Exception e) {
handle(e);
}
}
}
private void handle(Exception e) {
if (!(e instanceof SocketException)) {
e.printStackTrace();
}
}
public void stopProcessing() {
keepProcessing = false;
closeIgnoringException(serverSocket);
}
</code></pre></div><p>344 <strong>Appendix A: Concurrency II</strong></p> <div class="language- extra-class"><pre class="language-text"><code>void process(Socket socket) {
if (socket == null)
return;
try {
System.out.printf(&quot;Server: getting message\n&quot;);
String message = MessageUtils.getMessage(socket);
System.out.printf(&quot;Server: got message: %s\n&quot;, message);
Thread.sleep(1000);
System.out.printf(&quot;Server: sending reply: %s\n&quot;, message);
MessageUtils.sendMessage(socket, &quot;Processed: &quot; + message);
System.out.printf(&quot;Server: sent\n&quot;);
closeIgnoringException(socket);
} catch (Exception e) {
e.printStackTrace();
}
}
private void closeIgnoringException(Socket socket) {
if (socket != null)
try {
socket.close();
} catch (IOException ignore) {
}
}
private void closeIgnoringException(ServerSocket serverSocket) {
if (serverSocket != null)
try {
serverSocket.close();
} catch (IOException ignore) {
}
}
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>Listing A-4
ClientTest.java
package com.objectmentor.clientserver.nonthreaded;
import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.SocketException;
import common.MessageUtils;
public class Server implements Runnable {
ServerSocket serverSocket;
volatile boolean keepProcessing = true;
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>Listing A-3 (continued)
Server.java
</code></pre></div><p><strong>Tutorial: Full Code Examples</strong> 345</p> <div class="language- extra-class"><pre class="language-text"><code>public Server(int port, int millisecondsTimeout) throws IOException {
serverSocket = new ServerSocket(port);
serverSocket.setSoTimeout(millisecondsTimeout);
}
public void run() {
System.out.printf(&quot;Server Starting\n&quot;);
while (keepProcessing) {
try {
System.out.printf(&quot;accepting client\n&quot;);
Socket socket = serverSocket.accept();
System.out.printf(&quot;got client\n&quot;);
process(socket);
} catch (Exception e) {
handle(e);
}
}
}
private void handle(Exception e) {
if (!(e instanceof SocketException)) {
e.printStackTrace();
}
}
public void stopProcessing() {
keepProcessing = false;
closeIgnoringException(serverSocket);
}
void process(Socket socket) {
if (socket == null)
return;
try {
System.out.printf(&quot;Server: getting message\n&quot;);
String message = MessageUtils.getMessage(socket);
System.out.printf(&quot;Server: got message: %s\n&quot;, message);
Thread.sleep(1000);
System.out.printf(&quot;Server: sending reply: %s\n&quot;, message);
MessageUtils.sendMessage(socket, &quot;Processed: &quot; + message);
System.out.printf(&quot;Server: sent\n&quot;);
closeIgnoringException(socket);
} catch (Exception e) {
e.printStackTrace();
}
}
private void closeIgnoringException(Socket socket) {
if (socket != null)
try {
socket.close();
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>Listing A-4 (continued)
ClientTest.java
</code></pre></div><p>346 <strong>Appendix A: Concurrency II</strong></p> <h4 id="client-server-using-threads"><a href="#client-server-using-threads" class="header-anchor">#</a> Client/Server Using Threads ..</h4> <p>Changing the server to use threads simply requires a change to the process message (new
lines are emphasized to stand out):</p> <div class="language- extra-class"><pre class="language-text"><code>void process(final Socket socket) {
if (socket == null)
return;
Runnable clientHandler = new Runnable() {
public void run() {
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>} catch (IOException ignore) {
}
}
private void closeIgnoringException(ServerSocket serverSocket) {
if (serverSocket != null)
try {
serverSocket.close();
} catch (IOException ignore) {
}
}
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>Listing A-5
MessageUtils.java
package common;
import java.io.IOException;
import java.io.InputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.net.Socket;
public class MessageUtils {
public static void sendMessage(Socket socket, String message)
throws IOException {
OutputStream stream = socket.getOutputStream();
ObjectOutputStream oos = new ObjectOutputStream(stream);
oos.writeUTF(message);
oos.flush();
}
public static String getMessage(Socket socket) throws IOException {
InputStream stream = socket.getInputStream();
ObjectInputStream ois = new ObjectInputStream(stream);
return ois.readUTF();
}
}
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>Listing A-4 (continued)
ClientTest.java
</code></pre></div><p><strong>Tutorial: Full Code Examples</strong> 347</p> <div class="language- extra-class"><pre class="language-text"><code>try {
System.out.printf(&quot;Server: getting message\n&quot;);
String message = MessageUtils.getMessage(socket);
System.out.printf(&quot;Server: got message: %s\n&quot;, message);
Thread.sleep(1000);
System.out.printf(&quot;Server: sending reply: %s\n&quot;, message);
MessageUtils.sendMessage(socket, &quot;Processed: &quot; + message);
System.out.printf(&quot;Server: sent\n&quot;);
closeIgnoringException(socket);
} catch (Exception e) {
e.printStackTrace();
}
}
};
Thread clientConnection = new Thread(clientHandler);
clientConnection.start();
}
</code></pre></div><h4 id="this-page-intentionally-left-blank"><a href="#this-page-intentionally-left-blank" class="header-anchor">#</a> This page intentionally left blank</h4> <h5 id="_349"><a href="#_349" class="header-anchor">#</a> 349</h5> <h1 id="appendix-b"><a href="#appendix-b" class="header-anchor">#</a> Appendix B</h1> <p><strong>org.jfree.date.SerialDate</strong></p> <p><strong>Listing B-1
SerialDate.Java</strong>
1 /* ========================================================================
2 * JCommon : a free general purpose class library for the Java(tm) platform
3 * ========================================================================
4 *
5 * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.
6 *
7 * Project Info: <a href="http://www.jfree.org/jcommon/index.html" target="_blank" rel="noopener noreferrer">http://www.jfree.org/jcommon/index.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
8 *
9 * This library is free software; you can redistribute it and/or modify it
10 * under the terms of the GNU Lesser General Public License as published by
11 * the Free Software Foundation; either version 2.1 of the License, or
12 * (at your option) any later version.
13 *
14 * This library is distributed in the hope that it will be useful, but
15 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
16 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
17 * License for more details.
18 *
19 * You should have received a copy of the GNU Lesser General Public
20 * License along with this library; if not, write to the Free Software
21 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
22 * USA.
23 *
24 * [Java is a trademark or registered trademark of Sun Microsystems, Inc.
25 * in the United States and other countries.]
26 *
27 * ---------------
28 * SerialDate.java
29 * ---------------
30 * (C) Copyright 2001-2005, by Object Refinery Limited.
31 *
32 * Original Author: David Gilbert (for Object Refinery Limited);
33 * Contributor(s): -;
34 *
35 * $Id: SerialDate.java,v 1.7 2005/11/03 09:25:17 mungady Exp $
36 *
37 * Changes (from 11-Oct-2001)</p> <p>350 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>38 * --------------------------
39 * 11-Oct-2001 : Re-organised the class and moved it to new package
40 * com.jrefinery.date (DG);
41 * 05-Nov-2001 : Added a getDescription() method, and eliminated NotableDate
42 * class (DG);
43 * 12-Nov-2001 : IBD requires setDescription() method, now that NotableDate
44 * class is gone (DG); Changed getPreviousDayOfWeek(),
45 * getFollowingDayOfWeek() and getNearestDayOfWeek() to correct
46 * bugs (DG);
47 * 05-Dec-2001 : Fixed bug in SpreadsheetDate class (DG);
48 * 29-May-2002 : Moved the month constants into a separate interface
49 * (MonthConstants) (DG);
50 * 27-Aug-2002 : Fixed bug in addMonths() method, thanks to N???levka Petr (DG);
51 * 03-Oct-2002 : Fixed errors reported by Checkstyle (DG);
52 * 13-Mar-2003 : Implemented Serializable (DG);
53 * 29-May-2003 : Fixed bug in addMonths method (DG);
54 * 04-Sep-2003 : Implemented Comparable. Updated the isInRange javadocs (DG);
55 * 05-Jan-2005 : Fixed bug in addYears() method (1096282) (DG);
56 *
57 <em>/
58
59 package org.jfree.date;
60
61 import java.io.Serializable;
62 import java.text.DateFormatSymbols;
63 import java.text.SimpleDateFormat;
64 import java.util.Calendar;
65 import java.util.GregorianCalendar;
66
67 /</em>*
68 * An abstract class that defines our requirements for manipulating dates,
69 * without tying down a particular implementation.
70 * <P>
71 * Requirement 1 : match at least what Excel does for dates;
72 * Requirement 2 : class is immutable;
73 * <P>
74 * Why not just use java.util.Date? We will, when it makes sense. At times,
75 * java.util.Date can be <em>too</em> precise - it represents an instant in time,
76 * accurate to 1/1000th of a second (with the date itself depending on the
77 * time-zone). Sometimes we just want to represent a particular day (e.g. 21
78 * January 2015) without concerning ourselves about the time of day, or the
79 * time-zone, or anything else. That's what we've defined SerialDate for.
80 * <P>
81 * You can call getInstance() to get a concrete subclass of SerialDate,
82 * without worrying about the exact implementation.
83 *
84 * @author David Gilbert
85 <em>/
86 public abstract class SerialDate implements Comparable,
87 Serializable,
88 MonthConstants {
89
90 /</em>* For serialization. <em>/
91 private static final long serialVersionUID = -293716040467423637L;
92
93 /</em>* Date format symbols. <em>/
94 public static final DateFormatSymbols
95 DATE_FORMAT_SYMBOLS = new SimpleDateFormat().getDateFormatSymbols();
96
97 /</em>* The serial number for 1 January 1900. <em>/
98 public static final int SERIAL_LOWER_BOUND = 2;
99
100 /</em>* The serial number for 31 December 9999. */
101 public static final int SERIAL_UPPER_BOUND = 2958465;
102</P> <div class="language- extra-class"><pre class="language-text"><code>Listing B-1 (continued)
SerialDate.Java
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 351</p> <p>103 /** The lowest year value supported by this date format. <em>/
104 public static final int MINIMUM_YEAR_SUPPORTED = 1900;
105
106 /</em>* The highest year value supported by this date format. <em>/
107 public static final int MAXIMUM_YEAR_SUPPORTED = 9999;
108
109 /</em>* Useful constant for Monday. Equivalent to java.util.Calendar.MONDAY. <em>/
110 public static final int MONDAY = Calendar.MONDAY;
111
112 /</em>*
113 * Useful constant for Tuesday. Equivalent to java.util.Calendar.TUESDAY.
114 <em>/
115 public static final int TUESDAY = Calendar.TUESDAY;
116
117 /</em>*
118 * Useful constant for Wednesday. Equivalent to
119 * java.util.Calendar.WEDNESDAY.
120 <em>/
121 public static final int WEDNESDAY = Calendar.WEDNESDAY;
122
123 /</em>*
124 * Useful constant for Thrusday. Equivalent to java.util.Calendar.THURSDAY.
125 <em>/
126 public static final int THURSDAY = Calendar.THURSDAY;
127
128 /</em>* Useful constant for Friday. Equivalent to java.util.Calendar.FRIDAY. <em>/
129 public static final int FRIDAY = Calendar.FRIDAY;
130
131 /</em>*
132 * Useful constant for Saturday. Equivalent to java.util.Calendar.SATURDAY.
133 <em>/
134 public static final int SATURDAY = Calendar.SATURDAY;
135
136 /</em>* Useful constant for Sunday. Equivalent to java.util.Calendar.SUNDAY. <em>/
137 public static final int SUNDAY = Calendar.SUNDAY;
138
139 /</em>* The number of days in each month in non leap years. <em>/
140 static final int[] LAST_DAY_OF_MONTH =
141 {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
142
143 /</em>* The number of days in a (non-leap) year up to the end of each month. <em>/
144 static final int[] AGGREGATE_DAYS_TO_END_OF_MONTH =
145 {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};
146
147 /</em>* The number of days in a year up to the end of the preceding month. <em>/
148 static final int[] AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH =
149 {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};
150
151 /</em>* The number of days in a leap year up to the end of each month. <em>/
152 static final int[] LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_MONTH =
153 {0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366};
154
155 /</em>*
156 * The number of days in a leap year up to the end of the preceding month.
157 <em>/
158 static final int[]
159 LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH =
160 {0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366};
161
162 /</em>* A useful constant for referring to the first week in a month. */
163 public static final int FIRST_WEEK_IN_MONTH = 1;
164</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-1 (continued)
SerialDate.Java
</code></pre></div><p>352 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>165 /** A useful constant for referring to the second week in a month. <em>/
166 public static final int SECOND_WEEK_IN_MONTH = 2;
167
168 /</em>* A useful constant for referring to the third week in a month. <em>/
169 public static final int THIRD_WEEK_IN_MONTH = 3;
170
171 /</em>* A useful constant for referring to the fourth week in a month. <em>/
172 public static final int FOURTH_WEEK_IN_MONTH = 4;
173
174 /</em>* A useful constant for referring to the last week in a month. <em>/
175 public static final int LAST_WEEK_IN_MONTH = 0;
176
177 /</em>* Useful range constant. <em>/
178 public static final int INCLUDE_NONE = 0;
179
180 /</em>* Useful range constant. <em>/
181 public static final int INCLUDE_FIRST = 1;
182
183 /</em>* Useful range constant. <em>/
184 public static final int INCLUDE_SECOND = 2;
185
186 /</em>* Useful range constant. <em>/
187 public static final int INCLUDE_BOTH = 3;
188
189 /</em>*
190 * Useful constant for specifying a day of the week relative to a fixed
191 * date.
192 <em>/
193 public static final int PRECEDING = -1;
194
195 /</em>*
196 * Useful constant for specifying a day of the week relative to a fixed
197 * date.
198 <em>/
199 public static final int NEAREST = 0;
200
201 /</em>*
202 * Useful constant for specifying a day of the week relative to a fixed
203 * date.
204 <em>/
205 public static final int FOLLOWING = 1;
206
207 /</em>* A description for the date. <em>/
208 private String description;
209
210 /</em>*
211 * Default constructor.
212 <em>/
213 protected SerialDate() {
214 }
215
216 /</em>*
217 * Returns <code>true</code> if the supplied integer code represents a
218 * valid day-of-the-week, and <code>false</code> otherwise.
219 *
220 * @param code the code being checked for validity.
221 *
222 * @return <code>true</code> if the supplied integer code represents a
223 * valid day-of-the-week, and <code>false</code> otherwise.
224 */
225 public static boolean isValidWeekdayCode(final int code) {
226</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-1 (continued)
SerialDate.Java
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 353</p> <p>227 switch(code) {
228 case SUNDAY:
229 case MONDAY:
230 case TUESDAY:
231 case WEDNESDAY:
232 case THURSDAY:
233 case FRIDAY:
234 case SATURDAY:
235 return true;
236 default:
237 return false;
238 }
239
240 }
241
242 /**
243 * Converts the supplied string to a day of the week.
244 *
245 * @param s a string representing the day of the week.
246 *
247 * @return <code>-1</code> if the string is not convertable, the day of
248 * the week otherwise.
249 <em>/
250 public static int stringToWeekdayCode(String s) {
251
252 final String[] shortWeekdayNames
253 = DATE_FORMAT_SYMBOLS.getShortWeekdays();
254 final String[] weekDayNames = DATE_FORMAT_SYMBOLS.getWeekdays();
255
256 int result = -1;
257 s = s.trim();
258 for (int i = 0; i &lt; weekDayNames.length; i++) {
259 if (s.equals(shortWeekdayNames[i])) {
260 result = i;
261 break;
262 }
263 if (s.equals(weekDayNames[i])) {
264 result = i;
265 break;
266 }
267 }
268 return result;
269
270 }
271
272 /</em>*
273 * Returns a string representing the supplied day-of-the-week.
274 * <P>
275 * Need to find a better approach.
276 *
277 * @param weekday the day of the week.
278 *
279 * @return a string representing the supplied day-of-the-week.
280 <em>/
281 public static String weekdayCodeToString(final int weekday) {
282
283 final String[] weekdays = DATE_FORMAT_SYMBOLS.getWeekdays();
284 return weekdays[weekday];
285
286 }
287
288 /</em>*</P></p><div class="language- extra-class"><pre class="language-text"><code>Listing B-1 (continued)
SerialDate.Java
</code></pre></div><p>354 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>289 * Returns an array of month names.
290 *
291 * @return an array of month names.
292 <em>/
293 public static String[] getMonths() {
294
295 return getMonths(false);
296
297 }
298
299 /</em>*
300 * Returns an array of month names.
301 *
302 * @param shortened a flag indicating that shortened month names should
303 * be returned.
304 *
305 * @return an array of month names.
306 <em>/
307 public static String[] getMonths(final boolean shortened) {
308
309 if (shortened) {
310 return DATE_FORMAT_SYMBOLS.getShortMonths();
311 }
312 else {
313 return DATE_FORMAT_SYMBOLS.getMonths();
314 }
315
316 }
317
318 /</em>*
319 * Returns true if the supplied integer code represents a valid month.
320 *
321 * @param code the code being checked for validity.
322 *
323 * @return <code>true</code> if the supplied integer code represents a
324 * valid month.
325 <em>/
326 public static boolean isValidMonthCode(final int code) {
327
328 switch(code) {
329 case JANUARY:
330 case FEBRUARY:
331 case MARCH:
332 case APRIL:
333 case MAY:
334 case JUNE:
335 case JULY:
336 case AUGUST:
337 case SEPTEMBER:
338 case OCTOBER:
339 case NOVEMBER:
340 case DECEMBER:
341 return true;
342 default:
343 return false;
344 }
345
346 }
347
348 /</em>*
349 * Returns the quarter for the specified month.
350 *</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-1 (continued)
SerialDate.Java
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 355</p> <p>351 * @param code the month code (1-12).
352 *
353 * @return the quarter that the month belongs to.
354 * @throws java.lang.IllegalArgumentException
355 <em>/
356 public static int monthCodeToQuarter(final int code) {
357
358 switch(code) {
359 case JANUARY:
360 case FEBRUARY:
361 case MARCH: return 1;
362 case APRIL:
363 case MAY:
364 case JUNE: return 2;
365 case JULY:
366 case AUGUST:
367 case SEPTEMBER: return 3;
368 case OCTOBER:
369 case NOVEMBER:
370 case DECEMBER: return 4;
371 default: throw new IllegalArgumentException(
372 &quot;SerialDate.monthCodeToQuarter: invalid month code.&quot;);
373 }
374
375 }
376
377 /</em>*
378 * Returns a string representing the supplied month.
379 * <P>
380 * The string returned is the long form of the month name taken from the
381 * default locale.
382 *
383 * @param month the month.
384 *
385 * @return a string representing the supplied month.
386 <em>/
387 public static String monthCodeToString(final int month) {
388
389 return monthCodeToString(month, false);
390
391 }
392
393 /</em>*
394 * Returns a string representing the supplied month.
395 * <P>
396 * The string returned is the long or short form of the month name taken
397 * from the default locale.
398 *
399 * @param month the month.
400 * @param shortened if <code>true</code> return the abbreviation of the
401 * month.
402 *
403 * @return a string representing the supplied month.
404 * @throws java.lang.IllegalArgumentException
405 */
406 public static String monthCodeToString(final int month,
407 final boolean shortened) {
408
409 // check arguments...
410 if (!isValidMonthCode(month)) {
411 throw new IllegalArgumentException(
412 &quot;SerialDate.monthCodeToString: month outside valid range.&quot;);</P> <div class="language- extra-class"><pre class="language-text"><code>Listing B-1 (continued)
SerialDate.Java
</code></pre></div><p>356 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>413 }
414
415 final String[] months;
416
417 if (shortened) {
418 months = DATE_FORMAT_SYMBOLS.getShortMonths();
419 }
420 else {
421 months = DATE_FORMAT_SYMBOLS.getMonths();
422 }
423
424 return months[month - 1];
425
426 }
427
428 /**
429 * Converts a string to a month code.
430 * <P>
431 * This method will return one of the constants JANUARY, FEBRUARY, ...,
432 * DECEMBER that corresponds to the string. If the string is not
433 * recognised, this method returns -1.
434 *
435 * @param s the string to parse.
436 *
437 * @return <code>-1</code> if the string is not parseable, the month of the
438 * year otherwise.
439 <em>/
440 public static int stringToMonthCode(String s) {
441
442 final String[] shortMonthNames = DATE_FORMAT_SYMBOLS.getShortMonths();
443 final String[] monthNames = DATE_FORMAT_SYMBOLS.getMonths();
444
445 int result = -1;
446 s = s.trim();
447
448 // first try parsing the string as an integer (1-12)...
449 try {
450 result = Integer.parseInt(s);
451 }
452 catch (NumberFormatException e) {
453 // suppress
454 }
455
456 // now search through the month names...
457 if ((result &lt; 1) || (result &gt; 12)) {
458 for (int i = 0; i &lt; monthNames.length; i++) {
459 if (s.equals(shortMonthNames[i])) {
460 result = i + 1;
461 break;
462 }
463 if (s.equals(monthNames[i])) {
464 result = i + 1;
465 break;
466 }
467 }
468 }
469
470 return result;
471
472 }
473
474 /</em>*</P></p><div class="language- extra-class"><pre class="language-text"><code>Listing B-1 (continued)
SerialDate.Java
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 357</p> <p>475 * Returns true if the supplied integer code represents a valid
476 * week-in-the-month, and false otherwise.
477 *
478 * @param code the code being checked for validity.
479 * @return <code>true</code> if the supplied integer code represents a
480 * valid week-in-the-month.
481 <em>/
482 public static boolean isValidWeekInMonthCode(final int code) {
483
484 switch(code) {
485 case FIRST_WEEK_IN_MONTH:
486 case SECOND_WEEK_IN_MONTH:
487 case THIRD_WEEK_IN_MONTH:
488 case FOURTH_WEEK_IN_MONTH:
489 case LAST_WEEK_IN_MONTH: return true;
490 default: return false;
491 }
492
493 }
494
495 /</em>*
496 * Determines whether or not the specified year is a leap year.
497 *
498 * @param yyyy the year (in the range 1900 to 9999).
499 *
500 * @return <code>true</code> if the specified year is a leap year.
501 <em>/
502 public static boolean isLeapYear(final int yyyy) {
503
504 if ((yyyy % 4) != 0) {
505 return false;
506 }
507 else if ((yyyy % 400) == 0) {
508 return true;
509 }
510 else if ((yyyy % 100) == 0) {
511 return false;
512 }
513 else {
514 return true;
515 }
516
517 }
518
519 /</em>*
520 * Returns the number of leap years from 1900 to the specified year
521 * INCLUSIVE.
522 * <P>
523 * Note that 1900 is not a leap year.
524 *
525 * @param yyyy the year (in the range 1900 to 9999).
526 *
527 * @return the number of leap years from 1900 to the specified year.
528 */
529 public static int leapYearCount(final int yyyy) {
530
531 final int leap4 = (yyyy - 1896) / 4;
532 final int leap100 = (yyyy - 1800) / 100;
533 final int leap400 = (yyyy - 1600) / 400;
534 return leap4 - leap100 + leap400;
535
536 }</P></p><div class="language- extra-class"><pre class="language-text"><code>Listing B-1 (continued)
SerialDate.Java
</code></pre></div><p>358 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>537
538 /**
539 * Returns the number of the last day of the month, taking into account
540 * leap years.
541 *
542 * @param month the month.
543 * @param yyyy the year (in the range 1900 to 9999).
544 *
545 * @return the number of the last day of the month.
546 <em>/
547 public static int lastDayOfMonth(final int month, final int yyyy) {
548
549 final int result = LAST_DAY_OF_MONTH[month];
550 if (month != FEBRUARY) {
551 return result;
552 }
553 else if (isLeapYear(yyyy)) {
554 return result + 1;
555 }
556 else {
557 return result;
558 }
559
560 }
561
562 /</em>*
563 * Creates a new date by adding the specified number of days to the base
564 * date.
565 *
566 * @param days the number of days to add (can be negative).
567 * @param base the base date.
568 *
569 * @return a new date.
570 <em>/
571 public static SerialDate addDays(final int days, final SerialDate base) {
572
573 final int serialDayNumber = base.toSerial() + days;
574 return SerialDate.createInstance(serialDayNumber);
575
576 }
577
578 /</em>*
579 * Creates a new date by adding the specified number of months to the base
580 * date.
581 * <P>
582 * If the base date is close to the end of the month, the day on the result
583 * may be adjusted slightly: 31 May + 1 month = 30 June.
584 *
585 * @param months the number of months to add (can be negative).
586 * @param base the base date.
587 *
588 * @return a new date.
589 */
590 public static SerialDate addMonths(final int months,
591 final SerialDate base) {
592
593 final int yy = (12 * base.getYYYY() + base.getMonth() + months - 1)
594 / 12;
595 final int mm = (12 * base.getYYYY() + base.getMonth() + months - 1)
596 % 12 + 1;
597 final int dd = Math.min(
598 base.getDayOfMonth(), SerialDate.lastDayOfMonth(mm, yy)</P></p><div class="language- extra-class"><pre class="language-text"><code>Listing B-1 (continued)
SerialDate.Java
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 359</p> <p>599 );
600 return SerialDate.createInstance(dd, mm, yy);
601
602 }
603
604 /**
605 * Creates a new date by adding the specified number of years to the base
606 * date.
607 *
608 * @param years the number of years to add (can be negative).
609 * @param base the base date.
610 *
611 * @return A new date.
612 <em>/
613 public static SerialDate addYears(final int years, final SerialDate base) {
614
615 final int baseY = base.getYYYY();
616 final int baseM = base.getMonth();
617 final int baseD = base.getDayOfMonth();
618
619 final int targetY = baseY + years;
620 final int targetD = Math.min(
621 baseD, SerialDate.lastDayOfMonth(baseM, targetY)
622 );
623
624 return SerialDate.createInstance(targetD, baseM, targetY);
625
626 }
627
628 /</em>*
629 * Returns the latest date that falls on the specified day-of-the-week and
630 * is BEFORE the base date.
631 *
632 * @param targetWeekday a code for the target day-of-the-week.
633 * @param base the base date.
634 *
635 * @return the latest date that falls on the specified day-of-the-week and
636 * is BEFORE the base date.
637 */
638 public static SerialDate getPreviousDayOfWeek(final int targetWeekday,
639 final SerialDate base) {
640
641 // check arguments...
642 if (!SerialDate.isValidWeekdayCode(targetWeekday)) {
643 throw new IllegalArgumentException(
644 &quot;Invalid day-of-the-week code.&quot;
645 );
646 }
647
648 // find the date...
649 final int adjust;
650 final int baseDOW = base.getDayOfWeek();
651 if (baseDOW &gt; targetWeekday) {
652 adjust = Math.min(0, targetWeekday - baseDOW);
653 }
654 else {
655 adjust = -7 + Math.max(0, targetWeekday - baseDOW);
656 }
657
658 return SerialDate.addDays(adjust, base);
659
660 }</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-1 (continued)
SerialDate.Java
</code></pre></div><p>360 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>661
662 /**
663 * Returns the earliest date that falls on the specified day-of-the-week
664 * and is AFTER the base date.
665 *
666 * @param targetWeekday a code for the target day-of-the-week.
667 * @param base the base date.
668 *
669 * @return the earliest date that falls on the specified day-of-the-week
670 * and is AFTER the base date.
671 <em>/
672 public static SerialDate getFollowingDayOfWeek(final int targetWeekday,
673 final SerialDate base) {
674
675 // check arguments...
676 if (!SerialDate.isValidWeekdayCode(targetWeekday)) {
677 throw new IllegalArgumentException(
678 &quot;Invalid day-of-the-week code.&quot;
679 );
680 }
681
682 // find the date...
683 final int adjust;
684 final int baseDOW = base.getDayOfWeek();
685 if (baseDOW &gt; targetWeekday) {
686 adjust = 7 + Math.min(0, targetWeekday - baseDOW);
687 }
688 else {
689 adjust = Math.max(0, targetWeekday - baseDOW);
690 }
691
692 return SerialDate.addDays(adjust, base);
693 }
694
695 /</em>*
696 * Returns the date that falls on the specified day-of-the-week and is
697 * CLOSEST to the base date.
698 *
699 * @param targetDOW a code for the target day-of-the-week.
700 * @param base the base date.
701 *
702 * @return the date that falls on the specified day-of-the-week and is
703 * CLOSEST to the base date.
704 */
705 public static SerialDate getNearestDayOfWeek(final int targetDOW,
706 final SerialDate base) {
707
708 // check arguments...
709 if (!SerialDate.isValidWeekdayCode(targetDOW)) {
710 throw new IllegalArgumentException(
711 &quot;Invalid day-of-the-week code.&quot;
712 );
713 }
714
715 // find the date...
716 final int baseDOW = base.getDayOfWeek();
717 int adjust = -Math.abs(targetDOW - baseDOW);
718 if (adjust &gt;= 4) {
719 adjust = 7 - adjust;
720 }
721 if (adjust &lt;= -4) {
722 adjust = 7 + adjust;</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-1 (continued)
SerialDate.Java
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 361</p> <p>723 }
724 return SerialDate.addDays(adjust, base);
725
726 }
727
728 /**
729 * Rolls the date forward to the last day of the month.
730 *
731 * @param base the base date.
732 *
733 * @return a new serial date.
734 <em>/
735 public SerialDate getEndOfCurrentMonth(final SerialDate base) {
736 final int last = SerialDate.lastDayOfMonth(
737 base.getMonth(), base.getYYYY()
738 );
739 return SerialDate.createInstance(last, base.getMonth(), base.getYYYY());
740 }
741
742 /</em>*
743 * Returns a string corresponding to the week-in-the-month code.
744 * <P>
745 * Need to find a better approach.
746 *
747 * @param count an integer code representing the week-in-the-month.
748 *
749 * @return a string corresponding to the week-in-the-month code.
750 <em>/
751 public static String weekInMonthToString(final int count) {
752
753 switch (count) {
754 case SerialDate.FIRST_WEEK_IN_MONTH : return &quot;First&quot;;
755 case SerialDate.SECOND_WEEK_IN_MONTH : return &quot;Second&quot;;
756 case SerialDate.THIRD_WEEK_IN_MONTH : return &quot;Third&quot;;
757 case SerialDate.FOURTH_WEEK_IN_MONTH : return &quot;Fourth&quot;;
758 case SerialDate.LAST_WEEK_IN_MONTH : return &quot;Last&quot;;
759 default :
760 return &quot;SerialDate.weekInMonthToString(): invalid code.&quot;;
761 }
762
763 }
764
765 /</em>*
766 * Returns a string representing the supplied 'relative'.
767 * <P>
768 * Need to find a better approach.
769 *
770 * @param relative a constant representing the 'relative'.
771 *
772 * @return a string representing the supplied 'relative'.
773 */
774 public static String relativeToString(final int relative) {
775
776 switch (relative) {
777 case SerialDate.PRECEDING : return &quot;Preceding&quot;;
778 case SerialDate.NEAREST : return &quot;Nearest&quot;;
779 case SerialDate.FOLLOWING : return &quot;Following&quot;;
780 default : return &quot;ERROR : Relative To String&quot;;
781 }
782
783 }
784</P> <div class="language- extra-class"><pre class="language-text"><code>Listing B-1 (continued)
SerialDate.Java
</code></pre></div><p>362 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>785 /**
786 * Factory method that returns an instance of some concrete subclass of
787 * {@link SerialDate}.
788 *
789 * @param day the day (1-31).
790 * @param month the month (1-12).
791 * @param yyyy the year (in the range 1900 to 9999).
792 *
793 * @return An instance of {@link SerialDate}.
794 <em>/
795 public static SerialDate createInstance(final int day, final int month,
796 final int yyyy) {
797 return new SpreadsheetDate(day, month, yyyy);
798 }
799
800 /</em>*
801 * Factory method that returns an instance of some concrete subclass of
802 * {@link SerialDate}.
803 *
804 * @param serial the serial number for the day (1 January 1900 = 2).
805 *
806 * @return a instance of SerialDate.
807 <em>/
808 public static SerialDate createInstance(final int serial) {
809 return new SpreadsheetDate(serial);
810 }
811
812 /</em>*
813 * Factory method that returns an instance of a subclass of SerialDate.
814 *
815 * @param date A Java date object.
816 *
817 * @return a instance of SerialDate.
818 <em>/
819 public static SerialDate createInstance(final java.util.Date date) {
820
821 final GregorianCalendar calendar = new GregorianCalendar();
822 calendar.setTime(date);
823 return new SpreadsheetDate(calendar.get(Calendar.DATE),
824 calendar.get(Calendar.MONTH) + 1,
825 calendar.get(Calendar.YEAR));
826
827 }
828
829 /</em>*
830 * Returns the serial number for the date, where 1 January 1900 = 2 (this
831 * corresponds, almost, to the numbering system used in Microsoft Excel for
832 * Windows and Lotus 1-2-3).
833 *
834 * @return the serial number for the date.
835 <em>/
836 public abstract int toSerial();
837
838 /</em>*
839 * Returns a java.util.Date. Since java.util.Date has more precision than
840 * SerialDate, we need to define a convention for the 'time of day'.
841 *
842 * @return this as <code>java.util.Date</code>.
843 <em>/
844 public abstract java.util.Date toDate();
845
846 /</em>*</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-1 (continued)
SerialDate.Java
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 363</p> <p>847 * Returns a description of the date.
848 *
849 * @return a description of the date.
850 <em>/
851 public String getDescription() {
852 return this.description;
853 }
854
855 /</em>*
856 * Sets the description for the date.
857 *
858 * @param description the new description for the date.
859 <em>/
860 public void setDescription(final String description) {
861 this.description = description;
862 }
863
864 /</em>*
865 * Converts the date to a string.
866 *
867 * @return a string representation of the date.
868 <em>/
869 public String toString() {
870 return getDayOfMonth() + &quot;-&quot; + SerialDate.monthCodeToString(getMonth())
871 + &quot;-&quot; + getYYYY();
872 }
873
874 /</em>*
875 * Returns the year (assume a valid range of 1900 to 9999).
876 *
877 * @return the year.
878 <em>/
879 public abstract int getYYYY();
880
881 /</em>*
882 * Returns the month (January = 1, February = 2, March = 3).
883 *
884 * @return the month of the year.
885 <em>/
886 public abstract int getMonth();
887
888 /</em>*
889 * Returns the day of the month.
890 *
891 * @return the day of the month.
892 <em>/
893 public abstract int getDayOfMonth();
894
895 /</em>*
896 * Returns the day of the week.
897 *
898 * @return the day of the week.
899 <em>/
900 public abstract int getDayOfWeek();
901
902 /</em>*
903 * Returns the difference (in days) between this date and the specified
904 * 'other' date.
905 * <P>
906 * The result is positive if this date is after the 'other' date and
907 * negative if it is before the 'other' date.
908 *</P></p><div class="language- extra-class"><pre class="language-text"><code>Listing B-1 (continued)
SerialDate.Java
</code></pre></div><p>364 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>909 * @param other the date being compared to.
910 *
911 * @return the difference between this and the other date.
912 <em>/
913 public abstract int compare(SerialDate other);
914
915 /</em>*
916 * Returns true if this SerialDate represents the same date as the
917 * specified SerialDate.
918 *
919 * @param other the date being compared to.
920 *
921 * @return <code>true</code> if this SerialDate represents the same date as
922 * the specified SerialDate.
923 <em>/
924 public abstract boolean isOn(SerialDate other);
925
926 /</em>*
927 * Returns true if this SerialDate represents an earlier date compared to
928 * the specified SerialDate.
929 *
930 * @param other The date being compared to.
931 *
932 * @return <code>true</code> if this SerialDate represents an earlier date
933 * compared to the specified SerialDate.
934 <em>/
935 public abstract boolean isBefore(SerialDate other);
936
937 /</em>*
938 * Returns true if this SerialDate represents the same date as the
939 * specified SerialDate.
940 *
941 * @param other the date being compared to.
942 *
943 * @return <code>true<code> if this SerialDate represents the same date
944 * as the specified SerialDate.
945 <em>/
946 public abstract boolean isOnOrBefore(SerialDate other);
947
948 /</em>*
949 * Returns true if this SerialDate represents the same date as the
950 * specified SerialDate.
951 *
952 * @param other the date being compared to.
953 *
954 * @return <code>true</code> if this SerialDate represents the same date
955 * as the specified SerialDate.
956 <em>/
957 public abstract boolean isAfter(SerialDate other);
958
959 /</em>*
960 * Returns true if this SerialDate represents the same date as the
961 * specified SerialDate.
962 *
963 * @param other the date being compared to.
964 *
965 * @return <code>true</code> if this SerialDate represents the same date
966 * as the specified SerialDate.
967 <em>/
968 public abstract boolean isOnOrAfter(SerialDate other);
969
970 /</em>*
971 * Returns <code>true</code> if this {@link SerialDate} is within the</code></code></p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-1 (continued)
SerialDate.Java
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 365</p> <p>972 * specified range (INCLUSIVE). The date order of d1 and d2 is not
973 * important.
974 *
975 * @param d1 a boundary date for the range.
976 * @param d2 the other boundary date for the range.
977 *
978 * @return A boolean.
979 <em>/
980 public abstract boolean isInRange(SerialDate d1, SerialDate d2);
981
982 /</em>*
983 * Returns <code>true</code> if this {@link SerialDate} is within the
984 * specified range (caller specifies whether or not the end-points are
985 * included). The date order of d1 and d2 is not important.
986 *
987 * @param d1 a boundary date for the range.
988 * @param d2 the other boundary date for the range.
989 * @param include a code that controls whether or not the start and end
990 * dates are included in the range.
991 *
992 * @return A boolean.
993 <em>/
994 public abstract boolean isInRange(SerialDate d1, SerialDate d2,
995 int include);
996
997 /</em>*
998 * Returns the latest date that falls on the specified day-of-the-week and
999 * is BEFORE this date.
1000 *
1001 * @param targetDOW a code for the target day-of-the-week.
1002 *
1003 * @return the latest date that falls on the specified day-of-the-week and
1004 * is BEFORE this date.
1005 <em>/
1006 public SerialDate getPreviousDayOfWeek(final int targetDOW) {
1007 return getPreviousDayOfWeek(targetDOW, this);
1008 }
1009
1010 /</em>*
1011 * Returns the earliest date that falls on the specified day-of-the-week
1012 * and is AFTER this date.
1013 *
1014 * @param targetDOW a code for the target day-of-the-week.
1015 *
1016 * @return the earliest date that falls on the specified day-of-the-week
1017 * and is AFTER this date.
1018 <em>/
1019 public SerialDate getFollowingDayOfWeek(final int targetDOW) {
1020 return getFollowingDayOfWeek(targetDOW, this);
1021 }
1022
1023 /</em>*
1024 * Returns the nearest date that falls on the specified day-of-the-week.
1025 *
1026 * @param targetDOW a code for the target day-of-the-week.
1027 *
1028 * @return the nearest date that falls on the specified day-of-the-week.
1029 */
1030 public SerialDate getNearestDayOfWeek(final int targetDOW) {
1031 return getNearestDayOfWeek(targetDOW, this);
1032 }
1033
1034 }</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-1 (continued)
SerialDate.Java
</code></pre></div><p>366 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p><strong>Listing B-2
SerialDateTest.java</strong>
1 /* ========================================================================
2 * JCommon : a free general purpose class library for the Java(tm) platform
3 * ========================================================================
4 *
5 * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.
6 *
7 * Project Info: <a href="http://www.jfree.org/jcommon/index.html" target="_blank" rel="noopener noreferrer">http://www.jfree.org/jcommon/index.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
8 *
9 * This library is free software; you can redistribute it and/or modify it
10 * under the terms of the GNU Lesser General Public License as published by
11 * the Free Software Foundation; either version 2.1 of the License, or
12 * (at your option) any later version.
13 *
14 * This library is distributed in the hope that it will be useful, but
15 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
16 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
17 * License for more details.
18 *
19 * You should have received a copy of the GNU Lesser General Public
20 * License along with this library; if not, write to the Free Software
21 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
22 * USA.
23 *
24 * [Java is a trademark or registered trademark of Sun Microsystems, Inc.
25 * in the United States and other countries.]
26 *
27 * --------------------
28 * SerialDateTests.java
29 * --------------------
30 * (C) Copyright 2001-2005, by Object Refinery Limited.
31 *
32 * Original Author: David Gilbert (for Object Refinery Limited);
33 * Contributor(s): -;
34 *
35 * $Id: SerialDateTests.java,v 1.6 2005/11/16 15:58:40 taqua Exp $
36 *
37 * Changes
38 * -------
39 * 15-Nov-2001 : Version 1 (DG);
40 * 25-Jun-2002 : Removed unnecessary import (DG);
41 * 24-Oct-2002 : Fixed errors reported by Checkstyle (DG);
42 * 13-Mar-2003 : Added serialization test (DG);
43 * 05-Jan-2005 : Added test for bug report 1096282 (DG);
44 *
45 */
46
47 package org.jfree.date.junit;
48
49 import java.io.ByteArrayInputStream;
50 import java.io.ByteArrayOutputStream;
51 import java.io.ObjectInput;
52 import java.io.ObjectInputStream;
53 import java.io.ObjectOutput;
54 import java.io.ObjectOutputStream;
55
56 import junit.framework.Test;
57 import junit.framework.TestCase;
58 import junit.framework.TestSuite;
59
60 import org.jfree.date.MonthConstants;
61 import org.jfree.date.SerialDate;
62</p> <p><strong>Appendix B: org.jfree.date.SerialDate</strong> 367</p> <p>63 /**
64 * Some JUnit tests for the {@link SerialDate} class.
65 <em>/
66 public class SerialDateTests extends TestCase {
67
68 /</em>* Date representing November 9. <em>/
69 private SerialDate nov9Y2001;
70
71 /</em>*
72 * Creates a new test case.
73 *
74 * @param name the name.
75 <em>/
76 public SerialDateTests(final String name) {
77 super(name);
78 }
79
80 /</em>*
81 * Returns a test suite for the JUnit test runner.
82 *
83 * @return The test suite.
84 <em>/
85 public static Test suite() {
86 return new TestSuite(SerialDateTests.class);
87 }
88
89 /</em>*
90 * Problem set up.
91 <em>/
92 protected void setUp() {
93 this.nov9Y2001 = SerialDate.createInstance(9, MonthConstants.NOVEMBER, 2001);
94 }
95
96 /</em>*
97 * 9 Nov 2001 plus two months should be 9 Jan 2002.
98 <em>/
99 public void testAddMonthsTo9Nov2001() {
100 final SerialDate jan9Y2002 = SerialDate.addMonths(2, this.nov9Y2001);
101 final SerialDate answer = SerialDate.createInstance(9, 1, 2002);
102 assertEquals(answer, jan9Y2002);
103 }
104
105 /</em>*
106 * A test case for a reported bug, now fixed.
107 <em>/
108 public void testAddMonthsTo5Oct2003() {
109 final SerialDate d1 = SerialDate.createInstance(5, MonthConstants.OCTOBER, 2003);
110 final SerialDate d2 = SerialDate.addMonths(2, d1);
111 assertEquals(d2, SerialDate.createInstance(5, MonthConstants.DECEMBER, 2003));
112 }
113
114 /</em>*
115 * A test case for a reported bug, now fixed.
116 <em>/
117 public void testAddMonthsTo1Jan2003() {
118 final SerialDate d1 = SerialDate.createInstance(1, MonthConstants.JANUARY, 2003);
119 final SerialDate d2 = SerialDate.addMonths(0, d1);
120 assertEquals(d2, d1);
121 }
122
123 /</em>*
124 * Monday preceding Friday 9 November 2001 should be 5 November.</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-2 (continued)
SerialDateTest.java
</code></pre></div><p>368 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>125 <em>/
126 public void testMondayPrecedingFriday9Nov2001() {
127 SerialDate mondayBefore = SerialDate.getPreviousDayOfWeek(
128 SerialDate.MONDAY, this.nov9Y2001
129 );
130 assertEquals(5, mondayBefore.getDayOfMonth());
131 }
132
133 /</em>*
134 * Monday following Friday 9 November 2001 should be 12 November.
135 <em>/
136 public void testMondayFollowingFriday9Nov2001() {
137 SerialDate mondayAfter = SerialDate.getFollowingDayOfWeek(
138 SerialDate.MONDAY, this.nov9Y2001
139 );
140 assertEquals(12, mondayAfter.getDayOfMonth());
141 }
142
143 /</em>*
144 * Monday nearest Friday 9 November 2001 should be 12 November.
145 <em>/
146 public void testMondayNearestFriday9Nov2001() {
147 SerialDate mondayNearest = SerialDate.getNearestDayOfWeek(
148 SerialDate.MONDAY, this.nov9Y2001
149 );
150 assertEquals(12, mondayNearest.getDayOfMonth());
151 }
152
153 /</em>*
154 * The Monday nearest to 22nd January 1970 falls on the 19th.
155 <em>/
156 public void testMondayNearest22Jan1970() {
157 SerialDate jan22Y1970 = SerialDate.createInstance(22, MonthConstants.JANUARY, 1970);
158 SerialDate mondayNearest=SerialDate.getNearestDayOfWeek(SerialDate.MONDAY, jan22Y1970);
159 assertEquals(19, mondayNearest.getDayOfMonth());
160 }
161
162 /</em>*
163 * Problem that the conversion of days to strings returns the right result. Actually, this
164 * result depends on the Locale so this test needs to be modified.
165 <em>/
166 public void testWeekdayCodeToString() {
167
168 final String test = SerialDate.weekdayCodeToString(SerialDate.SATURDAY);
169 assertEquals(&quot;Saturday&quot;, test);
170
171 }
172
173 /</em>*
174 * Test the conversion of a string to a weekday. Note that this test will fail if the
175 * default locale doesn't use English weekday names...devise a better test!
176 */
177 public void testStringToWeekday() {
178
179 int weekday = SerialDate.stringToWeekdayCode(&quot;Wednesday&quot;);
180 assertEquals(SerialDate.WEDNESDAY, weekday);
181
182 weekday = SerialDate.stringToWeekdayCode(&quot; Wednesday &quot;);
183 assertEquals(SerialDate.WEDNESDAY, weekday);
184</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-2 (continued)
SerialDateTest.java
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 369</p> <p>185 weekday = SerialDate.stringToWeekdayCode(&quot;Wed&quot;);
186 assertEquals(SerialDate.WEDNESDAY, weekday);
187
188 }
189
190 /**
191 * Test the conversion of a string to a month. Note that this test will fail if the
192 * default locale doesn't use English month names...devise a better test!
193 <em>/
194 public void testStringToMonthCode() {
195
196 int m = SerialDate.stringToMonthCode(&quot;January&quot;);
197 assertEquals(MonthConstants.JANUARY, m);
198
199 m = SerialDate.stringToMonthCode(&quot; January &quot;);
200 assertEquals(MonthConstants.JANUARY, m);
201
202 m = SerialDate.stringToMonthCode(&quot;Jan&quot;);
203 assertEquals(MonthConstants.JANUARY, m);
204
205 }
206
207 /</em>*
208 * Tests the conversion of a month code to a string.
209 <em>/
210 public void testMonthCodeToStringCode() {
211
212 final String test = SerialDate.monthCodeToString(MonthConstants.DECEMBER);
213 assertEquals(&quot;December&quot;, test);
214
215 }
216
217 /</em>*
218 * 1900 is not a leap year.
219 <em>/
220 public void testIsNotLeapYear1900() {
221 assertTrue(!SerialDate.isLeapYear(1900));
222 }
223
224 /</em>*
225 * 2000 is a leap year.
226 <em>/
227 public void testIsLeapYear2000() {
228 assertTrue(SerialDate.isLeapYear(2000));
229 }
230
231 /</em>*
232 * The number of leap years from 1900 up-to-and-including 1899 is 0.
233 <em>/
234 public void testLeapYearCount1899() {
235 assertEquals(SerialDate.leapYearCount(1899), 0);
236 }
237
238 /</em>*
239 * The number of leap years from 1900 up-to-and-including 1903 is 0.
240 <em>/
241 public void testLeapYearCount1903() {
242 assertEquals(SerialDate.leapYearCount(1903), 0);
243 }
244
245 /</em>*
246 * The number of leap years from 1900 up-to-and-including 1904 is 1.
247 */</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-2 (continued)
SerialDateTest.java
</code></pre></div><p>370 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>248 public void testLeapYearCount1904() {
249 assertEquals(SerialDate.leapYearCount(1904), 1);
250 }
251
252 /**
253 * The number of leap years from 1900 up-to-and-including 1999 is 24.
254 <em>/
255 public void testLeapYearCount1999() {
256 assertEquals(SerialDate.leapYearCount(1999), 24);
257 }
258
259 /</em>*
260 * The number of leap years from 1900 up-to-and-including 2000 is 25.
261 <em>/
262 public void testLeapYearCount2000() {
263 assertEquals(SerialDate.leapYearCount(2000), 25);
264 }
265
266 /</em>*
267 * Serialize an instance, restore it, and check for equality.
268 <em>/
269 public void testSerialization() {
270
271 SerialDate d1 = SerialDate.createInstance(15, 4, 2000);
272 SerialDate d2 = null;
273
274 try {
275 ByteArrayOutputStream buffer = new ByteArrayOutputStream();
276 ObjectOutput out = new ObjectOutputStream(buffer);
277 out.writeObject(d1);
278 out.close();
279
280 ObjectInput in = new ObjectInputStream(
new ByteArrayInputStream(buffer.toByteArray()));
281 d2 = (SerialDate) in.readObject();
282 in.close();
283 }
284 catch (Exception e) {
285 System.out.println(e.toString());
286 }
287 assertEquals(d1, d2);
288
289 }
290
291 /</em>*
292 * A test for bug report 1096282 (now fixed).
293 <em>/
294 public void test1096282() {
295 SerialDate d = SerialDate.createInstance(29, 2, 2004);
296 d = SerialDate.addYears(1, d);
297 SerialDate expected = SerialDate.createInstance(28, 2, 2005);
298 assertTrue(d.isOn(expected));
299 }
300
301 /</em>*
302 * Miscellaneous tests for the addMonths() method.
303 */
304 public void testAddMonths() {
305 SerialDate d1 = SerialDate.createInstance(31, 5, 2004);
306</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-2 (continued)
SerialDateTest.java
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 371</p> <p>307 SerialDate d2 = SerialDate.addMonths(1, d1);
308 assertEquals(30, d2.getDayOfMonth());
309 assertEquals(6, d2.getMonth());
310 assertEquals(2004, d2.getYYYY());
311
312 SerialDate d3 = SerialDate.addMonths(2, d1);
313 assertEquals(31, d3.getDayOfMonth());
314 assertEquals(7, d3.getMonth());
315 assertEquals(2004, d3.getYYYY());
316
317 SerialDate d4 = SerialDate.addMonths(1, SerialDate.addMonths(1, d1));
318 assertEquals(30, d4.getDayOfMonth());
319 assertEquals(7, d4.getMonth());
320 assertEquals(2004, d4.getYYYY());
321 }
322 }</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-2 (continued)
SerialDateTest.java
</code></pre></div><p>372 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p><strong>Listing B-3
MonthConstants.java</strong>
1 /* ========================================================================
2 * JCommon : a free general purpose class library for the Java(tm) platform
3 * ========================================================================
4 *
5 * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.
6 *
7 * Project Info: <a href="http://www.jfree.org/jcommon/index.html" target="_blank" rel="noopener noreferrer">http://www.jfree.org/jcommon/index.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
8 *
9 * This library is free software; you can redistribute it and/or modify it
10 * under the terms of the GNU Lesser General Public License as published by
11 * the Free Software Foundation; either version 2.1 of the License, or
12 * (at your option) any later version.
13 *
14 * This library is distributed in the hope that it will be useful, but
15 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
16 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
17 * License for more details.
18 *
19 * You should have received a copy of the GNU Lesser General Public
20 * License along with this library; if not, write to the Free Software
21 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
22 * USA.
23 *
24 * [Java is a trademark or registered trademark of Sun Microsystems, Inc.
25 * in the United States and other countries.]
26 *
27 * -------------------
28 * MonthConstants.java
29 * -------------------
30 * (C) Copyright 2002, 2003, by Object Refinery Limited.
31 *
32 * Original Author: David Gilbert (for Object Refinery Limited);
33 * Contributor(s): -;
34 *
35 * $Id: MonthConstants.java,v 1.4 2005/11/16 15:58:40 taqua Exp $
36 *
37 * Changes
38 * -------
39 * 29-May-2002 : Version 1 (code moved from SerialDate class) (DG);
40 *
41 <em>/
42
43 package org.jfree.date;
44
45 /</em>*
46 * Useful constants for months. Note that these are NOT equivalent to the
47 * constants defined by java.util.Calendar (where JANUARY=0 and DECEMBER=11).
48 * <P>
49 * Used by the SerialDate and RegularTimePeriod classes.
50 *
51 * @author David Gilbert
52 <em>/
53 public interface MonthConstants {
54
55 /</em>* Constant for January. <em>/
56 public static final int JANUARY = 1;
57
58 /</em>* Constant for February. */
59 public static final int FEBRUARY = 2;
60</P></p><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 373</p> <p>61 /** Constant for March. <em>/
62 public static final int MARCH = 3;
63
64 /</em>* Constant for April. <em>/
65 public static final int APRIL = 4;
66
67 /</em>* Constant for May. <em>/
68 public static final int MAY = 5;
69
70 /</em>* Constant for June. <em>/
71 public static final int JUNE = 6;
72
73 /</em>* Constant for July. <em>/
74 public static final int JULY = 7;
75
76 /</em>* Constant for August. <em>/
77 public static final int AUGUST = 8;
78
79 /</em>* Constant for September. <em>/
80 public static final int SEPTEMBER = 9;
81
82 /</em>* Constant for October. <em>/
83 public static final int OCTOBER = 10;
84
85 /</em>* Constant for November. <em>/
86 public static final int NOVEMBER = 11;
87
88 /</em>* Constant for December. */
89 public static final int DECEMBER = 12;
90
91 }</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-3 (continued)
MonthConstants.java
</code></pre></div><p>374 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p><strong>Listing B-4
BobsSerialDateTest.java</strong>
1 package org.jfree.date.junit;
2
3 import junit.framework.TestCase;
4 import org.jfree.date.<em>;
5 import static org.jfree.date.SerialDate.</em>;
6
7 import java.util.*;
8
9 public class BobsSerialDateTest extends TestCase {
10
11 public void testIsValidWeekdayCode() throws Exception {
12 for (int day = 1; day &lt;= 7; day++)
13 assertTrue(isValidWeekdayCode(day));
14 assertFalse(isValidWeekdayCode(0));
15 assertFalse(isValidWeekdayCode(8));
16 }
17
18 public void testStringToWeekdayCode() throws Exception {
19
20 assertEquals(-1, stringToWeekdayCode(&quot;Hello&quot;));
21 assertEquals(MONDAY, stringToWeekdayCode(&quot;Monday&quot;));
22 assertEquals(MONDAY, stringToWeekdayCode(&quot;Mon&quot;));
23 //todo assertEquals(MONDAY,stringToWeekdayCode(&quot;monday&quot;));
24 // assertEquals(MONDAY,stringToWeekdayCode(&quot;MONDAY&quot;));
25 // assertEquals(MONDAY, stringToWeekdayCode(&quot;mon&quot;));
26
27 assertEquals(TUESDAY, stringToWeekdayCode(&quot;Tuesday&quot;));
28 assertEquals(TUESDAY, stringToWeekdayCode(&quot;Tue&quot;));
29 // assertEquals(TUESDAY,stringToWeekdayCode(&quot;tuesday&quot;));
30 // assertEquals(TUESDAY,stringToWeekdayCode(&quot;TUESDAY&quot;));
31 // assertEquals(TUESDAY, stringToWeekdayCode(&quot;tue&quot;));
32 // assertEquals(TUESDAY, stringToWeekdayCode(&quot;tues&quot;));
33
34 assertEquals(WEDNESDAY, stringToWeekdayCode(&quot;Wednesday&quot;));
35 assertEquals(WEDNESDAY, stringToWeekdayCode(&quot;Wed&quot;));
36 // assertEquals(WEDNESDAY,stringToWeekdayCode(&quot;wednesday&quot;));
37 // assertEquals(WEDNESDAY,stringToWeekdayCode(&quot;WEDNESDAY&quot;));
38 // assertEquals(WEDNESDAY, stringToWeekdayCode(&quot;wed&quot;));
39
40 assertEquals(THURSDAY, stringToWeekdayCode(&quot;Thursday&quot;));
41 assertEquals(THURSDAY, stringToWeekdayCode(&quot;Thu&quot;));
42 // assertEquals(THURSDAY,stringToWeekdayCode(&quot;thursday&quot;));
43 // assertEquals(THURSDAY,stringToWeekdayCode(&quot;THURSDAY&quot;));
44 // assertEquals(THURSDAY, stringToWeekdayCode(&quot;thu&quot;));
45 // assertEquals(THURSDAY, stringToWeekdayCode(&quot;thurs&quot;));
46
47 assertEquals(FRIDAY, stringToWeekdayCode(&quot;Friday&quot;));
48 assertEquals(FRIDAY, stringToWeekdayCode(&quot;Fri&quot;));
49 // assertEquals(FRIDAY,stringToWeekdayCode(&quot;friday&quot;));
50 // assertEquals(FRIDAY,stringToWeekdayCode(&quot;FRIDAY&quot;));
51 // assertEquals(FRIDAY, stringToWeekdayCode(&quot;fri&quot;));
52
53 assertEquals(SATURDAY, stringToWeekdayCode(&quot;Saturday&quot;));
54 assertEquals(SATURDAY, stringToWeekdayCode(&quot;Sat&quot;));
55 // assertEquals(SATURDAY,stringToWeekdayCode(&quot;saturday&quot;));
56 // assertEquals(SATURDAY,stringToWeekdayCode(&quot;SATURDAY&quot;));
57 // assertEquals(SATURDAY, stringToWeekdayCode(&quot;sat&quot;));
58
59 assertEquals(SUNDAY, stringToWeekdayCode(&quot;Sunday&quot;));
60 assertEquals(SUNDAY, stringToWeekdayCode(&quot;Sun&quot;));
61 // assertEquals(SUNDAY,stringToWeekdayCode(&quot;sunday&quot;));
62 // assertEquals(SUNDAY,stringToWeekdayCode(&quot;SUNDAY&quot;));
63 // assertEquals(SUNDAY, stringToWeekdayCode(&quot;sun&quot;));
64 }
65</p> <p><strong>Appendix B: org.jfree.date.SerialDate</strong> 375</p> <p>66 public void testWeekdayCodeToString() throws Exception {
67 assertEquals(&quot;Sunday&quot;, weekdayCodeToString(SUNDAY));
68 assertEquals(&quot;Monday&quot;, weekdayCodeToString(MONDAY));
69 assertEquals(&quot;Tuesday&quot;, weekdayCodeToString(TUESDAY));
70 assertEquals(&quot;Wednesday&quot;, weekdayCodeToString(WEDNESDAY));
71 assertEquals(&quot;Thursday&quot;, weekdayCodeToString(THURSDAY));
72 assertEquals(&quot;Friday&quot;, weekdayCodeToString(FRIDAY));
73 assertEquals(&quot;Saturday&quot;, weekdayCodeToString(SATURDAY));
74 }
75
76 public void testIsValidMonthCode() throws Exception {
77 for (int i = 1; i &lt;= 12; i++)
78 assertTrue(isValidMonthCode(i));
79 assertFalse(isValidMonthCode(0));
80 assertFalse(isValidMonthCode(13));
81 }
82
83 public void testMonthToQuarter() throws Exception {
84 assertEquals(1, monthCodeToQuarter(JANUARY));
85 assertEquals(1, monthCodeToQuarter(FEBRUARY));
86 assertEquals(1, monthCodeToQuarter(MARCH));
87 assertEquals(2, monthCodeToQuarter(APRIL));
88 assertEquals(2, monthCodeToQuarter(MAY));
89 assertEquals(2, monthCodeToQuarter(JUNE));
90 assertEquals(3, monthCodeToQuarter(JULY));
91 assertEquals(3, monthCodeToQuarter(AUGUST));
92 assertEquals(3, monthCodeToQuarter(SEPTEMBER));
93 assertEquals(4, monthCodeToQuarter(OCTOBER));
94 assertEquals(4, monthCodeToQuarter(NOVEMBER));
95 assertEquals(4, monthCodeToQuarter(DECEMBER));
96
97 try {
98 monthCodeToQuarter(-1);
99 fail(&quot;Invalid Month Code should throw exception&quot;);
100 } catch (IllegalArgumentException e) {
101 }
102 }
103
104 public void testMonthCodeToString() throws Exception {
105 assertEquals(&quot;January&quot;, monthCodeToString(JANUARY));
106 assertEquals(&quot;February&quot;, monthCodeToString(FEBRUARY));
107 assertEquals(&quot;March&quot;, monthCodeToString(MARCH));
108 assertEquals(&quot;April&quot;, monthCodeToString(APRIL));
109 assertEquals(&quot;May&quot;, monthCodeToString(MAY));
110 assertEquals(&quot;June&quot;, monthCodeToString(JUNE));
111 assertEquals(&quot;July&quot;, monthCodeToString(JULY));
112 assertEquals(&quot;August&quot;, monthCodeToString(AUGUST));
113 assertEquals(&quot;September&quot;, monthCodeToString(SEPTEMBER));
114 assertEquals(&quot;October&quot;, monthCodeToString(OCTOBER));
115 assertEquals(&quot;November&quot;, monthCodeToString(NOVEMBER));
116 assertEquals(&quot;December&quot;, monthCodeToString(DECEMBER));
117
118 assertEquals(&quot;Jan&quot;, monthCodeToString(JANUARY, true));
119 assertEquals(&quot;Feb&quot;, monthCodeToString(FEBRUARY, true));
120 assertEquals(&quot;Mar&quot;, monthCodeToString(MARCH, true));
121 assertEquals(&quot;Apr&quot;, monthCodeToString(APRIL, true));
122 assertEquals(&quot;May&quot;, monthCodeToString(MAY, true));
123 assertEquals(&quot;Jun&quot;, monthCodeToString(JUNE, true));
124 assertEquals(&quot;Jul&quot;, monthCodeToString(JULY, true));
125 assertEquals(&quot;Aug&quot;, monthCodeToString(AUGUST, true));
126 assertEquals(&quot;Sep&quot;, monthCodeToString(SEPTEMBER, true));
127 assertEquals(&quot;Oct&quot;, monthCodeToString(OCTOBER, true));</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-4 (continued)
BobsSerialDateTest.java
</code></pre></div><p>376 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>128 assertEquals(&quot;Nov&quot;, monthCodeToString(NOVEMBER, true));
129 assertEquals(&quot;Dec&quot;, monthCodeToString(DECEMBER, true));
130
131 try {
132 monthCodeToString(-1);
133 fail(&quot;Invalid month code should throw exception&quot;);
134 } catch (IllegalArgumentException e) {
135 }
136
137 }
138
139 public void testStringToMonthCode() throws Exception {
140 assertEquals(JANUARY,stringToMonthCode(&quot;1&quot;));
141 assertEquals(FEBRUARY,stringToMonthCode(&quot;2&quot;));
142 assertEquals(MARCH,stringToMonthCode(&quot;3&quot;));
143 assertEquals(APRIL,stringToMonthCode(&quot;4&quot;));
144 assertEquals(MAY,stringToMonthCode(&quot;5&quot;));
145 assertEquals(JUNE,stringToMonthCode(&quot;6&quot;));
146 assertEquals(JULY,stringToMonthCode(&quot;7&quot;));
147 assertEquals(AUGUST,stringToMonthCode(&quot;8&quot;));
148 assertEquals(SEPTEMBER,stringToMonthCode(&quot;9&quot;));
149 assertEquals(OCTOBER,stringToMonthCode(&quot;10&quot;));
150 assertEquals(NOVEMBER, stringToMonthCode(&quot;11&quot;));
151 assertEquals(DECEMBER,stringToMonthCode(&quot;12&quot;));
152
153 //todo assertEquals(-1, stringToMonthCode(&quot;0&quot;));
154 // assertEquals(-1, stringToMonthCode(&quot;13&quot;));
155
156 assertEquals(-1,stringToMonthCode(&quot;Hello&quot;));
157
158 for (int m = 1; m &lt;= 12; m++) {
159 assertEquals(m, stringToMonthCode(monthCodeToString(m, false)));
160 assertEquals(m, stringToMonthCode(monthCodeToString(m, true)));
161 }
162
163 // assertEquals(1,stringToMonthCode(&quot;jan&quot;));
164 // assertEquals(2,stringToMonthCode(&quot;feb&quot;));
165 // assertEquals(3,stringToMonthCode(&quot;mar&quot;));
166 // assertEquals(4,stringToMonthCode(&quot;apr&quot;));
167 // assertEquals(5,stringToMonthCode(&quot;may&quot;));
168 // assertEquals(6,stringToMonthCode(&quot;jun&quot;));
169 // assertEquals(7,stringToMonthCode(&quot;jul&quot;));
170 // assertEquals(8,stringToMonthCode(&quot;aug&quot;));
171 // assertEquals(9,stringToMonthCode(&quot;sep&quot;));
172 // assertEquals(10,stringToMonthCode(&quot;oct&quot;));
173 // assertEquals(11,stringToMonthCode(&quot;nov&quot;));
174 // assertEquals(12,stringToMonthCode(&quot;dec&quot;));
175
176 // assertEquals(1,stringToMonthCode(&quot;JAN&quot;));
177 // assertEquals(2,stringToMonthCode(&quot;FEB&quot;));
178 // assertEquals(3,stringToMonthCode(&quot;MAR&quot;));
179 // assertEquals(4,stringToMonthCode(&quot;APR&quot;));
180 // assertEquals(5,stringToMonthCode(&quot;MAY&quot;));
181 // assertEquals(6,stringToMonthCode(&quot;JUN&quot;));
182 // assertEquals(7,stringToMonthCode(&quot;JUL&quot;));
183 // assertEquals(8,stringToMonthCode(&quot;AUG&quot;));
184 // assertEquals(9,stringToMonthCode(&quot;SEP&quot;));
185 // assertEquals(10,stringToMonthCode(&quot;OCT&quot;));
186 // assertEquals(11,stringToMonthCode(&quot;NOV&quot;));
187 // assertEquals(12,stringToMonthCode(&quot;DEC&quot;));
188
189 // assertEquals(1,stringToMonthCode(&quot;january&quot;));
190 // assertEquals(2,stringToMonthCode(&quot;february&quot;));</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-4 (continued)
BobsSerialDateTest.java
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 377</p> <p>191 // assertEquals(3,stringToMonthCode(&quot;march&quot;));
192 // assertEquals(4,stringToMonthCode(&quot;april&quot;));
193 // assertEquals(5,stringToMonthCode(&quot;may&quot;));
194 // assertEquals(6,stringToMonthCode(&quot;june&quot;));
195 // assertEquals(7,stringToMonthCode(&quot;july&quot;));
196 // assertEquals(8,stringToMonthCode(&quot;august&quot;));
197 // assertEquals(9,stringToMonthCode(&quot;september&quot;));
198 // assertEquals(10,stringToMonthCode(&quot;october&quot;));
199 // assertEquals(11,stringToMonthCode(&quot;november&quot;));
200 // assertEquals(12,stringToMonthCode(&quot;december&quot;));
201
202 // assertEquals(1,stringToMonthCode(&quot;JANUARY&quot;));
203 // assertEquals(2,stringToMonthCode(&quot;FEBRUARY&quot;));
204 // assertEquals(3,stringToMonthCode(&quot;MAR&quot;));
205 // assertEquals(4,stringToMonthCode(&quot;APRIL&quot;));
206 // assertEquals(5,stringToMonthCode(&quot;MAY&quot;));
207 // assertEquals(6,stringToMonthCode(&quot;JUNE&quot;));
208 // assertEquals(7,stringToMonthCode(&quot;JULY&quot;));
209 // assertEquals(8,stringToMonthCode(&quot;AUGUST&quot;));
210 // assertEquals(9,stringToMonthCode(&quot;SEPTEMBER&quot;));
211 // assertEquals(10,stringToMonthCode(&quot;OCTOBER&quot;));
212 // assertEquals(11,stringToMonthCode(&quot;NOVEMBER&quot;));
213 // assertEquals(12,stringToMonthCode(&quot;DECEMBER&quot;));
214 }
215
216 public void testIsValidWeekInMonthCode() throws Exception {
217 for (int w = 0; w &lt;= 4; w++) {
218 assertTrue(isValidWeekInMonthCode(w));
219 }
220 assertFalse(isValidWeekInMonthCode(5));
221 }
222
223 public void testIsLeapYear() throws Exception {
224 assertFalse(isLeapYear(1900));
225 assertFalse(isLeapYear(1901));
226 assertFalse(isLeapYear(1902));
227 assertFalse(isLeapYear(1903));
228 assertTrue(isLeapYear(1904));
229 assertTrue(isLeapYear(1908));
230 assertFalse(isLeapYear(1955));
231 assertTrue(isLeapYear(1964));
232 assertTrue(isLeapYear(1980));
233 assertTrue(isLeapYear(2000));
234 assertFalse(isLeapYear(2001));
235 assertFalse(isLeapYear(2100));
236 }
237
238 public void testLeapYearCount() throws Exception {
239 assertEquals(0, leapYearCount(1900));
240 assertEquals(0, leapYearCount(1901));
241 assertEquals(0, leapYearCount(1902));
242 assertEquals(0, leapYearCount(1903));
243 assertEquals(1, leapYearCount(1904));
244 assertEquals(1, leapYearCount(1905));
245 assertEquals(1, leapYearCount(1906));
246 assertEquals(1, leapYearCount(1907));
247 assertEquals(2, leapYearCount(1908));
248 assertEquals(24, leapYearCount(1999));
249 assertEquals(25, leapYearCount(2001));
250 assertEquals(49, leapYearCount(2101));
251 assertEquals(73, leapYearCount(2201));</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-4 (continued)
BobsSerialDateTest.java
</code></pre></div><p>378 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>252 assertEquals(97, leapYearCount(2301));
253 assertEquals(122, leapYearCount(2401));
254 }
255
256 public void testLastDayOfMonth() throws Exception {
257 assertEquals(31, lastDayOfMonth(JANUARY, 1901));
258 assertEquals(28, lastDayOfMonth(FEBRUARY, 1901));
259 assertEquals(31, lastDayOfMonth(MARCH, 1901));
260 assertEquals(30, lastDayOfMonth(APRIL, 1901));
261 assertEquals(31, lastDayOfMonth(MAY, 1901));
262 assertEquals(30, lastDayOfMonth(JUNE, 1901));
263 assertEquals(31, lastDayOfMonth(JULY, 1901));
264 assertEquals(31, lastDayOfMonth(AUGUST, 1901));
265 assertEquals(30, lastDayOfMonth(SEPTEMBER, 1901));
266 assertEquals(31, lastDayOfMonth(OCTOBER, 1901));
267 assertEquals(30, lastDayOfMonth(NOVEMBER, 1901));
268 assertEquals(31, lastDayOfMonth(DECEMBER, 1901));
269 assertEquals(29, lastDayOfMonth(FEBRUARY, 1904));
270 }
271
272 public void testAddDays() throws Exception {
273 SerialDate newYears = d(1, JANUARY, 1900);
274 assertEquals(d(2, JANUARY, 1900), addDays(1, newYears));
275 assertEquals(d(1, FEBRUARY, 1900), addDays(31, newYears));
276 assertEquals(d(1, JANUARY, 1901), addDays(365, newYears));
277 assertEquals(d(31, DECEMBER, 1904), addDays(5 * 365, newYears));
278 }
279
280 private static SpreadsheetDate d(int day, int month, int year) {return new
SpreadsheetDate(day, month, year);}
281
282 public void testAddMonths() throws Exception {
283 assertEquals(d(1, FEBRUARY, 1900), addMonths(1, d(1, JANUARY, 1900)));
284 assertEquals(d(28, FEBRUARY, 1900), addMonths(1, d(31, JANUARY, 1900)));
285 assertEquals(d(28, FEBRUARY, 1900), addMonths(1, d(30, JANUARY, 1900)));
286 assertEquals(d(28, FEBRUARY, 1900), addMonths(1, d(29, JANUARY, 1900)));
287 assertEquals(d(28, FEBRUARY, 1900), addMonths(1, d(28, JANUARY, 1900)));
288 assertEquals(d(27, FEBRUARY, 1900), addMonths(1, d(27, JANUARY, 1900)));
289
290 assertEquals(d(30, JUNE, 1900), addMonths(5, d(31, JANUARY, 1900)));
291 assertEquals(d(30, JUNE, 1901), addMonths(17, d(31, JANUARY, 1900)));
292
293 assertEquals(d(29, FEBRUARY, 1904), addMonths(49, d(31, JANUARY, 1900)));
294
295 }
296
297 public void testAddYears() throws Exception {
298 assertEquals(d(1, JANUARY, 1901), addYears(1, d(1, JANUARY, 1900)));
299 assertEquals(d(28, FEBRUARY, 1905), addYears(1, d(29, FEBRUARY, 1904)));
300 assertEquals(d(28, FEBRUARY, 1905), addYears(1, d(28, FEBRUARY, 1904)));
301 assertEquals(d(28, FEBRUARY, 1904), addYears(1, d(28, FEBRUARY, 1903)));
302 }
303
304 public void testGetPreviousDayOfWeek() throws Exception {
305 assertEquals(d(24, FEBRUARY, 2006), getPreviousDayOfWeek(FRIDAY, d(1, MARCH, 2006)));
306 assertEquals(d(22, FEBRUARY, 2006), getPreviousDayOfWeek(WEDNESDAY, d(1, MARCH, 2006)));
307 assertEquals(d(29, FEBRUARY, 2004), getPreviousDayOfWeek(SUNDAY, d(3, MARCH, 2004)));
308 assertEquals(d(29, DECEMBER, 2004), getPreviousDayOfWeek(WEDNESDAY, d(5, JANUARY, 2005)));
309
310 try {
311 getPreviousDayOfWeek(-1, d(1, JANUARY, 2006));
312 fail(&quot;Invalid day of week code should throw exception&quot;);</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-4 (continued)
BobsSerialDateTest.java
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 379</p> <p>313 } catch (IllegalArgumentException e) {
314 }
315 }
316
317 public void testGetFollowingDayOfWeek() throws Exception {
318 // assertEquals(d(1, JANUARY, 2005),getFollowingDayOfWeek(SATURDAY, d(25, DECEMBER, 2004)));
319 assertEquals(d(1, JANUARY, 2005), getFollowingDayOfWeek(SATURDAY, d(26, DECEMBER, 2004)));
320 assertEquals(d(3, MARCH, 2004), getFollowingDayOfWeek(WEDNESDAY, d(28, FEBRUARY, 2004)));
321
322 try {
323 getFollowingDayOfWeek(-1, d(1, JANUARY, 2006));
324 fail(&quot;Invalid day of week code should throw exception&quot;);
325 } catch (IllegalArgumentException e) {
326 }
327 }
328
329 public void testGetNearestDayOfWeek() throws Exception {
330 assertEquals(d(16, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(16, APRIL, 2006)));
331 assertEquals(d(16, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(17, APRIL, 2006)));
332 assertEquals(d(16, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(18, APRIL, 2006)));
333 assertEquals(d(16, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(19, APRIL, 2006)));
334 assertEquals(d(23, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(20, APRIL, 2006)));
335 assertEquals(d(23, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(21, APRIL, 2006)));
336 assertEquals(d(23, APRIL, 2006), getNearestDayOfWeek(SUNDAY, d(22, APRIL, 2006)));
337
338 //todo assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(16, APRIL, 2006)));
339 assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(17, APRIL, 2006)));
340 assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(18, APRIL, 2006)));
341 assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(19, APRIL, 2006)));
342 assertEquals(d(17, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(20, APRIL, 2006)));
343 assertEquals(d(24, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(21, APRIL, 2006)));
344 assertEquals(d(24, APRIL, 2006), getNearestDayOfWeek(MONDAY, d(22, APRIL, 2006)));
345
346 // assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(16, APRIL, 2006)));
347 // assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(17, APRIL, 2006)));
348 assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(18, APRIL, 2006)));
349 assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(19, APRIL, 2006)));
350 assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(20, APRIL, 2006)));
351 assertEquals(d(18, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(21, APRIL, 2006)));
352 assertEquals(d(25, APRIL, 2006), getNearestDayOfWeek(TUESDAY, d(22, APRIL, 2006)));
353
354 // assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(16, APRIL, 2006)));
355 // assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(17, APRIL, 2006)));
356 // assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(18, APRIL, 2006)));
357 assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(19, APRIL, 2006)));
358 assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(20, APRIL, 2006)));
359 assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(21, APRIL, 2006)));
360 assertEquals(d(19, APRIL, 2006), getNearestDayOfWeek(WEDNESDAY, d(22, APRIL, 2006)));
361
362 // assertEquals(d(13, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(16, APRIL, 2006)));
363 // assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(17, APRIL, 2006)));
364 // assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(18, APRIL, 2006)));
365 // assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(19, APRIL, 2006)));
366 assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(20, APRIL, 2006)));
367 assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(21, APRIL, 2006)));
368 assertEquals(d(20, APRIL, 2006), getNearestDayOfWeek(THURSDAY, d(22, APRIL, 2006)));
369
370 // assertEquals(d(14, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(16, APRIL, 2006)));
371 // assertEquals(d(14, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(17, APRIL, 2006)));
372 // assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(18, APRIL, 2006)));
373 // assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(19, APRIL, 2006)));
374 // assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(20, APRIL, 2006)));</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-4 (continued)
BobsSerialDateTest.java
</code></pre></div><p>380 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>375 assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(21, APRIL, 2006)));
376 assertEquals(d(21, APRIL, 2006), getNearestDayOfWeek(FRIDAY, d(22, APRIL, 2006)));
377
378 // assertEquals(d(15, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(16, APRIL, 2006)));
379 // assertEquals(d(15, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(17, APRIL, 2006)));
380 // assertEquals(d(15, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(18, APRIL, 2006)));
381 // assertEquals(d(22, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(19, APRIL, 2006)));
382 // assertEquals(d(22, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(20, APRIL, 2006)));
383 // assertEquals(d(22, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(21, APRIL, 2006)));
384 assertEquals(d(22, APRIL, 2006), getNearestDayOfWeek(SATURDAY, d(22, APRIL, 2006)));
385
386 try {
387 getNearestDayOfWeek(-1, d(1, JANUARY, 2006));
388 fail(&quot;Invalid day of week code should throw exception&quot;);
389 } catch (IllegalArgumentException e) {
390 }
391 }
392
393 public void testEndOfCurrentMonth() throws Exception {
394 SerialDate d = SerialDate.createInstance(2);
395 assertEquals(d(31, JANUARY, 2006), d.getEndOfCurrentMonth(d(1, JANUARY, 2006)));
396 assertEquals(d(28, FEBRUARY, 2006), d.getEndOfCurrentMonth(d(1, FEBRUARY, 2006)));
397 assertEquals(d(31, MARCH, 2006), d.getEndOfCurrentMonth(d(1, MARCH, 2006)));
398 assertEquals(d(30, APRIL, 2006), d.getEndOfCurrentMonth(d(1, APRIL, 2006)));
399 assertEquals(d(31, MAY, 2006), d.getEndOfCurrentMonth(d(1, MAY, 2006)));
400 assertEquals(d(30, JUNE, 2006), d.getEndOfCurrentMonth(d(1, JUNE, 2006)));
401 assertEquals(d(31, JULY, 2006), d.getEndOfCurrentMonth(d(1, JULY, 2006)));
402 assertEquals(d(31, AUGUST, 2006), d.getEndOfCurrentMonth(d(1, AUGUST, 2006)));
403 assertEquals(d(30, SEPTEMBER, 2006), d.getEndOfCurrentMonth(d(1, SEPTEMBER, 2006)));
404 assertEquals(d(31, OCTOBER, 2006), d.getEndOfCurrentMonth(d(1, OCTOBER, 2006)));
405 assertEquals(d(30, NOVEMBER, 2006), d.getEndOfCurrentMonth(d(1, NOVEMBER, 2006)));
406 assertEquals(d(31, DECEMBER, 2006), d.getEndOfCurrentMonth(d(1, DECEMBER, 2006)));
407 assertEquals(d(29, FEBRUARY, 2008), d.getEndOfCurrentMonth(d(1, FEBRUARY, 2008)));
408 }
409
410 public void testWeekInMonthToString() throws Exception {
411 assertEquals(&quot;First&quot;,weekInMonthToString(FIRST_WEEK_IN_MONTH));
412 assertEquals(&quot;Second&quot;,weekInMonthToString(SECOND_WEEK_IN_MONTH));
413 assertEquals(&quot;Third&quot;,weekInMonthToString(THIRD_WEEK_IN_MONTH));
414 assertEquals(&quot;Fourth&quot;,weekInMonthToString(FOURTH_WEEK_IN_MONTH));
415 assertEquals(&quot;Last&quot;,weekInMonthToString(LAST_WEEK_IN_MONTH));
416
417 //todo try {
418 // weekInMonthToString(-1);
419 // fail(&quot;Invalid week code should throw exception&quot;);
420 // } catch (IllegalArgumentException e) {
421 // }
422 }
423
424 public void testRelativeToString() throws Exception {
425 assertEquals(&quot;Preceding&quot;,relativeToString(PRECEDING));
426 assertEquals(&quot;Nearest&quot;,relativeToString(NEAREST));
427 assertEquals(&quot;Following&quot;,relativeToString(FOLLOWING));
428
429 //todo try {
430 // relativeToString(-1000);
431 // fail(&quot;Invalid relative code should throw exception&quot;);
432 // } catch (IllegalArgumentException e) {
433 // }
434 }
435</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-4 (continued)
BobsSerialDateTest.java
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 381</p> <p>436 public void testCreateInstanceFromDDMMYYY() throws Exception {
437 SerialDate date = createInstance(1, JANUARY, 1900);
438 assertEquals(1,date.getDayOfMonth());
439 assertEquals(JANUARY,date.getMonth());
440 assertEquals(1900,date.getYYYY());
441 assertEquals(2,date.toSerial());
442 }
443
444 public void testCreateInstanceFromSerial() throws Exception {
445 assertEquals(d(1, JANUARY, 1900),createInstance(2));
446 assertEquals(d(1, JANUARY, 1901), createInstance(367));
447 }
448
449 public void testCreateInstanceFromJavaDate() throws Exception {
450 assertEquals(d(1, JANUARY, 1900),
createInstance(new GregorianCalendar(1900,0,1).getTime()));
451 assertEquals(d(1, JANUARY, 2006),
createInstance(new GregorianCalendar(2006,0,1).getTime()));
452 }
453
454 public static void main(String[] args) {
455 junit.textui.TestRunner.run(BobsSerialDateTest.class);
456 }
457 }</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-4 (continued)
BobsSerialDateTest.java
</code></pre></div><p>382 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p><strong>Listing B-5
SpreadsheetDate.java</strong>
1 /* ========================================================================
2 * JCommon : a free general purpose class library for the Java(tm) platform
3 * ========================================================================
4 *
5 * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.
6 *
7 * Project Info: <a href="http://www.jfree.org/jcommon/index.html" target="_blank" rel="noopener noreferrer">http://www.jfree.org/jcommon/index.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
8 *
9 * This library is free software; you can redistribute it and/or modify it
10 * under the terms of the GNU Lesser General Public License as published by
11 * the Free Software Foundation; either version 2.1 of the License, or
12 * (at your option) any later version.
13 *
14 * This library is distributed in the hope that it will be useful, but
15 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
16 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
17 * License for more details.
18 *
19 * You should have received a copy of the GNU Lesser General Public
20 * License along with this library; if not, write to the Free Software
21 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
22 * USA.
23 *
24 * [Java is a trademark or registered trademark of Sun Microsystems, Inc.
25 * in the United States and other countries.]
26 *
27 * --------------------
28 * SpreadsheetDate.java
29 * --------------------
30 * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.
31 *
32 * Original Author: David Gilbert (for Object Refinery Limited);
33 * Contributor(s): -;
34 *
35 * $Id: SpreadsheetDate.java,v 1.8 2005/11/03 09:25:39 mungady Exp $
36 *
37 * Changes
38 * -------
39 * 11-Oct-2001 : Version 1 (DG);
40 * 05-Nov-2001 : Added getDescription() and setDescription() methods (DG);
41 * 12-Nov-2001 : Changed name from ExcelDate.java to SpreadsheetDate.java (DG);
42 * Fixed a bug in calculating day, month and year from serial
43 * number (DG);
44 * 24-Jan-2002 : Fixed a bug in calculating the serial number from the day,
45 * month and year. Thanks to Trevor Hills for the report (DG);
46 * 29-May-2002 : Added equals(Object) method (SourceForge ID 558850) (DG);
47 * 03-Oct-2002 : Fixed errors reported by Checkstyle (DG);
48 * 13-Mar-2003 : Implemented Serializable (DG);
49 * 04-Sep-2003 : Completed isInRange() methods (DG);
50 * 05-Sep-2003 : Implemented Comparable (DG);
51 * 21-Oct-2003 : Added hashCode() method (DG);
52 *
53 <em>/
54
55 package org.jfree.date;
56
57 import java.util.Calendar;
58 import java.util.Date;
59
60 /</em>*
61 * Represents a date using an integer, in a similar fashion to the
62 * implementation in Microsoft Excel. The range of dates supported is</p> <p><strong>Appendix B: org.jfree.date.SerialDate</strong> 383</p> <p>63 * 1-Jan-1900 to 31-Dec-9999.
64 * <P>
65 * Be aware that there is a deliberate bug in Excel that recognises the year
66 * 1900 as a leap year when in fact it is not a leap year. You can find more
67 * information on the Microsoft website in article Q181370:
68 * <P>
69 * <a href="http://support.microsoft.com/support/kb/articles/Q181/3/70.asp" target="_blank" rel="noopener noreferrer">http://support.microsoft.com/support/kb/articles/Q181/3/70.asp<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
70 * <P>
71 * Excel uses the convention that 1-Jan-1900 = 1. This class uses the
72 * convention 1-Jan-1900 = 2.
73 * The result is that the day number in this class will be different to the
74 * Excel figure for January and February 1900...but then Excel adds in an extra
75 * day (29-Feb-1900 which does not actually exist!) and from that point forward
76 * the day numbers will match.
77 *
78 * @author David Gilbert
79 <em>/
80 public class SpreadsheetDate extends SerialDate {
81
82 /</em>* For serialization. <em>/
83 private static final long serialVersionUID = -2039586705374454461L;
84
85 /</em>*
86 * The day number (1-Jan-1900 = 2, 2-Jan-1900 = 3, ..., 31-Dec-9999 =
87 * 2958465).
88 <em>/
89 private int serial;
90
91 /</em>* The day of the month (1 to 28, 29, 30 or 31 depending on the month). <em>/
92 private int day;
93
94 /</em>* The month of the year (1 to 12). <em>/
95 private int month;
96
97 /</em>* The year (1900 to 9999). <em>/
98 private int year;
99
100 /</em>* An optional description for the date. <em>/
101 private String description;
102
103 /</em>*
104 * Creates a new date instance.
105 *
106 * @param day the day (in the range 1 to 28/29/30/31).
107 * @param month the month (in the range 1 to 12).
108 * @param year the year (in the range 1900 to 9999).
109 */
110 public SpreadsheetDate(final int day, final int month, final int year) {
111
112 if ((year &gt;= 1900) &amp;&amp; (year &lt;= 9999)) {
113 this.year = year;
114 }
115 else {
116 throw new IllegalArgumentException(
117 &quot;The 'year' argument must be in range 1900 to 9999.&quot;
118 );
119 }
120
121 if ((month &gt;= MonthConstants.JANUARY)
122 &amp;&amp; (month &lt;= MonthConstants.DECEMBER)) {
123 this.month = month;
124 }</P> <div class="language- extra-class"><pre class="language-text"><code>Listing B-5 (continued)
SpreadsheetDate.java
</code></pre></div><p>384 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>125 else {
126 throw new IllegalArgumentException(
127 &quot;The 'month' argument must be in the range 1 to 12.&quot;
128 );
129 }
130
131 if ((day &gt;= 1) &amp;&amp; (day &lt;= SerialDate.lastDayOfMonth(month, year))) {
132 this.day = day;
133 }
134 else {
135 throw new IllegalArgumentException(&quot;Invalid 'day' argument.&quot;);
136 }
137
138 // the serial number needs to be synchronised with the day-month-year...
139 this.serial = calcSerial(day, month, year);
140
141 this.description = null;
142
143 }
144
145 /**
146 * Standard constructor - creates a new date object representing the
147 * specified day number (which should be in the range 2 to 2958465.
148 *
149 * @param serial the serial number for the day (range: 2 to 2958465).
150 <em>/
151 public SpreadsheetDate(final int serial) {
152
153 if ((serial &gt;= SERIAL_LOWER_BOUND) &amp;&amp; (serial &lt;= SERIAL_UPPER_BOUND)) {
154 this.serial = serial;
155 }
156 else {
157 throw new IllegalArgumentException(
158 &quot;SpreadsheetDate: Serial must be in range 2 to 2958465.&quot;);
159 }
160
161 // the day-month-year needs to be synchronised with the serial number...
162 calcDayMonthYear();
163
164 }
165
166 /</em>*
167 * Returns the description that is attached to the date. It is not
168 * required that a date have a description, but for some applications it
169 * is useful.
170 *
171 * @return The description that is attached to the date.
172 <em>/
173 public String getDescription() {
174 return this.description;
175 }
176
177 /</em>*
178 * Sets the description for the date.
179 *
180 * @param description the description for this date (<code>null</code>
181 * permitted).
182 */
183 public void setDescription(final String description) {
184 this.description = description;
185 }
186</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-5 (continued)
SpreadsheetDate.java
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 385</p> <p>187 /**
188 * Returns the serial number for the date, where 1 January 1900 = 2
189 * (this corresponds, almost, to the numbering system used in Microsoft
190 * Excel for Windows and Lotus 1-2-3).
191 *
192 * @return The serial number of this date.
193 <em>/
194 public int toSerial() {
195 return this.serial;
196 }
197
198 /</em>*
199 * Returns a <code>java.util.Date</code> equivalent to this date.
200 *
201 * @return The date.
202 <em>/
203 public Date toDate() {
204 final Calendar calendar = Calendar.getInstance();
205 calendar.set(getYYYY(), getMonth() - 1, getDayOfMonth(), 0, 0, 0);
206 return calendar.getTime();
207 }
208
209 /</em>*
210 * Returns the year (assume a valid range of 1900 to 9999).
211 *
212 * @return The year.
213 <em>/
214 public int getYYYY() {
215 return this.year;
216 }
217
218 /</em>*
219 * Returns the month (January = 1, February = 2, March = 3).
220 *
221 * @return The month of the year.
222 <em>/
223 public int getMonth() {
224 return this.month;
225 }
226
227 /</em>*
228 * Returns the day of the month.
229 *
230 * @return The day of the month.
231 <em>/
232 public int getDayOfMonth() {
233 return this.day;
234 }
235
236 /</em>*
237 * Returns a code representing the day of the week.
238 * <P>
239 * The codes are defined in the {@link SerialDate} class as:
240 * <code>SUNDAY</code>, <code>MONDAY</code>, <code>TUESDAY</code>,
241 * <code>WEDNESDAY</code>, <code>THURSDAY</code>, <code>FRIDAY</code>, and
242 * <code>SATURDAY</code>.
243 *
244 * @return A code representing the day of the week.
245 */
246 public int getDayOfWeek() {
247 return (this.serial + 6) % 7 + 1;
248 }</P></p><div class="language- extra-class"><pre class="language-text"><code>Listing B-5 (continued)
SpreadsheetDate.java
</code></pre></div><p>386 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>249
250 /**
251 * Tests the equality of this date with an arbitrary object.
252 * <P>
253 * This method will return true ONLY if the object is an instance of the
254 * {@link SerialDate} base class, and it represents the same day as this
255 * {@link SpreadsheetDate}.
256 *
257 * @param object the object to compare (<code>null</code> permitted).
258 *
259 * @return A boolean.
260 <em>/
261 public boolean equals(final Object object) {
262
263 if (object instanceof SerialDate) {
264 final SerialDate s = (SerialDate) object;
265 return (s.toSerial() == this.toSerial());
266 }
267 else {
268 return false;
269 }
270
271 }
272
273 /</em>*
274 * Returns a hash code for this object instance.
275 *
276 * @return A hash code.
277 <em>/
278 public int hashCode() {
279 return toSerial();
280 }
281
282 /</em>*
283 * Returns the difference (in days) between this date and the specified
284 * 'other' date.
285 *
286 * @param other the date being compared to.
287 *
288 * @return The difference (in days) between this date and the specified
289 * 'other' date.
290 <em>/
291 public int compare(final SerialDate other) {
292 return this.serial - other.toSerial();
293 }
294
295 /</em>*
296 * Implements the method required by the Comparable interface.
297 *
298 * @param other the other object (usually another SerialDate).
299 *
300 * @return A negative integer, zero, or a positive integer as this object
301 * is less than, equal to, or greater than the specified object.
302 <em>/
303 public int compareTo(final Object other) {
304 return compare((SerialDate) other);
305 }
306
307 /</em>*
308 * Returns true if this SerialDate represents the same date as the
309 * specified SerialDate.
310 *</P></p><div class="language- extra-class"><pre class="language-text"><code>Listing B-5 (continued)
SpreadsheetDate.java
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 387</p> <p>311 * @param other the date being compared to.
312 *
313 * @return <code>true</code> if this SerialDate represents the same date as
314 * the specified SerialDate.
315 <em>/
316 public boolean isOn(final SerialDate other) {
317 return (this.serial == other.toSerial());
318 }
319
320 /</em>*
321 * Returns true if this SerialDate represents an earlier date compared to
322 * the specified SerialDate.
323 *
324 * @param other the date being compared to.
325 *
326 * @return <code>true</code> if this SerialDate represents an earlier date
327 * compared to the specified SerialDate.
328 <em>/
329 public boolean isBefore(final SerialDate other) {
330 return (this.serial &lt; other.toSerial());
331 }
332
333 /</em>*
334 * Returns true if this SerialDate represents the same date as the
335 * specified SerialDate.
336 *
337 * @param other the date being compared to.
338 *
339 * @return <code>true</code> if this SerialDate represents the same date
340 * as the specified SerialDate.
341 <em>/
342 public boolean isOnOrBefore(final SerialDate other) {
343 return (this.serial &lt;= other.toSerial());
344 }
345
346 /</em>*
347 * Returns true if this SerialDate represents the same date as the
348 * specified SerialDate.
349 *
350 * @param other the date being compared to.
351 *
352 * @return <code>true</code> if this SerialDate represents the same date
353 * as the specified SerialDate.
354 <em>/
355 public boolean isAfter(final SerialDate other) {
356 return (this.serial &gt; other.toSerial());
357 }
358
359 /</em>*
360 * Returns true if this SerialDate represents the same date as the
361 * specified SerialDate.
362 *
363 * @param other the date being compared to.
364 *
365 * @return <code>true</code> if this SerialDate represents the same date as
366 * the specified SerialDate.
367 <em>/
368 public boolean isOnOrAfter(final SerialDate other) {
369 return (this.serial &gt;= other.toSerial());
370 }
371
372 /</em>*
373 * Returns <code>true</code> if this {@link SerialDate} is within the</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-5 (continued)
SpreadsheetDate.java
</code></pre></div><p>388 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>374 * specified range (INCLUSIVE). The date order of d1 and d2 is not
375 * important.
376 *
377 * @param d1 a boundary date for the range.
378 * @param d2 the other boundary date for the range.
379 *
380 * @return A boolean.
381 <em>/
382 public boolean isInRange(final SerialDate d1, final SerialDate d2) {
383 return isInRange(d1, d2, SerialDate.INCLUDE_BOTH);
384 }
385
386 /</em>*
387 * Returns true if this SerialDate is within the specified range (caller
388 * specifies whether or not the end-points are included). The order of d1
389 * and d2 is not important.
390 *
391 * @param d1 one boundary date for the range.
392 * @param d2 a second boundary date for the range.
393 * @param include a code that controls whether or not the start and end
394 * dates are included in the range.
395 *
396 * @return <code>true</code> if this SerialDate is within the specified
397 * range.
398 <em>/
399 public boolean isInRange(final SerialDate d1, final SerialDate d2,
400 final int include) {
401 final int s1 = d1.toSerial();
402 final int s2 = d2.toSerial();
403 final int start = Math.min(s1, s2);
404 final int end = Math.max(s1, s2);
405
406 final int s = toSerial();
407 if (include == SerialDate.INCLUDE_BOTH) {
408 return (s &gt;= start &amp;&amp; s &lt;= end);
409 }
410 else if (include == SerialDate.INCLUDE_FIRST) {
411 return (s &gt;= start &amp;&amp; s &lt; end);
412 }
413 else if (include == SerialDate.INCLUDE_SECOND) {
414 return (s &gt; start &amp;&amp; s &lt;= end);
415 }
416 else {
417 return (s &gt; start &amp;&amp; s &lt; end);
418 }
419 }
420
421 /</em>*
422 * Calculate the serial number from the day, month and year.
423 * <P>
424 * 1-Jan-1900 = 2.
425 *
426 * @param d the day.
427 * @param m the month.
428 * @param y the year.
429 *
430 * @return the serial number from the day, month and year.
431 */
432 private int calcSerial(final int d, final int m, final int y) {
433 final int yy = ((y - 1900) * 365) + SerialDate.leapYearCount(y - 1);
434 int mm = SerialDate.AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH[m];
435 if (m &gt; MonthConstants.FEBRUARY) {</P></p><div class="language- extra-class"><pre class="language-text"><code>Listing B-5 (continued)
SpreadsheetDate.java
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 389</p> <p>436 if (SerialDate.isLeapYear(y)) {
437 mm = mm + 1;
438 }
439 }
440 final int dd = d;
441 return yy + mm + dd + 1;
442 }
443
444 /**
445 * Calculate the day, month and year from the serial number.
446 */
447 private void calcDayMonthYear() {
448
449 // get the year from the serial date
450 final int days = this.serial - SERIAL_LOWER_BOUND;
451 // overestimated because we ignored leap days
452 final int overestimatedYYYY = 1900 + (days / 365);
453 final int leaps = SerialDate.leapYearCount(overestimatedYYYY);
454 final int nonleapdays = days - leaps;
455 // underestimated because we overestimated years
456 int underestimatedYYYY = 1900 + (nonleapdays / 365);
457
458 if (underestimatedYYYY == overestimatedYYYY) {
459 this.year = underestimatedYYYY;
460 }
461 else {
462 int ss1 = calcSerial(1, 1, underestimatedYYYY);
463 while (ss1 &lt;= this.serial) {
464 underestimatedYYYY = underestimatedYYYY + 1;
465 ss1 = calcSerial(1, 1, underestimatedYYYY);
466 }
467 this.year = underestimatedYYYY - 1;
468 }
469
470 final int ss2 = calcSerial(1, 1, this.year);
471
472 int[] daysToEndOfPrecedingMonth
473 = AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH;
474
475 if (isLeapYear(this.year)) {
476 daysToEndOfPrecedingMonth
477 = LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH;
478 }
479
480 // get the month from the serial date
481 int mm = 1;
482 int sss = ss2 + daysToEndOfPrecedingMonth[mm] - 1;
483 while (sss &lt; this.serial) {
484 mm = mm + 1;
485 sss = ss2 + daysToEndOfPrecedingMonth[mm] - 1;
486 }
487 this.month = mm - 1;
488
489 // what's left is d(+1);
490 this.day = this.serial - ss2
491 - daysToEndOfPrecedingMonth[this.month] + 1;
492
493 }
494
495 }</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-5 (continued)
SpreadsheetDate.java
</code></pre></div><p>390 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p><strong>Listing B-6
RelativeDayOfWeekRule.java</strong>
1 /* ========================================================================
2 * JCommon : a free general purpose class library for the Java(tm) platform
3 * ========================================================================
4 *
5 * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.
6 *
7 * Project Info: <a href="http://www.jfree.org/jcommon/index.html" target="_blank" rel="noopener noreferrer">http://www.jfree.org/jcommon/index.html<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
8 *
9 * This library is free software; you can redistribute it and/or modify it
10 * under the terms of the GNU Lesser General Public License as published by
11 * the Free Software Foundation; either version 2.1 of the License, or
12 * (at your option) any later version.
13 *
14 * This library is distributed in the hope that it will be useful, but
15 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
16 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public
17 * License for more details.
18 *
19 * You should have received a copy of the GNU Lesser General Public
20 * License along with this library; if not, write to the Free Software
21 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
22 * USA.
23 *
24 * [Java is a trademark or registered trademark of Sun Microsystems, Inc.
25 * in the United States and other countries.]
26 *
27 * --------------------------
28 * RelativeDayOfWeekRule.java
29 * --------------------------
30 * (C) Copyright 2000-2003, by Object Refinery Limited and Contributors.
31 *
32 * Original Author: David Gilbert (for Object Refinery Limited);
33 * Contributor(s): -;
34 *
35 * $Id: RelativeDayOfWeekRule.java,v 1.6 2005/11/16 15:58:40 taqua Exp $
36 *
37 * Changes (from 26-Oct-2001)
38 * --------------------------
39 * 26-Oct-2001 : Changed package to com.jrefinery.date.*;
40 * 03-Oct-2002 : Fixed errors reported by Checkstyle (DG);
41 *
42 <em>/
43
44 package org.jfree.date;
45
46 /</em>*
47 * An annual date rule that returns a date for each year based on (a) a
48 * reference rule; (b) a day of the week; and (c) a selection parameter
49 * (SerialDate.PRECEDING, SerialDate.NEAREST, SerialDate.FOLLOWING).
50 * <P>
51 * For example, Good Friday can be specified as 'the Friday PRECEDING Easter
52 * Sunday'.
53 *
54 * @author David Gilbert
55 <em>/
56 public class RelativeDayOfWeekRule extends AnnualDateRule {
57
58 /</em>* A reference to the annual date rule on which this rule is based. <em>/
59 private AnnualDateRule subrule;
60
61 /</em>*
62 * The day of the week (SerialDate.MONDAY, SerialDate.TUESDAY, and so on).</P></p><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 391</p> <p>63 <em>/
64 private int dayOfWeek;
65
66 /</em>* Specifies which day of the week (PRECEDING, NEAREST or FOLLOWING). <em>/
67 private int relative;
68
69 /</em>*
70 * Default constructor - builds a rule for the Monday following 1 January.
71 <em>/
72 public RelativeDayOfWeekRule() {
73 this(new DayAndMonthRule(), SerialDate.MONDAY, SerialDate.FOLLOWING);
74 }
75
76 /</em>*
77 * Standard constructor - builds rule based on the supplied sub-rule.
78 *
79 * @param subrule the rule that determines the reference date.
80 * @param dayOfWeek the day-of-the-week relative to the reference date.
81 * @param relative indicates <em>which</em> day-of-the-week (preceding, nearest
82 * or following).
83 <em>/
84 public RelativeDayOfWeekRule(final AnnualDateRule subrule,
85 final int dayOfWeek, final int relative) {
86 this.subrule = subrule;
87 this.dayOfWeek = dayOfWeek;
88 this.relative = relative;
89 }
90
91 /</em>*
92 * Returns the sub-rule (also called the reference rule).
93 *
94 * @return The annual date rule that determines the reference date for this
95 * rule.
96 <em>/
97 public AnnualDateRule getSubrule() {
98 return this.subrule;
99 }
100
101 /</em>*
102 * Sets the sub-rule.
103 *
104 * @param subrule the annual date rule that determines the reference date
105 * for this rule.
106 <em>/
107 public void setSubrule(final AnnualDateRule subrule) {
108 this.subrule = subrule;
109 }
110
111 /</em>*
112 * Returns the day-of-the-week for this rule.
113 *
114 * @return the day-of-the-week for this rule.
115 <em>/
116 public int getDayOfWeek() {
117 return this.dayOfWeek;
118 }
119
120 /</em>*
121 * Sets the day-of-the-week for this rule.
122 *
123 * @param dayOfWeek the day-of-the-week (SerialDate.MONDAY,
124 * SerialDate.TUESDAY, and so on).</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-6 (continued)
RelativeDayOfWeekRule.java
</code></pre></div><p>392 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>125 <em>/
126 public void setDayOfWeek(final int dayOfWeek) {
127 this.dayOfWeek = dayOfWeek;
128 }
129
130 /</em>*
131 * Returns the 'relative' attribute, that determines <em>which</em>
132 * day-of-the-week we are interested in (SerialDate.PRECEDING,
133 * SerialDate.NEAREST or SerialDate.FOLLOWING).
134 *
135 * @return The 'relative' attribute.
136 <em>/
137 public int getRelative() {
138 return this.relative;
139 }
140
141 /</em>*
142 * Sets the 'relative' attribute (SerialDate.PRECEDING, SerialDate.NEAREST,
143 * SerialDate.FOLLOWING).
144 *
145 * @param relative determines <em>which</em> day-of-the-week is selected by this
146 * rule.
147 <em>/
148 public void setRelative(final int relative) {
149 this.relative = relative;
150 }
151
152 /</em>*
153 * Creates a clone of this rule.
154 *
155 * @return a clone of this rule.
156 *
157 * @throws CloneNotSupportedException this should never happen.
158 <em>/
159 public Object clone() throws CloneNotSupportedException {
160 final RelativeDayOfWeekRule duplicate
161 = (RelativeDayOfWeekRule) super.clone();
162 duplicate.subrule = (AnnualDateRule) duplicate.getSubrule().clone();
163 return duplicate;
164 }
165
166 /</em>*
167 * Returns the date generated by this rule, for the specified year.
168 *
169 * @param year the year (1900 &lt;= year &lt;= 9999).
170 *
171 * @return The date generated by the rule for the given year (possibly
172 * <code>null</code>).
173 */
174 public SerialDate getDate(final int year) {
175
176 // check argument...
177 if ((year &lt; SerialDate.MINIMUM_YEAR_SUPPORTED)
178 || (year &gt; SerialDate.MAXIMUM_YEAR_SUPPORTED)) {
179 throw new IllegalArgumentException(
180 &quot;RelativeDayOfWeekRule.getDate(): year outside valid range.&quot;);
181 }
182
183 // calculate the date...
184 SerialDate result = null;
185 final SerialDate base = this.subrule.getDate(year);
186</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-6 (continued)
RelativeDayOfWeekRule.java
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 393</p> <p>187 if (base != null) {
188 switch (this.relative) {
189 case(SerialDate.PRECEDING):
190 result = SerialDate.getPreviousDayOfWeek(this.dayOfWeek,
191 base);
192 break;
193 case(SerialDate.NEAREST):
194 result = SerialDate.getNearestDayOfWeek(this.dayOfWeek,
195 base);
196 break;
197 case(SerialDate.FOLLOWING):
198 result = SerialDate.getFollowingDayOfWeek(this.dayOfWeek,
199 base);
200 break;
201 default:
202 break;
203 }
204 }
205 return result;
206
207 }
208
209 }</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-6 (continued)
RelativeDayOfWeekRule.java
</code></pre></div><p>394 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p><strong>Listing B-7
DayDate.java (Final)</strong>
1 /* ========================================================================
2 * JCommon : a free general purpose class library for the Java(tm) platform
3 * ========================================================================
4 *
5 * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.
...
36 <em>/
37 package org.jfree.date;
38
39 import java.io.Serializable;
40 import java.util.</em>;
41
42 /**
43 * An abstract class that represents immutable dates with a precision of
44 * one day. The implementation will map each date to an integer that
45 * represents an ordinal number of days from some fixed origin.
46 *
47 * Why not just use java.util.Date? We will, when it makes sense. At times,
48 * java.util.Date can be <em>too</em> precise - it represents an instant in time,
49 * accurate to 1/1000th of a second (with the date itself depending on the
50 * time-zone). Sometimes we just want to represent a particular day (e.g. 21
51 * January 2015) without concerning ourselves about the time of day, or the
52 * time-zone, or anything else. That's what we've defined DayDate for.
53 *
54 * Use DayDateFactory.makeDate to create an instance.
55 *
56 * @author David Gilbert
57 * @author Robert C. Martin did a lot of refactoring.
58 */
59
60 public abstract class DayDate implements Comparable, Serializable {
61 public abstract int getOrdinalDay();
62 public abstract int getYear();
63 public abstract Month getMonth();
64 public abstract int getDayOfMonth();
65
66 protected abstract Day getDayOfWeekForOrdinalZero();
67
68 public DayDate plusDays(int days) {
69 return DayDateFactory.makeDate(getOrdinalDay() + days);
70 }
71
72 public DayDate plusMonths(int months) {
73 int thisMonthAsOrdinal = getMonth().toInt() - Month.JANUARY.toInt();
74 int thisMonthAndYearAsOrdinal = 12 * getYear() + thisMonthAsOrdinal;
75 int resultMonthAndYearAsOrdinal = thisMonthAndYearAsOrdinal + months;
76 int resultYear = resultMonthAndYearAsOrdinal / 12;
77 int resultMonthAsOrdinal = resultMonthAndYearAsOrdinal % 12 + Month.JANUARY.toInt();
78 Month resultMonth = Month.fromInt(resultMonthAsOrdinal);
79 int resultDay = correctLastDayOfMonth(getDayOfMonth(), resultMonth, resultYear);
80 return DayDateFactory.makeDate(resultDay, resultMonth, resultYear);
81 }
82
83 public DayDate plusYears(int years) {
84 int resultYear = getYear() + years;
85 int resultDay = correctLastDayOfMonth(getDayOfMonth(), getMonth(), resultYear);
86 return DayDateFactory.makeDate(resultDay, getMonth(), resultYear);
87 }
88
89 private int correctLastDayOfMonth(int day, Month month, int year) {
90 int lastDayOfMonth = DateUtil.lastDayOfMonth(month, year);
91 if (day &gt; lastDayOfMonth)</p> <p><strong>Appendix B: org.jfree.date.SerialDate</strong> 395</p> <p>92 day = lastDayOfMonth;
93 return day;
94 }
95
96 public DayDate getPreviousDayOfWeek(Day targetDayOfWeek) {
97 int offsetToTarget = targetDayOfWeek.toInt() - getDayOfWeek().toInt();
98 if (offsetToTarget &gt;= 0)
99 offsetToTarget -= 7;
100 return plusDays(offsetToTarget);
101 }
102
103 public DayDate getFollowingDayOfWeek(Day targetDayOfWeek) {
104 int offsetToTarget = targetDayOfWeek.toInt() - getDayOfWeek().toInt();
105 if (offsetToTarget &lt;= 0)
106 offsetToTarget += 7;
107 return plusDays(offsetToTarget);
108 }
109
110 public DayDate getNearestDayOfWeek(Day targetDayOfWeek) {
111 int offsetToThisWeeksTarget = targetDayOfWeek.toInt() - getDayOfWeek().toInt();
112 int offsetToFutureTarget = (offsetToThisWeeksTarget + 7) % 7;
113 int offsetToPreviousTarget = offsetToFutureTarget - 7;
114
115 if (offsetToFutureTarget &gt; 3)
116 return plusDays(offsetToPreviousTarget);
117 else
118 return plusDays(offsetToFutureTarget);
119 }
120
121 public DayDate getEndOfMonth() {
122 Month month = getMonth();
123 int year = getYear();
124 int lastDay = DateUtil.lastDayOfMonth(month, year);
125 return DayDateFactory.makeDate(lastDay, month, year);
126 }
127
128 public Date toDate() {
129 final Calendar calendar = Calendar.getInstance();
130 int ordinalMonth = getMonth().toInt() - Month.JANUARY.toInt();
131 calendar.set(getYear(), ordinalMonth, getDayOfMonth(), 0, 0, 0);
132 return calendar.getTime();
133 }
134
135 public String toString() {
136 return String.format(&quot;%02d-%s-%d&quot;, getDayOfMonth(), getMonth(), getYear());
137 }
138
139 public Day getDayOfWeek() {
140 Day startingDay = getDayOfWeekForOrdinalZero();
141 int startingOffset = startingDay.toInt() - Day.SUNDAY.toInt();
142 int ordinalOfDayOfWeek = (getOrdinalDay() + startingOffset) % 7;
143 return Day.fromInt(ordinalOfDayOfWeek + Day.SUNDAY.toInt());
144 }
145
146 public int daysSince(DayDate date) {
147 return getOrdinalDay() - date.getOrdinalDay();
148 }
149
150 public boolean isOn(DayDate other) {
151 return getOrdinalDay() == other.getOrdinalDay();
152 }
153</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-7 (continued)
DayDate.java (Final)
</code></pre></div><p>396 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>154 public boolean isBefore(DayDate other) {
155 return getOrdinalDay() &lt; other.getOrdinalDay();
156 }
157
158 public boolean isOnOrBefore(DayDate other) {
159 return getOrdinalDay() &lt;= other.getOrdinalDay();
160 }
161
162 public boolean isAfter(DayDate other) {
163 return getOrdinalDay() &gt; other.getOrdinalDay();
164 }
165
166 public boolean isOnOrAfter(DayDate other) {
167 return getOrdinalDay() &gt;= other.getOrdinalDay();
168 }
169
170 public boolean isInRange(DayDate d1, DayDate d2) {
171 return isInRange(d1, d2, DateInterval.CLOSED);
172 }
173
174 public boolean isInRange(DayDate d1, DayDate d2, DateInterval interval) {
175 int left = Math.min(d1.getOrdinalDay(), d2.getOrdinalDay());
176 int right = Math.max(d1.getOrdinalDay(), d2.getOrdinalDay());
177 return interval.isIn(getOrdinalDay(), left, right);
178 }
179 }</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-7 (continued)
DayDate.java (Final)
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 397</p> <p><strong>Listing B- 8
Month.java (Final)</strong>
1 package org.jfree.date;
2
3 import java.text.DateFormatSymbols;
4
5 public enum Month {
6 JANUARY(1), FEBRUARY(2), MARCH(3),
7 APRIL(4), MAY(5), JUNE(6),
8 JULY(7), AUGUST(8), SEPTEMBER(9),
9 OCTOBER(10),NOVEMBER(11),DECEMBER(12);
10 private static DateFormatSymbols dateFormatSymbols = new DateFormatSymbols();
11 private static final int[] LAST_DAY_OF_MONTH =
12 {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
13
14 private int index;
15
16 Month(int index) {
17 this.index = index;
18 }
19
20 public static Month fromInt(int monthIndex) {
21 for (Month m : Month.values()) {
22 if (m.index == monthIndex)
23 return m;
24 }
25 throw new IllegalArgumentException(&quot;Invalid month index &quot; + monthIndex);
26 }
27
28 public int lastDay() {
29 return LAST_DAY_OF_MONTH[index];
30 }
31
32 public int quarter() {
33 return 1 + (index - 1) / 3;
34 }
35
36 public String toString() {
37 return dateFormatSymbols.getMonths()[index - 1];
38 }
39
40 public String toShortString() {
41 return dateFormatSymbols.getShortMonths()[index - 1];
42 }
43
44 public static Month parse(String s) {
45 s = s.trim();
46 for (Month m : Month.values())
47 if (m.matches(s))
48 return m;
49
50 try {
51 return fromInt(Integer.parseInt(s));
52 }
53 catch (NumberFormatException e) {}
54 throw new IllegalArgumentException(&quot;Invalid month &quot; + s);
55 }
56
57 private boolean matches(String s) {
58 return s.equalsIgnoreCase(toString()) ||
59 s.equalsIgnoreCase(toShortString());
60 }
61
62 public int toInt() {
63 return index;
64 }
65 }</p> <p>398 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p><strong>Listing B-9
Day.java (Final)</strong>
1 package org.jfree.date;
2
3 import java.util.Calendar;
4 import java.text.DateFormatSymbols;
5
6 public enum Day {
7 MONDAY(Calendar.MONDAY),
8 TUESDAY(Calendar.TUESDAY),
9 WEDNESDAY(Calendar.WEDNESDAY),
10 THURSDAY(Calendar.THURSDAY),
11 FRIDAY(Calendar.FRIDAY),
12 SATURDAY(Calendar.SATURDAY),
13 SUNDAY(Calendar.SUNDAY);
14
15 private final int index;
16 private static DateFormatSymbols dateSymbols = new DateFormatSymbols();
17
18 Day(int day) {
19 index = day;
20 }
21
22 public static Day fromInt(int index) throws IllegalArgumentException {
23 for (Day d : Day.values())
24 if (d.index == index)
25 return d;
26 throw new IllegalArgumentException(
27 String.format(&quot;Illegal day index: %d.&quot;, index));
28 }
29
30 public static Day parse(String s) throws IllegalArgumentException {
31 String[] shortWeekdayNames =
32 dateSymbols.getShortWeekdays();
33 String[] weekDayNames =
34 dateSymbols.getWeekdays();
35
36 s = s.trim();
37 for (Day day : Day.values()) {
38 if (s.equalsIgnoreCase(shortWeekdayNames[day.index]) ||
39 s.equalsIgnoreCase(weekDayNames[day.index])) {
40 return day;
41 }
42 }
43 throw new IllegalArgumentException(
44 String.format(&quot;%s is not a valid weekday string&quot;, s));
45 }
46
47 public String toString() {
48 return dateSymbols.getWeekdays()[index];
49 }
50
51 public int toInt() {
52 return index;
53 }
54 }</p> <p><strong>Appendix B: org.jfree.date.SerialDate</strong> 399</p> <p><strong>Listing B-10
DateInterval.java (Final)</strong>
1 package org.jfree.date;
2
3 public enum DateInterval {
4 OPEN {
5 public boolean isIn(int d, int left, int right) {
6 return d &gt; left &amp;&amp; d &lt; right;
7 }
8 },
9 CLOSED_LEFT {
10 public boolean isIn(int d, int left, int right) {
11 return d &gt;= left &amp;&amp; d &lt; right;
12 }
13 },
14 CLOSED_RIGHT {
15 public boolean isIn(int d, int left, int right) {
16 return d &gt; left &amp;&amp; d &lt;= right;
17 }
18 },
19 CLOSED {
20 public boolean isIn(int d, int left, int right) {
21 return d &gt;= left &amp;&amp; d &lt;= right;
22 }
23 };
24
25 public abstract boolean isIn(int d, int left, int right);
26 }</p> <p>400 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p><strong>Listing B-11
WeekInMonth.java (Final)</strong>
1 package org.jfree.date;
2
3 public enum WeekInMonth {
4 FIRST(1), SECOND(2), THIRD(3), FOURTH(4), LAST(0);
5 private final int index;
6
7 WeekInMonth(int index) {
8 this.index = index;
9 }
10
11 public int toInt() {
12 return index;
13 }
14 }</p> <p><strong>Appendix B: org.jfree.date.SerialDate</strong> 401</p> <p><strong>Listing B-12
WeekdayRange.java (Final)</strong>
1 package org.jfree.date;
2
3 public enum WeekdayRange {
4 LAST, NEAREST, NEXT
5 }</p> <p>402 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p><strong>Listing B-13
DateUtil.java (Final)</strong>
1 package org.jfree.date;
2
3 import java.text.DateFormatSymbols;
4
5 public class DateUtil {
6 private static DateFormatSymbols dateFormatSymbols = new DateFormatSymbols();
7
8 public static String[] getMonthNames() {
9 return dateFormatSymbols.getMonths();
10 }
11
12 public static boolean isLeapYear(int year) {
13 boolean fourth = year % 4 == 0;
14 boolean hundredth = year % 100 == 0;
15 boolean fourHundredth = year % 400 == 0;
16 return fourth &amp;&amp; (!hundredth || fourHundredth);
17 }
18
19 public static int lastDayOfMonth(Month month, int year) {
20 if (month == Month.FEBRUARY &amp;&amp; isLeapYear(year))
21 return month.lastDay() + 1;
22 else
23 return month.lastDay();
24 }
25
26 public static int leapYearCount(int year) {
27 int leap4 = (year - 1896) / 4;
28 int leap100 = (year - 1800) / 100;
29 int leap400 = (year - 1600) / 400;
30 return leap4 - leap100 + leap400;
31 }
32 }</p> <p><strong>Appendix B: org.jfree.date.SerialDate</strong> 403</p> <p><strong>Listing B-14
DayDateFactory.java (Final)</strong>
1 package org.jfree.date;
2
3 public abstract class DayDateFactory {
4 private static DayDateFactory factory = new SpreadsheetDateFactory();
5 public static void setInstance(DayDateFactory factory) {
6 DayDateFactory.factory = factory;
7 }
8
9 protected abstract DayDate _makeDate(int ordinal);
10 protected abstract DayDate _makeDate(int day, Month month, int year);
11 protected abstract DayDate _makeDate(int day, int month, int year);
12 protected abstract DayDate _makeDate(java.util.Date date);
13 protected abstract int _getMinimumYear();
14 protected abstract int _getMaximumYear();
15
16 public static DayDate makeDate(int ordinal) {
17 return factory._makeDate(ordinal);
18 }
19
20 public static DayDate makeDate(int day, Month month, int year) {
21 return factory._makeDate(day, month, year);
22 }
23
24 public static DayDate makeDate(int day, int month, int year) {
25 return factory._makeDate(day, month, year);
26 }
27
28 public static DayDate makeDate(java.util.Date date) {
29 return factory._makeDate(date);
30 }
31
32 public static int getMinimumYear() {
33 return factory._getMinimumYear();
34 }
35
36 public static int getMaximumYear() {
37 return factory._getMaximumYear();
38 }
39 }</p> <p>404 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p><strong>Listing B-15
SpreadsheetDateFactory.java (Final)</strong>
1 package org.jfree.date;
2
3 import java.util.*;
4
5 public class SpreadsheetDateFactory extends DayDateFactory {
6 public DayDate _makeDate(int ordinal) {
7 return new SpreadsheetDate(ordinal);
8 }
9
10 public DayDate _makeDate(int day, Month month, int year) {
11 return new SpreadsheetDate(day, month, year);
12 }
13
14 public DayDate _makeDate(int day, int month, int year) {
15 return new SpreadsheetDate(day, month, year);
16 }
17
18 public DayDate _makeDate(Date date) {
19 final GregorianCalendar calendar = new GregorianCalendar();
20 calendar.setTime(date);
21 return new SpreadsheetDate(
22 calendar.get(Calendar.DATE),
23 Month.fromInt(calendar.get(Calendar.MONTH) + 1),
24 calendar.get(Calendar.YEAR));
25 }
26
27 protected int _getMinimumYear() {
28 return SpreadsheetDate.MINIMUM_YEAR_SUPPORTED;
29 }
30
31 protected int _getMaximumYear() {
32 return SpreadsheetDate.MAXIMUM_YEAR_SUPPORTED;
33 }
34 }</p> <p><strong>Appendix B: org.jfree.date.SerialDate</strong> 405</p> <p><strong>Listing B-16
SpreadsheetDate.java (Final)</strong>
1 /* ========================================================================
2 * JCommon : a free general purpose class library for the Java(tm) platform
3 * ========================================================================
4 *
5 * (C) Copyright 2000-2005, by Object Refinery Limited and Contributors.
6 *
...
52 *
53 <em>/
54
55 package org.jfree.date;
56
57 import static org.jfree.date.Month.FEBRUARY;
58
59 import java.util.</em>;
60
61 /**
62 * Represents a date using an integer, in a similar fashion to the
63 * implementation in Microsoft Excel. The range of dates supported is
64 * 1-Jan-1900 to 31-Dec-9999.
65 * </p><p></p>
66 * Be aware that there is a deliberate bug in Excel that recognises the year
67 * 1900 as a leap year when in fact it is not a leap year. You can find more
68 * information on the Microsoft website in article Q181370:
69 * <p></p>
70 * <a href="http://support.microsoft.com/support/kb/articles/Q181/3/70.asp" target="_blank" rel="noopener noreferrer">http://support.microsoft.com/support/kb/articles/Q181/3/70.asp<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>
71 * <p></p>
72 * Excel uses the convention that 1-Jan-1900 = 1. This class uses the
73 * convention 1-Jan-1900 = 2.
74 * The result is that the day number in this class will be different to the
75 * Excel figure for January and February 1900...but then Excel adds in an extra
76 * day (29-Feb-1900 which does not actually exist!) and from that point forward
77 * the day numbers will match.
78 *
79 * @author David Gilbert
80 */
81 public class SpreadsheetDate extends DayDate {
82 public static final int EARLIEST_DATE_ORDINAL = 2; // 1/1/1900
83 public static final int LATEST_DATE_ORDINAL = 2958465; // 12/31/9999
84 public static final int MINIMUM_YEAR_SUPPORTED = 1900;
85 public static final int MAXIMUM_YEAR_SUPPORTED = 9999;
86 static final int[] AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH =
87 {0, 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365};
88 static final int[] LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH =
89 {0, 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366};
90
91 private int ordinalDay;
92 private int day;
93 private Month month;
94 private int year;
95
96 public SpreadsheetDate(int day, Month month, int year) {
97 if (year &lt; MINIMUM_YEAR_SUPPORTED || year &gt; MAXIMUM_YEAR_SUPPORTED)
98 throw new IllegalArgumentException(
99 &quot;The 'year' argument must be in range &quot; +
100 MINIMUM_YEAR_SUPPORTED + &quot; to &quot; + MAXIMUM_YEAR_SUPPORTED + &quot;.&quot;);
101 if (day &lt; 1 || day &gt; DateUtil.lastDayOfMonth(month, year))
102 throw new IllegalArgumentException(&quot;Invalid 'day' argument.&quot;);
103
104 this.year = year;
105 this.month = month;</P> <p>406 <strong>Appendix B: org.jfree.date.SerialDate</strong></p> <p>106 this.day = day;
107 ordinalDay = calcOrdinal(day, month, year);
108 }
109
110 public SpreadsheetDate(int day, int month, int year) {
111 this(day, Month.fromInt(month), year);
112 }
113
114 public SpreadsheetDate(int serial) {
115 if (serial &lt; EARLIEST_DATE_ORDINAL || serial &gt; LATEST_DATE_ORDINAL)
116 throw new IllegalArgumentException(
117 &quot;SpreadsheetDate: Serial must be in range 2 to 2958465.&quot;);
118
119 ordinalDay = serial;
120 calcDayMonthYear();
121 }
122
123 public int getOrdinalDay() {
124 return ordinalDay;
125 }
126
127 public int getYear() {
128 return year;
129 }
130
131 public Month getMonth() {
132 return month;
133 }
134
135 public int getDayOfMonth() {
136 return day;
137 }
138
139 protected Day getDayOfWeekForOrdinalZero() {return Day.SATURDAY;}
140
141 public boolean equals(Object object) {
142 if (!(object instanceof DayDate))
143 return false;
144
145 DayDate date = (DayDate) object;
146 return date.getOrdinalDay() == getOrdinalDay();
147 }
148
149 public int hashCode() {
150 return getOrdinalDay();
151 }
152
153 public int compareTo(Object other) {
154 return daysSince((DayDate) other);
155 }
156
157 private int calcOrdinal(int day, Month month, int year) {
158 int leapDaysForYear = DateUtil.leapYearCount(year - 1);
159 int daysUpToYear = (year - MINIMUM_YEAR_SUPPORTED) * 365 + leapDaysForYear;
160 int daysUpToMonth = AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH[month.toInt()];
161 if (DateUtil.isLeapYear(year) &amp;&amp; month.toInt() &gt; FEBRUARY.toInt())
162 daysUpToMonth++;
163 int daysInMonth = day - 1;
164 return daysUpToYear + daysUpToMonth + daysInMonth + EARLIEST_DATE_ORDINAL;
165 }
166</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-16 (continued)
SpreadsheetDate.java (Final)
</code></pre></div><p><strong>Appendix B: org.jfree.date.SerialDate</strong> 407</p> <p>167 private void calcDayMonthYear() {
168 int days = ordinalDay - EARLIEST_DATE_ORDINAL;
169 int overestimatedYear = MINIMUM_YEAR_SUPPORTED + days / 365;
170 int nonleapdays = days - DateUtil.leapYearCount(overestimatedYear);
171 int underestimatedYear = MINIMUM_YEAR_SUPPORTED + nonleapdays / 365;
172
173 year = huntForYearContaining(ordinalDay, underestimatedYear);
174 int firstOrdinalOfYear = firstOrdinalOfYear(year);
175 month = huntForMonthContaining(ordinalDay, firstOrdinalOfYear);
176 day = ordinalDay - firstOrdinalOfYear - daysBeforeThisMonth(month.toInt());
177 }
178
179 private Month huntForMonthContaining(int anOrdinal, int firstOrdinalOfYear) {
180 int daysIntoThisYear = anOrdinal - firstOrdinalOfYear;
181 int aMonth = 1;
182 while (daysBeforeThisMonth(aMonth) &lt; daysIntoThisYear)
183 aMonth++;
184
185 return Month.fromInt(aMonth - 1);
186 }
187
188 private int daysBeforeThisMonth(int aMonth) {
189 if (DateUtil.isLeapYear(year))
190 return LEAP_YEAR_AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH[aMonth] - 1;
191 else
192 return AGGREGATE_DAYS_TO_END_OF_PRECEDING_MONTH[aMonth] - 1;
193 }
194
195 private int huntForYearContaining(int anOrdinalDay, int startingYear) {
196 int aYear = startingYear;
197 while (firstOrdinalOfYear(aYear) &lt;= anOrdinalDay)
198 aYear++;
199
200 return aYear - 1;
201 }
202
203 private int firstOrdinalOfYear(int year) {
204 return calcOrdinal(1, Month.JANUARY, year);
205 }
206
207 public static DayDate createInstance(Date date) {
208 GregorianCalendar calendar = new GregorianCalendar();
209 calendar.setTime(date);
210 return new SpreadsheetDate(calendar.get(Calendar.DATE),
211 Month.fromInt(calendar.get(Calendar.MONTH) + 1),
212 calendar.get(Calendar.YEAR));
213
214 }
215 }</p> <div class="language- extra-class"><pre class="language-text"><code>Listing B-16 (continued)
SpreadsheetDate.java (Final)
</code></pre></div></P></p></P></p></P></p></P></P></p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"><!----><!----><!----></div></div>
    <script src="/docs/assets/js/app.c1419c2e.js" defer></script><script src="/docs/assets/js/2.0631070b.js" defer></script><script src="/docs/assets/js/247.14de355b.js" defer></script><script src="/docs/assets/js/29.9e31a33a.js" defer></script>
  </body>
</html>
