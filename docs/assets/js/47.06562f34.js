(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{1317:function(e,t,a){"use strict";a.r(t);var s=a(7),o=Object(s.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"lambda-architecture"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lambda-architecture"}},[e._v("#")]),e._v(" Lambda Architecture")]),e._v(" "),s("h2",{attrs:{id:"asynchronous-processing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#asynchronous-processing"}},[e._v("#")]),e._v(" Asynchronous Processing")]),e._v(" "),s("blockquote",{staticClass:"highlight-quote"},[s("p",[e._v("Asynchronous processing is when a client executes something and doesn’t wait for that task to complete before moving onto something else.")])]),s("p",[e._v("The purpose of asynchronous processing is to offload the task at hand to a background processing such that the caller does not have to wait for the response of the task result. This leads to lower latency because the request processing doesn’t block the client.")]),e._v(" "),s("h3",{attrs:{id:"reasons-for-asynchronous-processing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reasons-for-asynchronous-processing"}},[e._v("#")]),e._v(" Reasons for Asynchronous Processing")]),e._v(" "),s("p",[e._v("The main idea for asynchronous processing is you don’t want the end-user to wait for your task to complete because waiting for the job to complete\nwould be a bad user experience. So, in an interview, you should justify why asynchronous processing would improve the end-user experience. Here are\nsome examples that might be a good candidate for asynchronous processing:")]),e._v(" "),s("ul",[s("li",[e._v("The Processing Time is Indeterministic")]),e._v(" "),s("li",[e._v("The Processing Time is Long-Running")]),e._v(" "),s("li",[e._v("Improve Perceived Latency")])]),e._v(" "),s("h2",{attrs:{id:"batch-processing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#batch-processing"}},[e._v("#")]),e._v(" Batch processing")]),e._v(" "),s("p",[e._v("Batch processing is a form of asynchronous processing. In batch processing, the system processes a large amount of data periodically to\ngenerate output to let clients consume later. Here are some use cases for batch processing:")]),e._v(" "),s("ul",[s("li",[e._v("Run payroll, billing, and accounting for the company")]),e._v(" "),s("li",[e._v("Generate reverse index for documents")]),e._v(" "),s("li",[e._v("Generate word count for documents")]),e._v(" "),s("li",[e._v("Distributed sorting")])]),e._v(" "),s("p",[e._v("When talking about batch processing, most people will think about MapReduce. It doesn’t have to be. Batch processing on a high-level means grabbing some data sources periodically, applying custom business logic, and creating an output to be consumed by another consumer. You can write custom code for each process.")]),e._v(" "),s("p",[e._v("MapReduce consists of:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("Input => Splitting => Mapping => Shuffling => Reduce => Output\n")])])]),s("h3",{attrs:{id:"build-reverse-index-for-search"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#build-reverse-index-for-search"}},[e._v("#")]),e._v(" Build Reverse Index for Search")]),e._v(" "),s("p",[s("img",{attrs:{src:a(488),alt:"reverse index"}})]),e._v(" "),s("h3",{attrs:{id:"word-count-for-document"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#word-count-for-document"}},[e._v("#")]),e._v(" Word count for document")]),e._v(" "),s("p",[s("img",{attrs:{src:a(489),alt:"wordcount"}})]),e._v(" "),s("h2",{attrs:{id:"stream-processing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#stream-processing"}},[e._v("#")]),e._v(" Stream Processing")]),e._v(" "),s("p",[e._v("Data is unbounded in a stream processing architecture since data continuously comes in, and the system has to deal with it. The advantage of stream processing over batch is that the output will be much fresher since it’s processing near real-time, but it also comes at the expense of complexities.")]),e._v(" "),s("p",[e._v("In some streaming applications, event time does not need to be considered.")]),e._v(" "),s("p",[e._v("For example, if you have a global counter that keeps track of the number of events since the beginning of time, the event time is irrelevant in this context. However, if you are keeping track of the number of events from one period to another, then event time is crucial because you need to ensure the event time belongs in that period.")]),e._v(" "),s("h3",{attrs:{id:"realtime-classification"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#realtime-classification"}},[e._v("#")]),e._v(" Realtime Classification")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Classification")]),e._v(" "),s("th",[e._v("Examples")]),e._v(" "),s("th",[e._v("Latency measured in")]),e._v(" "),s("th",[e._v("Tolerance for delay")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("Hard")]),e._v(" "),s("td",[e._v("Pacemaker, anti-lock brakes")]),e._v(" "),s("td",[e._v("microseconds - milliseconds")]),e._v(" "),s("td",[e._v("None - total system failure, potential loss of life")])]),e._v(" "),s("tr",[s("td",[e._v("Soft")]),e._v(" "),s("td",[e._v("Airline reservation system, online stock quotes, VoIP (Skype)")]),e._v(" "),s("td",[e._v("milliseconds - seconds")]),e._v(" "),s("td",[e._v("Low - no system failure, no life at risk")])]),e._v(" "),s("tr",[s("td",[e._v("Near")]),e._v(" "),s("td",[e._v("Skype video, home automation")]),e._v(" "),s("td",[e._v("seconds - minutes")]),e._v(" "),s("td",[e._v("High - no system failure, no life at risk")])])])]),e._v(" "),s("h3",{attrs:{id:"system-is-down"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#system-is-down"}},[e._v("#")]),e._v(" System is Down")]),e._v(" "),s("p",[e._v("Since streaming is near real-time, and batch processing is much less frequent, if the service is down for 10 minutes, it has a much more significant implication for a near real-time system. Also, when the system comes back up, you need to think about how the system will process the 10 minutes of unprocessed data.")]),e._v(" "),s("h3",{attrs:{id:"late-and-out-of-order-events"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#late-and-out-of-order-events"}},[e._v("#")]),e._v(" Late and Out of Order Events")]),e._v(" "),s("p",[e._v("In the real-life system, events come in late. Imagine you have a mobile phone that omits events, and the network is down. The mobile phone\nqueues up the events, and when you reconnect to the internet, the events are late with respect to the processing time. On top of late events, since there's a\nclock skew (each machine has its clock) in a distributed system, you can’t assume the events are ordered since it makes it difficult for you to assume\nyou’ve seen all the events before a certain time.")]),e._v(" "),s("h3",{attrs:{id:"watermark"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#watermark"}},[e._v("#")]),e._v(" Watermark")]),e._v(" "),s("p",[e._v("The intuition behind the watermark is that you have a heuristic behind whether you have received enough data for a time-period to move on.")]),e._v(" "),s("p",[e._v("For example, if you are collecting data from time_0 to time_1, due to late events, how do you know you have collected enough information about that interval such that you hope events between time_0 and time_1 won’t ever come anymore?")]),e._v(" "),s("p",[e._v("Assume you have a watermark delay of 7. If you see a time_20 event, you have a watermark of time_13. If you see events before time_13, you will consider it past the watermark and treat it accordingly, such as dropping the event. A trade-off you can discuss is the bigger the watermark, the more memory you have to hold to account for late data with the benefit of not dropping late events.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(490),alt:"img"}})]),e._v(" "),s("p",[e._v("Now, what happens if another event belongs in time_0 to time_1? That depends on your application. Some common options are discarding it or updating the previous record. Discarding is easy but may lead to an inaccuracy that’s poor for user experience. On the other hand, updating records isn’t as simple as just append-only applications and may require a separate pipeline for updating existing records.")]),e._v(" "),s("h3",{attrs:{id:"checkpointing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#checkpointing"}},[e._v("#")]),e._v(" Checkpointing")]),e._v(" "),s("p",[e._v("There is usually some intermediate data structure in streaming applications to keep track of the data processed so far. What if that host goes down? Processing failure is where checkpointing helps so you don’t have to reprocess all the events from the beginning. The frequency of the\ncheckpoint and how and what you persist in the checkpoints.  More frequent checkpointing means lower performance but faster failure recovery, and the\nreverse is true for less frequent checkpointing.")]),e._v(" "),s("h3",{attrs:{id:"batch-size"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#batch-size"}},[e._v("#")]),e._v(" Batch Size")]),e._v(" "),s("p",[e._v("Even in stream processing, it doesn’t mean you process event by event, which may kill the throughput of your system since there’s additional\noverhead per event. For example, imagine for each event you need to do a network or disk IO. To do it on every event will cause IOs to become the bottleneck. Sometimes it's more efficient to micro-batch to make that more efficient. A trade-off discussion is the batch size. A bigger batch size causes delay but may have better throughput since there’s less IO overhead per batch.")]),e._v(" "),s("h3",{attrs:{id:"streaming-architectural-blueprint"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#streaming-architectural-blueprint"}},[e._v("#")]),e._v(" Streaming Architectural blueprint")]),e._v(" "),s("p",[s("img",{attrs:{src:a(491),alt:"stream arch"}})]),e._v(" "),s("h2",{attrs:{id:"lambda-architecture-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lambda-architecture-2"}},[e._v("#")]),e._v(" Lambda Architecture")]),e._v(" "),s("p",[e._v("Sometimes the application can not wait for a delay in processing for the end-user at the same time. Doing the processing accurately and consistently\nwill be difficult with the existing infrastructure. There’s lambda architecture with a fast lane and a slow lane.")]),e._v(" "),s("p",[e._v("Fast lane tries to minimize latency at the sacrifice of completeness and accuracy like stream processing.")]),e._v(" "),s("p",[e._v("Slow lane will have most, if not all the data available to compute a more accurate result for the end-user like batch processing.")]),e._v(" "),s("p",[e._v("In practice, there’s operational complexity to managing two similar systems.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(492),alt:"hadoop-arch"}})]),e._v(" "),s("p",[s("a",{attrs:{href:"https://www.databricks.com/glossary/lambda-architecture",target:"_blank",rel:"noopener noreferrer"}},[e._v("Read more"),s("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=o.exports},488:function(e,t,a){e.exports=a.p+"assets/img/reverse-index.c92f287f.png"},489:function(e,t,a){e.exports=a.p+"assets/img/word-count.9bec76b7.png"},490:function(e,t,a){e.exports=a.p+"assets/img/watermark.15b58e98.png"},491:function(e,t,a){e.exports=a.p+"assets/img/stream-arch.f7f94662.png"},492:function(e,t,a){e.exports=a.p+"assets/img/hadoop-architecture.b16ae7f2.png"}}]);