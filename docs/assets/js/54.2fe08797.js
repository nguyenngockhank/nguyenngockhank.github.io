(window.webpackJsonp=window.webpackJsonp||[]).push([[54],{1594:function(e,t,a){"use strict";a.r(t);var n=a(7),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_9-security"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_9-security"}},[e._v("#")]),e._v(" 9. Security")]),e._v(" "),n("p",[e._v("We’ve become familiar with stories about security breaches of large-scale systems resulting in our data being exposed to all sorts of dodgy characters. But more recently, events like the Edward Snowden revelations have made us even more aware of the value of data that companies hold about us, and the value of data that we hold for our customers in the systems we build. This chapter will give a brief overview of some aspects of\nsecurity you should consider when designing your systems. While not meant to be\nexhaustive, it will lay out some of the main options available to you and give you a\nstarting point for your own further research.")]),e._v(" "),n("p",[e._v("We need to think about what protection our data needs while in transit from one point to\nanother, and what protection it needs at rest. We need to think about the security of our\nunderlying operating systems, and our networks too. There is so much to think about, and\nso much we could do! So how much security do we need? How can we work out what is\n"),n("em",[e._v("enough")]),e._v("  security?")]),e._v(" "),n("p",[e._v("But we also need to think of the human element. How do we know who a person is, and\nwhat he can do? And how does this relate to how our servers talk to each other? Let’s start\nthere.")]),e._v(" "),n("h2",{attrs:{id:"authentication-and-authorization"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#authentication-and-authorization"}},[e._v("#")]),e._v(" Authentication and Authorization")]),e._v(" "),n("p",[e._v("Authentication and authorization are core concepts when it comes to people and things\nthat interact with our system. In the context of security,  "),n("em",[e._v("authentication")]),e._v("  is the process by\nwhich we confirm that a party is who she says she is. For a human, you typically\nauthenticate a user by having her type in her username and password. We assume that only\nshe has access to this information, and therefore that the person entering this information\nmust be her. Other, more complex systems exist as well, of course. My phone now lets me\nuse my fingerprint to confirm that I am who I say I am. Generally, when we’re talking\nabstractly about who or what is being authenticated, we refer to that party as the  "),n("em",[e._v("principal")]),e._v(".")]),e._v(" "),n("p",[n("em",[e._v("Authorization")]),e._v("  is the mechanism by which we map from a principal to the action we are\nallowing her to do. Often, when a principal is authenticated, we will be given information\nabout her that will help us decide what we should let her do. We might, for example, be\ntold what department or office she works in — pieces of information that our systems can\nuse to decide what she can and cannot do.")]),e._v(" "),n("p",[e._v("For single, monolithic applications, it is common for the application itself to handle\nauthentication and authorization for you. Django, the Python web framework, comes out\nof the box with user management, for example. When it comes to distributed systems,\nthough, we need to think of more advanced schemes. We don’t want everyone to have to\nlog in separately for different systems, using a different username and password for each.\nThe aim is to have a single identity that we can authenticate once.")]),e._v(" "),n("h2",{attrs:{id:"common-single-sign-on-implementations"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#common-single-sign-on-implementations"}},[e._v("#")]),e._v(" Common Single Sign-On Implementations")]),e._v(" "),n("p",[e._v("A common approach to authentication and authorization is to use some sort of  "),n("em",[e._v("single sign-\non (SSO)")]),e._v("  solution. SAML, which is the reigning implementation in the enterprise space,\nand OpenID Connect both provide capabilities in this area. More or less they use the same\ncore concepts, although the terminology differs slightly. The terms used here are from\nSAML.")]),e._v(" "),n("p",[e._v("When a principal tries to access a resource (like a web-based interface), she is directed to\nauthenticate with an  "),n("em",[e._v("identity provider")]),e._v(" . This may ask her to provide a username and\npassword, or might use something more advanced like two-factor authentication. Once the\nidentity provider is satisfied that the principal has been authenticated, it gives information\nto the  "),n("em",[e._v("service provider")]),e._v(" , allowing it to decide whether to grant her access to the resource.")]),e._v(" "),n("p",[e._v("This identity provider could be an externally hosted system, or something inside your own\norganization. Google, for example, provides an OpenID Connect identity provider. For\nenterprises, though, it is common to have your own identity provider, which may be linked\nto your company’s  "),n("em",[e._v("directory service")]),e._v(" . A directory service could be something like the\nLightweight Directory Access Protocol (LDAP) or Active Directory. These systems allow\nyou to store information about principals, such as what roles they play in the organization.\nOften, the directory service and the identity provider are one and the same, while\nsometimes they are separate but linked. Okta, for example, is a hosted SAML identity\nprovider that handles tasks like two-factor authentication, but can link to your company’s\ndirectory services as the source of truth.")]),e._v(" "),n("p",[e._v("SAML is a SOAP-based standard, and is known for being fairly complex to work with\ndespite the libraries and tooling available to support it. OpenID Connect is a standard that\nhas emerged as a specific implementation of OAuth 2.0, based on the way Google and\nothers handle SSO. It uses simpler REST calls, and in my opinion is likely to make\ninroads into enterprises due to its improved ease of use. Its biggest stumbling block right\nnow is the lack of identity providers that support it. For a public-facing website, you might\nbe OK using Google as your provider, but for internal systems or systems where you want\nmore control over and visibility into how and where your data is installed, you’ll want\nyour own in-house identity provider. At the time of writing, OpenAM and Gluu are two of\nthe very few options available in this space, compared to a wealth of options for SAML\n(including Active Directory, which seems to be everywhere). Until and unless existing\nidentity providers start supporting OpenID Connect, its growth may be limited to those\nsituations where people are happy using a public identity provider.")]),e._v(" "),n("p",[e._v("So while I think OpenID Connect is the future, it’s quite possible it’ll take a while to reach\nwidespread adoption.")]),e._v(" "),n("h2",{attrs:{id:"single-sign-on-gateway"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#single-sign-on-gateway"}},[e._v("#")]),e._v(" Single Sign-On Gateway")]),e._v(" "),n("p",[e._v("Within a microservice setup, each service could decide to handle the redirection to, and\nhandshaking with, the identity provider. Obviously, this could mean a lot of duplicated\nwork. A shared library could help, but we’d have to be careful to avoid the coupling that\ncan come from shared code. This also wouldn’t help if you had multiple different\ntechnology stacks.")]),e._v(" "),n("p",[e._v("Rather than having each service manage handshaking with your identity provider, you can\nuse a gateway to act as a proxy, sitting between your services and the outside world (as\nshown in Figure 9-1). The idea is that we can centralize the behavior for redirecting the\nuser and perform the handshake in only one place.")]),e._v(" "),n("p",[n("img",{attrs:{src:a(725),alt:"img"}})]),e._v(" "),n("p",[n("em",[e._v("Figure 9-1. Using a gateway to handle SSO")])]),e._v(" "),n("p",[e._v("However, we still need to solve the problem of how the downstream service receives\ninformation about principals, such as their username or what roles they play. If you’re\nusing HTTP, it could populate headers with this information. Shibboleth is one tool that\ncan do this for you, and I’ve seen it used with Apache to great effect to handle integration\nwith SAML-based identity providers.")]),e._v(" "),n("p",[e._v("Another problem is that if we have decided to offload responsibility for authentication to a\ngateway, it can be harder to reason about how a microservice behaves when looking at it\nin isolation. Remember in Chapter 7 where we explored some of the challenges in\nreproducing production-like environments? If you go the gateway route, make sure your\ndevelopers can launch their services behind one without too much work.")]),e._v(" "),n("p",[e._v("One final problem with this approach is that it can lull you into a false sense of security. I\nlike the idea of defense in depth — from network perimeter, to subnet, to firewall, to")]),e._v(" "),n("p",[e._v("machine, to operating system, to the underlying hardware. You have the ability to\nimplement security measures at all of these points, some of which we’ll get into shortly. I\nhave seen some people put all their eggs in one basket, relying on the gateway to handle\nevery step for them. And we all know what happens when we have a single point of\nfailure...")]),e._v(" "),n("p",[e._v("Obviously you could use this gateway to do other things. If using a layer of Apache\ninstances running Shibboleth, for example, you could also decide to terminate HTTPS at\nthis level, run intrusion detection, and so on. Do be careful, though. Gateway layers tend\nto take on more and more functionality, which itself can end up being a giant coupling\npoint. And the more functionality something has, the greater the attack surface.")]),e._v(" "),n("h2",{attrs:{id:"fine-grained-authorization"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fine-grained-authorization"}},[e._v("#")]),e._v(" Fine-Grained Authorization")]),e._v(" "),n("p",[e._v("A gateway may be able to provide fairly effective coarse-grained authentication. For\nexample, it could prevent access to any non-logged-in user to the helpdesk application.\nAssuming our gateway can extract attributes about the principal as a result of the\nauthentication, it may be able to make more nuanced decisions. For example, it is common\nto place people in groups, or assign them to roles. We can use this information to\nunderstand what they can do. So for the helpdesk application, we might allow access only\nto principals with a specific role (e.g., STAFF). Beyond allowing (or disallowing) access\nto specific resources or endpoints, though, we need to leave the rest to the microservice\nitself; it will need to make further decisions about what operations to allow.")]),e._v(" "),n("p",[e._v("Back to our helpdesk application: do we allow any staff members to see any and all\ndetails? More likely, we’ll have different roles at work. For example, a principal in the\nCALL_CENTER group might be allowed to view any piece of information about a\ncustomer except his payment details. The principal might also be able to issue refunds, but\nthat amount might be capped. Someone who has the CALL_CENTER_TEAM_LEADER\nrole, however, might be able to issue larger refunds.")]),e._v(" "),n("p",[e._v("These decisions need to be local to the microservice in question. I have seen people use\nthe various attributes supplied by identity providers in horrible ways, using really fine-\ngrained roles like CALL_CENTER_50_DOLLAR_REFUND, where they end up putting\ninformation specific to one part of one of our system’s behavior into their directory\nservices. This is a nightmare to maintain and gives very little scope for our services to\nhave their own independent lifecycle, as suddenly a chunk of information about how a\nservice behaves lives elsewhere, perhaps in a system managed by a different part of the\norganization.")]),e._v(" "),n("p",[e._v("Instead, favor coarse-grained roles, modeled around how your organization works. Going\nall the way back to the early chapters, remember that we are building software to match\nhow our organization works. So use your roles in this way too.")]),e._v(" "),n("h2",{attrs:{id:"service-to-service-authentication-and-authorization"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#service-to-service-authentication-and-authorization"}},[e._v("#")]),e._v(" Service-to-Service Authentication and Authorization")]),e._v(" "),n("p",[e._v("Up to this point we’ve been using the term  "),n("em",[e._v("principal")]),e._v("  to describe anything that can\nauthenticate and be authorized to do things, but our examples have actually been about\nhumans using computers. But what about programs, or other services, authenticating with\neach other?")]),e._v(" "),n("h2",{attrs:{id:"allow-everything-inside-the-perimeter"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#allow-everything-inside-the-perimeter"}},[e._v("#")]),e._v(" Allow Everything Inside the Perimeter")]),e._v(" "),n("p",[e._v("Our first option could be to just assume that any calls to a service made from inside our\nperimeter are implicitly trusted.")]),e._v(" "),n("p",[e._v("Depending on the sensitivity of the data, this might be fine. Some organizations attempt to\nensure security at the perimeter of their networks, and therefore assume they don’t need to\ndo anything else when two services are talking together. However, should an attacker\npenetrate your network, you will have little protection against a typical  "),n("em",[e._v("man-in-the-middle")]),e._v("\nattack. If the attacker decides to intercept and read the data being sent, change the data\nwithout you knowing, or even in some circumstances pretend to be the thing you are\ntalking to, you may not know much about it.")]),e._v(" "),n("p",[e._v("This is by far the most common form of inside-perimeter trust I see in organizations. They\nmay decide to run this traffic over HTTPS, but they don’t do much else. I’m not saying\nthat is a good thing! For most of the organizations I see using this model, I worry that the\nimplicit trust model is not a conscious decision, but more that people are unaware of the\nrisks in the first place.")]),e._v(" "),n("h2",{attrs:{id:"http-s-basic-authentication"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#http-s-basic-authentication"}},[e._v("#")]),e._v(" HTTP(S) Basic Authentication")]),e._v(" "),n("p",[e._v("HTTP Basic Authentication allows for a client to send a username and password in a\nstandard HTTP header. The server can then check these details and confirm that the client\nis allowed to access the service. The advantage here is that this is an extremely well-\nunderstood and well-supported protocol. The problem is that doing this over HTTP is\nhighly problematic, as the username and password are not sent in a secure manner. Any\nintermediate party can look at the information in the header and see the data. Thus, HTTP\nBasic Authentication should normally be used over HTTPS.")]),e._v(" "),n("p",[e._v("When using HTTPS, the client gains strong guarantees that the server it is talking to is\nwho the client thinks it is. It also gives us additional protection against people\neavesdropping on the traffic between the client and server or messing with the payload.")]),e._v(" "),n("p",[e._v("The server needs to manage its own SSL certificates, which can become problematic when\nit is managing multiple machines. Some organizations take on their own certificate issuing\nprocess, which is an additional administrative and operational burden. Tools around\nmanaging this in an automated fashion are nowhere near as mature as they could be, and it\nisn’t just the issuing process you have to handle. Self-signed certificates are not easily\nrevokable, and thus require a lot more thought around disaster scenarios. See if you can\ndodge all this work by avoiding self-signing altogether.")]),e._v(" "),n("p",[e._v("Another downside is that traffic sent via SSL cannot be cached by reverse proxies like\nVarnish or Squid. This means that if you need to cache traffic, it will have to be done\neither inside the server or inside the client. You can fix this by having a load balancer\nterminate the SSL traffic, and having the cache sit behind the load balancer.")]),e._v(" "),n("p",[e._v("We also have to think about what happens if we are using an existing SSO solution, like\nSAML, that already has access to usernames and passwords. Do we want our basic service\nauth to use the same set of credentials, allowing us one process for issuing and revoking\nthem? We could do this by having the service talk to the same directory service that backs\nour SSO solution. Alternatively, we could store the usernames and passwords ourselves\ninside the service, but then we run the risk of duplicating behavior.")]),e._v(" "),n("p",[e._v("One note: in this approach, all the server knows is that the client has the username and\npassword. We have no idea if this information is coming from a machine we expect; it\ncould be coming from anyone on our network.")]),e._v(" "),n("h2",{attrs:{id:"use-saml-or-openid-connect"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#use-saml-or-openid-connect"}},[e._v("#")]),e._v(" Use SAML or OpenID Connect")]),e._v(" "),n("p",[e._v("If you are already using SAML or OpenID Connect as your authentication and\nauthorization scheme, you could just use that for service-to-service interactions too. If\nyou’re using a gateway, you’ll need to route all in-network traffic via the gateway too, but\nif each service is handling the integration itself, this approach should just work out of the\nbox. The advantage here is that you’re making use of existing infrastructure, and get to\ncentralize all your service access controls in a central directory server. We’d still need to\nroute this over HTTPS if we wanted to avoid man-in-the-middle attacks.")]),e._v(" "),n("p",[e._v("Clients have a set of credentials they use to authenticate themselves with the identity\nprovider, and the service gets the information it needs to decide on any fine-grained\nauthentication.")]),e._v(" "),n("p",[e._v("This does mean you’ll need an account for your clients, sometimes referred to as a  "),n("em",[e._v("service\naccount")]),e._v(" . Many organizations use this approach quite commonly. A word of warning,\nthough: if you are going to create service accounts, try to keep their use narrow. So\nconsider each microservice having its own set of credentials. This makes\nrevoking/changing access easier if the credentials become compromised, as you only need\nto revoke the set of credentials that have been affected.")]),e._v(" "),n("p",[e._v("There are a couple of other downsides, though. First, just as with Basic Auth, we need to\nsecurely store our credentials: where do the username and password live? The client will\nneed to find some secure way to store this data. The other problem is that some of the\ntechnology in this space to do the authentication is fairly tedious to code for. SAML, in\nparticular, makes implementing a client a painful affair. OpenID Connect has a simpler\nworkflow, but as we discussed earlier it isn’t that well supported yet.")]),e._v(" "),n("h2",{attrs:{id:"client-certificates"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#client-certificates"}},[e._v("#")]),e._v(" Client Certificates")]),e._v(" "),n("p",[e._v("Another approach to confirm the identity of a client is to make use of capabilities in\nTransport Layer Security (TLS), the successor to SSL, in the form of client certificates.\nHere, each client has an X.509 certificate installed that is used to establish a link between\nclient and server. The server can verify the authenticity of the client certificate, providing\nstrong guarantees that the client is valid.")]),e._v(" "),n("p",[e._v("The operational challenges here in certificate management are even more onerous than\nwith just using server-side certificates. It isn’t just some of the basic issues of creating and\nmanaging a greater number of certificates; rather, it’s that with all the complexities around\nthe certificates themselves, you can expect to spend a lot of time trying to diagnose why a\nservice won’t accept what you believe to be a completely valid client certificate. And then\nwe have to consider the difficulty of revoking and reissuing certificates should the worst\nhappen. Using wildcard certificates can help, but won’t solve all problems. This additional\nburden means you’ll be looking to use this technique when you are especially concerned\nabout the sensitivity of the data being sent, or if you are sending data via networks you\ndon’t fully control. So you might decide to secure communication of very important data\nbetween parties that is sent over the Internet, for example.")]),e._v(" "),n("h2",{attrs:{id:"hmac-over-http"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hmac-over-http"}},[e._v("#")]),e._v(" HMAC Over HTTP")]),e._v(" "),n("p",[e._v("As we discussed earlier, the use of Basic Authentication over plain HTTP is not terribly\nsensible if we are worried about the username and password being compromised. The\ntraditional alternative is route traffic HTTPS, but there are some downsides. Aside from\nmanaging the certificates, the overhead of HTTPS traffic can place additional strain on\nservers (although, to be honest, this has a lower impact than it did several years ago), and\nthe traffic cannot easily be cached.")]),e._v(" "),n("p",[e._v("An alternative approach, as used extensively by Amazon’s S3 APIs for AWS and in parts\nof the OAuth specification, is to use a  "),n("em",[e._v("hash-based messaging code (HMAC)")]),e._v("  to sign the\nrequest.")]),e._v(" "),n("p",[e._v("With HMAC the body request along with a private key is hashed, and the resulting hash is\nsent along with the request. The server then uses its own copy of the private key and the\nrequest body to re-create the hash. If it matches, it allows the request. The nice thing here\nis that if a man in the middle messes with the request, then the hash won’t match and the\nserver knows the request has been tampered with. And the private key is never sent in the\nrequest, so it cannot be compromised in transit! The added benefit is that this traffic can\nthen more easily be cached, and the overhead of generating the hashes may well be lower\nthan handling HTTPS traffic (although your mileage may vary).")]),e._v(" "),n("p",[e._v("There are three downsides to this approach. First, both the client and server need a shared\nsecret that needs to be communicated somehow. How do they share it? It could be\nhardcoded at both ends, but then you have the problem of revoking access if the secret\nbecomes compromised. If you communicate this key over some alternative protocol, then\nyou need to make sure that that protocol is also very secure!")]),e._v(" "),n("p",[e._v("Second, this is a pattern, not a standard, and thus there are divergent ways of\nimplementing it. As a result, there is a dearth of good, open, and usable implementations\nof this approach. In general, if this approach interests you, then do some more reading to\nunderstand the different ways it is done. I’d go as far as to say just look at how Amazon\ndoes this for S3 and copy its approach, especially using a sensible hashing function with a\nsuitably long key like SHA-256. JSON web tokens (JWT) are also worth looking at, as\nthey implement a very similar approach and seem to be gaining traction. But be aware of\nthe difficulty of getting this stuff right. My colleague was working with a team that was\nimplementing its own JWT implementation, omitted a single Boolean check, and\ninvalidated its entire authentication code! Hopefully over time we’ll see more reusable\nlibrary implementations.")]),e._v(" "),n("p",[e._v("Finally, understand that this approach ensures only that no third party has manipulated the\nrequest and that the private key itself remains private. The rest of the data in the request\nwill still be visible to parties snooping on the network.")]),e._v(" "),n("h2",{attrs:{id:"api-keys"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#api-keys"}},[e._v("#")]),e._v(" API Keys")]),e._v(" "),n("p",[e._v("All public APIs from services like Twitter, Google, Flickr, and AWS make use of API\nkeys. API keys allow a service to identify who is making a call, and place limits on what\nthey can do. Often the limits go beyond simply giving access to a resource, and can extend\nto actions like rate-limiting specific callers to protect quality of service for other people.")]),e._v(" "),n("p",[e._v("When it comes to using API keys to handle your own microservice-to-microservice\napproach, the exact mechanics of how it works will depend on the technology you use.\nSome systems use a single API key that is shared, and use an approach similar to HMAC\nas just described. A more common approach is to use a public and private key pair.\nTypically, you’ll manage keys centrally, just as we would manage identities of people\ncentrally. The gateway model is very popular in this space.")]),e._v(" "),n("p",[e._v("Part of their popularity stems from the fact that API keys are focused on ease of use for\nprograms. Compared to handling a SAML handshake, API key–based authentication is\nmuch simpler and more straightforward.")]),e._v(" "),n("p",[e._v("The exact capabilities of the systems vary, and you have multiple options in both the\ncommercial and open source space. Some of the products just handle the API key\nexchange and some basic key management. Other tools offer everything up to and\nincluding rate limiting, monetization, API catalogs, and discovery systems.")]),e._v(" "),n("p",[e._v("Some API systems allow you to bridge API keys to existing directory services. This would\nallow you to issue API keys to principals (representing people or systems) in your\norganization, and control the lifecycle of those keys in the same way you’d manage their\nnormal credentials. This opens up the possibility of allowing access to your services in\ndifferent ways but keeping the same source of truth — for example, using SAML to\nauthenticate humans for SSO, and using API keys for service-to-service communication,\nas shown in Figure 9-2.")]),e._v(" "),n("p",[n("img",{attrs:{src:a(726),alt:"img"}})]),e._v(" "),n("p",[n("em",[e._v("Figure 9-2. Using directory services to synchronize principal information between an SSO and an API gateway")])]),e._v(" "),n("h2",{attrs:{id:"the-deputy-problem"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#the-deputy-problem"}},[e._v("#")]),e._v(" The Deputy Problem")]),e._v(" "),n("p",[e._v("Having a principal authenticate with a given microserservice is simple enough. But what\nhappens if that service then needs to make additional calls to complete an operation? Take\na look at Figure 9-3, which illustrates MusicCorp’s online shopping site. Our online shop\nis a browser-based JavaScript UI. It makes calls to a server-side shop application, using\nthe backends-for-frontends pattern we described in Chapter 4. Calls made between the\nbrowser and server calls can be authenticated using SAML or OpenID Connect or similar.\nSo far, so good.")]),e._v(" "),n("p",[e._v("When I am logged in, I can click on a link to view details of an order. To display the\ninformation, we need to pull back the original order from the order service, but we also\nwant to look up shipping information for the order. So clicking the link to\n"),n("em",[e._v("/orderStatus/12345")]),e._v("  causes the online shop to initiate a call from the online shop service to\nboth the order service and shipping service asking for those details. But should these\ndownstream services accept the calls from the online shop? We could adopt a stance of\nimplicit trust — that because the call came from within our perimeter, it is OK. We could\neven use certificates or API keys to confirm that yes, it really is the online shop asking for\nthis information. But is this enough?")]),e._v(" "),n("p",[n("img",{attrs:{src:a(727),alt:"img"}})]),e._v(" "),n("p",[n("em",[e._v("Figure 9-3. An example where a confused deputy could come into play")])]),e._v(" "),n("p",[e._v("of service-to-service communication refers to a situation where a malicious party can trick\na deputy service into making calls to a downstream service on his behalf that he shouldn’t\nbe able to. For example, as a customer, when I log in to the online shopping system, I can\nsee my account details. What if I could trick the online shopping UI into making a request\nfor someone else’s details, maybe by making a call with my logged-in credentials?")]),e._v(" "),n("p",[e._v("In this example, what is to stop me from asking for orders that are not mine? Once logged\nin, I could start sending requests for other orders that aren’t mine to see if I could get")]),e._v(" "),n("p",[e._v("useful information. We could try to protect against this inside the online shop itself, by\nchecking who the order is for and rejecting it if someone’s asking for things he shouldn’t.\nIf we have lots of different applications that surface this information, though, we could\npotentially be duplicating this logic in lots of places.")]),e._v(" "),n("p",[e._v("We could route requests directly from the UI to the order service and allow it to validate\nthe request, but then we hit the various downsides we discussed in Chapter 4.\nAlternatively, when the online shop sends the request to the order service, it could state\nnot just what order it wants, but also on whose behalf it is asking. Some authentication\nschemes allow us to pass in the original principal’s credentials downstream, although with\nSAML this is a bit of a nightmare, involving nested SAML assertions that are technically\nachievable — but so difficult that no one ever does this. This can become even more\ncomplex, of course. Imagine if the services the online shop talks to in turn make more\ndownstream calls. How far do we have to go in validating trust for all those deputies?")]),e._v(" "),n("p",[e._v("This problem, unfortunately, has no simple answer, because it isn’t a simple problem. Be\naware that it exists, though. Depending on the sensitivity of the operation in question, you\nmight have to choose between implicit trust, verifying the identity of the caller, or asking\nthe caller to provide the credentials of the original principal.")]),e._v(" "),n("h2",{attrs:{id:"securing-data-at-rest"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#securing-data-at-rest"}},[e._v("#")]),e._v(" Securing Data at Rest")]),e._v(" "),n("p",[e._v("Data lying about is a liability, especially if it is sensitive. Hopefully we’ve done\neverything we can to ensure attackers cannot breach our network, and also that they\ncannot breach our applications or operating systems to get access to the underlying close\nup. However, we need to be prepared in case they do — defense in depth is key.")]),e._v(" "),n("p",[e._v("Many of the high-profile security breaches involve data at rest being acquired by an\nattacker, and that data being readable by the attacker. This is either because the data was\nstored in an unencrypted form, or because the mechanism used to protect the data had a\nfundamental flaw.")]),e._v(" "),n("p",[e._v("The mechanisms by which secure information can be protected are many and varied, but\nwhichever approach you pick there are some general things to bear in mind.")]),e._v(" "),n("h2",{attrs:{id:"go-with-the-well-known"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#go-with-the-well-known"}},[e._v("#")]),e._v(" Go with the Well Known")]),e._v(" "),n("p",[e._v("The easiest way you can mess up data encryption is to try to implement your own\nencryption algorithms, or even try to implement someone else’s. Whatever programming\nlanguage you use, you’ll have access to reviewed, regularly patched implementations of\nwell-regarded encryption algorithms. Use those! And subscribe to the mailing\nlists/advisory lists for the technology you choose to make sure you are aware of\nvulnerabilities as they are found so you can keep them patched and up to date.")]),e._v(" "),n("p",[e._v("For encryption at rest, unless you have a very good reason for picking something else,\npick a well-known implementation of AES-128 or AES-256 for your platform.^3  Both the\nJava and .NET runtimes include implementations of AES that are highly likely to be well\ntested (and well patched), but separate libraries exist for most platforms too — for\nexample, the Bouncy Castle libraries for Java and C#.")]),e._v(" "),n("p",[e._v("For passwords, you should consider using a technique called  "),n("em",[e._v("salted password hashing")]),e._v(".")]),e._v(" "),n("p",[e._v("Badly implemented encryption could be worse than having none, as the false sense of\nsecurity (pardon the pun) can lead you to take your eye off the ball.")]),e._v(" "),n("h2",{attrs:{id:"it-s-all-about-the-keys"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#it-s-all-about-the-keys"}},[e._v("#")]),e._v(" It’s All About the Keys")]),e._v(" "),n("p",[e._v("As has been covered so far, encryption relies on an algorithm taking the data to be\nencrypted and a key and then producing the encrypted data. So, where is your key stored?\nNow if I am encrypting my data because I am worried about someone stealing my whole\ndatabase, and I store the key I use in the same database, then I haven’t really achieved\nmuch! Therefore, we need to store the keys somewhere else. But where?")]),e._v(" "),n("p",[e._v("One solution is to use a separate security appliance to encrypt and decrypt data. Another is\nto use a separate key vault that your service can access when it needs a key. The lifecycle\nmanagement of the keys (and access to change them) can be a vital operation, and these\nsystems can handle this for you.")]),e._v(" "),n("p",[e._v("Some databases even include built-in support for encryption, such as SQL Server’s\nTransparent Data Encryption, that aim to handle this in a transparent fashion. Even if your\ndatabase of choice does, research how the keys are handled and understand if the threat\nyou are protecting against is actually being mitigated.")]),e._v(" "),n("p",[e._v("Again, this stuff is complex. Avoid implementing your own, and do some good research!")]),e._v(" "),n("h2",{attrs:{id:"pick-your-targets"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#pick-your-targets"}},[e._v("#")]),e._v(" Pick Your Targets")]),e._v(" "),n("p",[e._v("Assuming everything should be encrypted can simplify things somewhat. There is no\nguesswork about what should or should not be protected. However, you’ll still need to\nthink about what data can be put into logfiles to help problem identification, and the\ncomputational overhead of encrypting everything can become pretty onerous, needing\nmore powerful hardware as a result. This is even more challenging when you’re applying\ndatabase migrations as part of refactoring schemas. Depending on the changes being\nmade, the data may need to be decrypted, migrated, and re-encrypted.")]),e._v(" "),n("p",[e._v("By subdividing your system into more fine-grained services, you might identify an entire\ndata store that can be encrypted wholesale, but even then it is unlikely. Limiting this\nencryption to a known set of tables is a sensible approach.")]),e._v(" "),n("h2",{attrs:{id:"decrypt-on-demand"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#decrypt-on-demand"}},[e._v("#")]),e._v(" Decrypt on Demand")]),e._v(" "),n("p",[e._v("Encrypt data when you first see it. Only decrypt on demand, and ensure that data is never\nstored anywhere.")]),e._v(" "),n("h2",{attrs:{id:"encrypt-backups"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#encrypt-backups"}},[e._v("#")]),e._v(" Encrypt Backups")]),e._v(" "),n("p",[e._v("Backups are good. We want to back up our important data, and almost by definition data\nwe are worried enough about that we want to encrypt it is important enough to back up!\nSo it may seem like an obvious point, but we need to make sure that  "),n("em",[e._v("our backups are also\nencrypted")]),e._v(" . This also means that we need to know which keys are needed to handle which\nversion of data, especially if the keys change. Having clear key management becomes\nfairly important.")]),e._v(" "),n("h2",{attrs:{id:"defense-in-depth"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#defense-in-depth"}},[e._v("#")]),e._v(" Defense in Depth")]),e._v(" "),n("p",[e._v("As I’ve mentioned earlier, I dislike putting all our eggs in one basket. It’s all about defence\nin depth. We’ve talked already about securing data in transit, and securing data at rest. But\nare there other protections we could put in place to help?")]),e._v(" "),n("h2",{attrs:{id:"firewalls"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#firewalls"}},[e._v("#")]),e._v(" Firewalls")]),e._v(" "),n("p",[e._v("Having one or more firewalls is a very sensible precaution to take. Some are very simple,\nable only to restrict access to certain types of traffic on certain ports. Others are more\nsophisticated. ModSecurity, for example, is a type of application firewall that can help\nthrottle connections from certain IP ranges and detect other sorts of malicious attacks.")]),e._v(" "),n("p",[e._v("There is value in having more than one firewall. For example, you may decide to use\nIPTables locally on a host to secure that host, setting up the allowable ingress and egress.\nThese rules could be tailored to the locally running services, with a firewall at the\nperimeter for controlling general access.")]),e._v(" "),n("h2",{attrs:{id:"logging"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#logging"}},[e._v("#")]),e._v(" Logging")]),e._v(" "),n("p",[e._v("Good logging, and specifically the ability to aggregate logs from multiple systems, is not\nabout prevention, but can help with detecting and recovering from bad things happening.\nFor example, after applying security patches you can often see in logs if people have been\nexploiting certain vulnerabilities. Patching makes sure it won’t happen again, but if it\nalready  "),n("em",[e._v("has")]),e._v("  happened, you may need to go into recovery mode. Having logs available\nallows you to see if something bad happened after the fact.")]),e._v(" "),n("p",[e._v("Note, however, that we need to be careful about what information we store in our logs!\nSensitive information needs to be culled to ensure we aren’t leaking important data into\nour logs, which could end up being a great target for attackers.")]),e._v(" "),n("h2",{attrs:{id:"intrusion-detection-and-prevention-system"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#intrusion-detection-and-prevention-system"}},[e._v("#")]),e._v(" Intrusion Detection (and Prevention) System")]),e._v(" "),n("p",[n("em",[e._v("Intrusion detection systems (IDS)")]),e._v("  can monitor networks or hosts for suspicious behavior,\nreporting problems when it sees them.  "),n("em",[e._v("Intrusion prevention systems (IPS)")]),e._v(" , as well as\nmonitoring for suspicious activity, can step in to stop it from happening. Unlike a firewall,\nwhich is primarily looking outward to stop bad things from getting in, IDS and IPS are\nactively looking inside the perimeter for suspect behavior. When you’re starting from\nscratch, IDS may make most sense. These systems are heuristic-based (as are many\napplication firewalls), and it is possible that the generic starting set of rules will either be\ntoo lenient or not lenient enough for how your service behaves. Using a more passive IDS\nto alert you to problems is a good way to tune your rules before using it in a more active\ncapacity.")]),e._v(" "),n("h2",{attrs:{id:"network-segregation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#network-segregation"}},[e._v("#")]),e._v(" Network Segregation")]),e._v(" "),n("p",[e._v("With a monolithic system, we have limits to how we can structure our networks to provide\nadditional protections. With microservices, though, you can put them into different\nnetwork segments to further control how services talk to each other. AWS, for example,\nprovides the ability to automatically provision a  "),n("em",[e._v("virtual private cloud (VPC)")]),e._v(" , which allow\nhosts to live in separate subnets. You can then specify which VPCs can see each other by\ndefining peering rules, and even route traffic through gateways to proxy access, giving\nyou in effect multiple perimeters at which additional security measures can be put into\nplace.")]),e._v(" "),n("p",[e._v("This could allow you to segment networks based on team ownership, or perhaps by risk\nlevel.")]),e._v(" "),n("h2",{attrs:{id:"operating-system"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#operating-system"}},[e._v("#")]),e._v(" Operating System")]),e._v(" "),n("p",[e._v("Our systems rely on a large amount of software that we didn’t write, and may have\nsecurity vulnerabilities that could expose our application, namely our operating systems\nand the other supporting tools we run on them. Here, basic advice can get you a long way.\nStart with only running services as OS users that have as few permissions as possible, to\nensure that if such an account is compromised it will do minimal damage.")]),e._v(" "),n("p",[e._v("Next, patch your software. Regularly. This needs to be automated, and you need to know\nif your machines are out of sync with the latest patch levels. Tools like Microsoft’s SCCM\nor RedHat’s Spacewalk can be beneficial here, as they can help you see if machines are up\nto date with the latest patches and initiate updates if required. If you are using tools like\nAnsible, Puppet, or Chef, chances are you are already fairly happy with pushing out\nchanges automatically — these tools can get you a long way too, but won’t do everything\nfor you.")]),e._v(" "),n("p",[e._v("This really is basic stuff, but it is surprising how often I see critical software running on\nunpatched, old operating systems. You can have the most well-defined and protected\napplication-level security in the world, but if you have an old version of a web server\nrunning on your machine as root that has an unpatched buffer overflow vulnerability, then\nyour system could still be extremely vulnerable.")]),e._v(" "),n("p",[e._v("Another thing to look at if you are using Linux is the emergence of security modules for\nthe operating system itself. AppArmour, for example, allows you to define how your\napplication is expected to behave, with the kernel keeping an eye on it. If it starts doing\nsomething it shouldn’t, the kernel steps in. AppArmour has been around for a while, as\nhas SeLinux. Although technically either of them should work on any modern Linux\nsystem, in practice some distributions support one better than the other. AppArmour is\nused by default in Ubuntu and SuSE, for example, whereas SELinux has traditionally been\nwell supported by RedHat. A newer option is GrSSecurity, which aims to be simpler to\nuse than either AppArmour or GrSecurity while also trying to expand on their capabilities,\nbut it requires a custom kernel to work. I’d suggest taking a look at all three to see which\nfits your use cases best, but I like the idea of having another layer of protection and\nprevention at work.")]),e._v(" "),n("h2",{attrs:{id:"a-worked-example"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#a-worked-example"}},[e._v("#")]),e._v(" A Worked Example")]),e._v(" "),n("p",[e._v("Having a finer-grained system architecture gives us much more freedom in how we\nimplement our security. For those parts that deal with the most sensitive information or\nexpose the most valuable capabilities, we can adopt the strictest security provisions. But\nfor other parts of the system, we can afford to be much more lax in what we worry about.")]),e._v(" "),n("p",[e._v("Let’s consider MusicCorp once again, and pull some of the preceding concepts together to\nsee where and how we might use some of these security techniques. We’re looking\nprimarily at the security concerns of data in transit and at rest. Figure 9-4 shows a subset\nof the overall system that we’ll be analyzing, which currently shows a crushing lack of\nregard for security concerns. Everything is sent over plain old HTTP.")]),e._v(" "),n("p",[n("img",{attrs:{src:a(728),alt:"img"}})]),e._v(" "),n("p",[n("em",[e._v("Figure 9-4. A subset of MusicCorp’s unfortunately insecure architecture")])]),e._v(" "),n("p",[e._v("Here we have standard web browsers that are used by our customers to shop on the site.\nWe also introduce the concept of a third-party royalty gateway: we’ve started working\nwith a third-party company that will handle royalty payments for our new streaming\nservice. It contacts us occasionally to pull down records of what music has been streamed\nwhen — information we jealously protect as we are worried about competition from rival\ncompanies. Finally, we expose our catalog data to other third parties — for example,\nallowing the metadata about artist or song to be embedded in music review sites. Inside\nour network perimeter, we have some collaborating services, which are only ever used\ninternally.")]),e._v(" "),n("p",[e._v("For the browser, we’ll use a mix of standard HTTP traffic for nonsecure content, to allow\nfor it to be cached. For secure, logged-in pages, all secure content will be sent over\nHTTPS, giving our customers extra protection if they are doing things like running on\npublic WiFi networks.")]),e._v(" "),n("p",[e._v("When it comes to the third-party royalty payment system, we are concerned not only about\nthe nature of the data we are exposing, but also about making sure the requests we’re")]),e._v(" "),n("p",[e._v("getting are legitimate. Here, we insist that our third party uses client certificates. All the\ndata is sent over a secure, cryptographic channel, increasing our ability to ensure we’re\nbeing asked for this data by the right person. We do, of course, have to think about what\nhappens when the data leaves our control. Will our partner care about the data as much as\nwe will?")]),e._v(" "),n("p",[e._v("For the feeds of catalog data, we want this information shared as widely as possible to\nallow people to easily buy music from us! However, we don’t want this abused, and we’d\nlike some idea of who is using our data. Here, API keys make perfect sense.")]),e._v(" "),n("p",[e._v("Inside the network perimeter, things are a bit more nuanced. How worried are we about\npeople compromising our internal networks? Ideally, we’d like to use HTTPS at a\nminimum, but managing it is somewhat painful. We decide instead to put the work\n(initially, at least) into hardening our network perimeter, including having a properly\nconfigured firewall and selecting an appropriate hardware or software security appliance\nto check for malicious traffic (e.g., port scanning or denial-of-service attacks).")]),e._v(" "),n("p",[e._v("That said, we are concerned about  "),n("em",[e._v("some")]),e._v("  of our data and where it lives. We aren’t worried\nabout the catalog service; after all, we want that data shared and have provided an API for\nit! But we are very concerned about our customers’ data. Here, we decide to encrypt the\ndata held by the customer service, and decrypt data on read. If attackers do penetrate our\nnetwork, they could still run requests against the customer service’s API, but the current\nimplementation does not allow for the bulk retrieval of customer data. If it did, we would\nlikely consider the use of client certificates to protect this information. Even if attackers\ncompromise the machine the database is running on and manage to download the entire\ncontents, they would need access to the key used to encrypt and decrypt the data to make\nuse if it.")]),e._v(" "),n("p",[e._v("Figure 9-5 shows the final picture. As you can see, the choices we made about what\ntechnology to use were based on an understanding of the nature of the information being\nsecured. Your own architecture’s security concerns are likely to be very different, and so\nyou may end up with a different-looking solution.")]),e._v(" "),n("p",[n("img",{attrs:{src:a(729),alt:"img"}})]),e._v(" "),n("p",[n("em",[e._v("Figure 9-5. MusicCorp’s more secure system")])]),e._v(" "),n("h2",{attrs:{id:"be-frugal"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#be-frugal"}},[e._v("#")]),e._v(" Be Frugal")]),e._v(" "),n("p",[e._v("As disk space becomes cheaper and the capabilities of the databases improve, the ease\nwith which bulk amounts of information can be captured and stored is improving rapidly.\nThis data is valuable — not only to businesses themselves, which increasingly see data as\na valuable asset, but equally to the users who value their own privacy. The data that\npertains to an individual, or could be used to derive information about an individual, must\nbe the data we are most careful about.")]),e._v(" "),n("p",[e._v("However, what if we made our lives a bit easier? Why not scrub as much information as\npossible that can be personally identifiable, and do it as soon as possible? When logging a\nrequest from a user, do we need to store the entire IP address forever, or could we replace\nthe last few digits with  "),n("em",[e._v("x")]),e._v(" ? Do we need to store someone’s name, age, gender, and date of\nbirth in order to provide her with product offers, or is her age range and postcode enough\ninformation?")]),e._v(" "),n("p",[e._v("The advantages here are manifold. First, if you don’t store it, no one can steal it. Second, if\nyou don’t store it, no one (e.g., a governmental agency) can ask for it either!")]),e._v(" "),n("p",[e._v("The German phrase  "),n("em",[e._v("Datensparsamkeit")]),e._v("  represents this concept. Originating from German\nprivacy legislation, it encapsulates the concept of only storing as much information as is\n"),n("em",[e._v("absolutely required")]),e._v("  to fulfill business operations or satisfy local laws.")]),e._v(" "),n("p",[e._v("This is obviously in direct tension with the move toward storing more and more\ninformation, but it is a start to realize that this tension even exists!")]),e._v(" "),n("h2",{attrs:{id:"the-human-element"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#the-human-element"}},[e._v("#")]),e._v(" The Human Element")]),e._v(" "),n("p",[e._v("Much of what we have covered here is the basics of how to implement technological\nsafeguards to protect your systems and data from malicious, external attackers. However,\nyou may also need processes and policies in place to deal with the human element in your\norganization. How do you revoke access to credentials when someone leaves the\norganization? How can you protect yourself against social engineering? As a good mental\nexercise, consider what damage a disgruntled ex-employee could do to your systems if she\nwanted to. Putting yourself in the mindset of a malicious party is often a good way to\nreason about the protections you may need, and few malicious parties have as much inside\ninformation as a recent employee!")]),e._v(" "),n("h2",{attrs:{id:"the-golden-rule"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#the-golden-rule"}},[e._v("#")]),e._v(" The Golden Rule")]),e._v(" "),n("p",[e._v("If there is nothing else you take away from this chapter, let it be this: "),n("strong",[e._v("don’t write your own crypto")]),e._v(". Don’t invent your own security protocols. Unless you are a cryptographic expert\nwith years of experience, if you try inventing your own encoding or elaborate\ncryptographic protections, you will get it wrong. And even  "),n("em",[e._v("if")]),e._v("  you are a cryptographic\nexpert, you may still get it wrong.")]),e._v(" "),n("p",[e._v("Many of the tools previously outlined, like AES, are industry-hardened technologies\nwhose underlying algorithms have been peer reviewed, and whose software\nimplementation has been rigorously tested and patched over many years. They are good\nenough! Reinventing the wheel in many cases is often just a waste of time, but when it\ncomes to security it can be outright dangerous.")]),e._v(" "),n("h2",{attrs:{id:"baking-security-in"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#baking-security-in"}},[e._v("#")]),e._v(" Baking Security In")]),e._v(" "),n("p",[e._v("Just as with automated functional testing, we don’t want security to be left to a different\nset of people, nor do we want to leave everything to the last minute. Helping educate\ndevelopers about security concerns is key, as raising everyone’s general awareness of\nsecurity issues can help reduce them in the first place. Getting people familar with the\nOWASP Top Ten list and OWASP’s Security Testing Framework can be a great place to\nstart. Specialists absolutely have their place, though, and if you have access to them, use\nthem to help you.")]),e._v(" "),n("p",[e._v("There are automated tools that can probe our systems for vulnerabilities, such as by\nlooking for cross-site scripting attacks. The Zed Attack Proxy (aka ZAP) is a good\nexample. Informed by the work of OWASP, ZAP attempts to re-create malicious attacks\non your website. Other tools exist that use static analysis to look for common coding\nmistakes that can open up security holes, such as Brakeman for Ruby. Where these tools\ncan be easily integrated into normal CI builds, integrate them into your standard check-ins.\nOther sorts of automated tests are more involved. For example, using something like\nNessus to scan for vulnerabilities is a bit more involved and it may require a human to\ninterpret the results. That said, these tests are still automatable, and it may make sense to\nrun them with the same sort of cadence as load testing.")]),e._v(" "),n("p",[e._v("Microsoft’s Security Development Lifecycle also has some good models for how delivery\nteams can bake security in. Some aspects of it feel overly waterfall, but take a look and see\nwhat aspects can fit into your current workflow.")]),e._v(" "),n("h2",{attrs:{id:"external-verification"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#external-verification"}},[e._v("#")]),e._v(" External Verification")]),e._v(" "),n("p",[e._v("With security, I think there is great value in having an external assessment done. Exercises\nlike penetration testing, when done by an outside party, really do mimic real-world\nattempts. They also sidestep the issue that teams aren’t always able to see the mistakes\nthey have made themselves, as they are too close to the problem. If you’re a big enough\ncompany, you may have a dedicated infosec team that can help you. If not, find an\nexternal party who can. Reach out to them early, understand how they like to work, and\nfind out how much notice they need to do a test.")]),e._v(" "),n("p",[e._v("You’ll also need to consider how much verification you require before each release.\nGenerally, doing a full penetration test, for example, isn’t needed for small incremental\nreleases, but may be for larger changes. What you need depends on your own risk profile.")]),e._v(" "),n("h2",{attrs:{id:"summary"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#summary"}},[e._v("#")]),e._v(" Summary")]),e._v(" "),n("p",[e._v("So again we return to a core theme of the book — that having a system decomposed into\nfiner-grained services gives us many more options as to how to solve a problem. Not only\ncan having microservices potentially reduce the impact of any given breach, but it also\ngives us more ability to trade off the overhead of more complex and secure approaches\nwhere data is sensitive, and a lighter-weight approach when the risks are lower.")]),e._v(" "),n("p",[e._v("Once you understand the threat levels of different parts of your system, you should start to\nget a sense of when to consider security during transit, at rest, or not at all.")]),e._v(" "),n("p",[e._v("Finally, understand the importance of defense in depth, make sure you patch your\noperating systems, and even if you consider yourself a rock star, don’t try to implement\nyour own cryptography!")]),e._v(" "),n("p",[e._v("If you want a general overview of security for browser-based applications, a great place to\nstart is the excellent Open Web Application Security Project (OWASP) nonprofit, whose\nregularly updated  "),n("em",[e._v("Top 10 Security Risk")]),e._v("  document should be considered essential reading\nfor any developer. Finally, if you want a more general discussion of cryptography, check\nout the book  "),n("em",[e._v("Cryptography Engineering")]),e._v("  by Niels Ferguson, Bruce Schneier, and\nTadayoshi Kohno (Wiley).")]),e._v(" "),n("p",[e._v("Getting to grips with security is often about understanding people and how they work with\nour systems. One human-related aspect we haven’t yet discussed in terms of microservices\nis the interplay between organizational structures and the architectures themselves. But as\nwith security, we’ll see that ignoring the human element can be a grave mistake.")]),e._v(" "),n("p",[e._v("(^3)  In general, key length increases the amount of work required to brute-force-break a key.\nTherefore you can assume the longer the key, the more secure your data. However, some\nminor concerns have been raised about the implementation of AES-256 for certain types\nof keys by respected security expert Bruce Schneier. This is one of those areas where you\nneed to do more research on what the current advice is at the time of reading!")])])}),[],!1,null,null,null);t.default=o.exports},725:function(e,t,a){e.exports=a.p+"assets/img/image--076.79e7d5da.jpg"},726:function(e,t,a){e.exports=a.p+"assets/img/image--077.24802df6.jpg"},727:function(e,t,a){e.exports=a.p+"assets/img/image--078.c30aaee4.jpg"},728:function(e,t,a){e.exports=a.p+"assets/img/image--079.846a5f29.jpg"},729:function(e,t,a){e.exports=a.p+"assets/img/image--080.9c1fad46.jpg"}}]);