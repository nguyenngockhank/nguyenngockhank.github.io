(window.webpackJsonp=window.webpackJsonp||[]).push([[287],{1456:function(e,t,a){"use strict";a.r(t);var s=a(7),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"indexing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#indexing"}},[e._v("#")]),e._v(" Indexing")]),e._v(" "),a("p",[e._v("You can use indexes to locate a piece of data quickly instead of searching for every single row. There are various data structures for indexes")]),e._v(" "),a("p",[e._v("Abstractly, an index is just a sorted table that allows the search to be O(Log N) using binary searching with a sorted data structure.")]),e._v(" "),a("p",[e._v("Internally, an index can be implemented using B-Tree or LSM, which uses Sorted Strings Table (SST). Since an index table is a sorted table with O(Log N) search, the performance will still degrade once the number of records (N) increases.")]),e._v(" "),a("p",[e._v("However, index lookup with O(Log N) is still significantly faster than a full table scan O(N).")]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),a("p",[e._v("Database indexes are not hashmaps. Hashmap is an in-memory data structure. You may implement an in-memory solution on top of the database, but the index stored on disk isnâ€™t a hashmap.")])]),e._v(" "),a("p",[e._v("LSM = Log-structured merge-tree\nB-Tree = Binary Tre")]),e._v(" "),a("h2",{attrs:{id:"cardinality"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cardinality"}},[e._v("#")]),e._v(" Cardinality")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://i.pinimg.com/originals/06/b6/2b/06b62b6acb0010624e641b517cf96efd.jpg",alt:"Cardinality"}})]),e._v(" "),a("p",[e._v("Cardinality refers to the number of unique values in a column relative to a table's total number of rows.")]),e._v(" "),a("ul",[a("li",[a("strong",[e._v("High Cardinality")]),e._v(" means the column has many unique values.")]),e._v(" "),a("li",[a("strong",[e._v("Low Cardinality")]),e._v(" means the column has few unique values.")])]),e._v(" "),a("p",[e._v("Creating an index on a column with low Cardinality is most of the time ineffective because:")]),e._v(" "),a("ol",[a("li",[e._v("Low Cardinality means each indexed value points to many rows, reducing the index's ability to narrow down the search.")]),e._v(" "),a("li",[e._v("Maintaining an index has a cost of storage and update time. For low cardinality columns, this overhead might outweigh the benefits.")]),e._v(" "),a("li",[e._v("Database query optimizers are smart; they know column statistics, including Cardinality. When they detect a low cardinality index, they often ignore it and perform a "),a("strong",[e._v("full table scan")]),e._v(" instead.")])]),e._v(" "),a("p",[a("strong",[e._v("When to consider a Low Cardinality column?")])]),e._v(" "),a("p",[e._v("There are scenarios where indexing a low cardinality column might be beneficial.")]),e._v(" "),a("p",[e._v("For example, combining low and high cardinality columns can be effective.")]),e._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("CREATE")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("INDEX")]),e._v(" idx_dept_emp "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("ON")]),e._v(" Employees"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("Department"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" ID"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("h2",{attrs:{id:"why-isn-t-a-trie-index-used-in-databases-for-string-indexing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#why-isn-t-a-trie-index-used-in-databases-for-string-indexing"}},[e._v("#")]),e._v(" Why isn't a trie index used in databases for string indexing?")]),e._v(" "),a("p",[e._v("Disks or SSDs are read in blocks, and the B+Tree indexes that databases use are optimized according to that structure. The B+Tree minimizes the average number of blocks you have to read to perform a lookup. They also allow you to update the index without changing too many blocks, and maximize the utility of cache.")]),e._v(" "),a("p",[e._v("Tries don't have these advantages. The one advantage they do provide is compressed storage of common prefixes, but for the short strings that are usually used as DB keys, that isn't much of an advantage. Sometimes specialized index structures are built to compress common prefixes, but again they're designed around the block structure of the storage.")]),e._v(" "),a("p",[a("a",{attrs:{href:"https://stackoverflow.com/questions/70472468/why-isnt-a-trie-index-used-in-databases-for-string-indexing",target:"_blank",rel:"noopener noreferrer"}},[e._v("Original Post"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);