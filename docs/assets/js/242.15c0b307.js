(window.webpackJsonp=window.webpackJsonp||[]).push([[242],{809:function(e,r,t){"use strict";t.r(r);var n=t(7),a=Object(n.a)({},(function(){var e=this,r=e.$createElement,t=e._self._c||r;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_14-successive-refinement"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_14-successive-refinement"}},[e._v("#")]),e._v(" 14. Successive Refinement")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Case Study of a Command-Line Argument Parser\n")])])]),t("p",[e._v("This chapter is a case study in successive refinement. You will see a module that started\nwell but did not scale. Then you will see how the module was refactored and cleaned.")]),e._v(" "),t("p",[e._v("Most of us have had to parse command-line arguments from time to time. If we\ndon’t have a convenient utility, then we simply walk the array of strings that is passed\ninto the mainfunction. There are several good utilities available from various sources,")]),e._v(" "),t("p",[e._v("194 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("p",[e._v("but none of them do exactly what I want. So, of course, I decided to write my own. I call\nit:Args.")]),e._v(" "),t("p",[e._v("Argsis very simple to use. You simply construct the Argsclass with the input argu-\nments and a format string, and then query the Argsinstance for the values of the argu-\nments. Consider the following simple example:")]),e._v(" "),t("p",[e._v("You can see how simple this is. We just create an instance of the Argsclass with two\nparameters. The first parameter is the format, or "),t("em",[e._v("schema,")]),e._v(' string: "l,p#,d*." It defines three\ncommand-line arguments. The first, –l, is a boolean argument. The second, -p, is an integer\nargument. The third, -d, is a string argument. The second parameter to the Argsconstructor\nis simply the array of command-line argument passed into main.')]),e._v(" "),t("p",[e._v("If the constructor returns without throwing an ArgsException, then the incoming\ncommand-line was parsed, and the Argsinstance is ready to be queried. Methods like\ngetBoolean,getInteger, and getStringallow us to access the values of the arguments by\ntheir names.")]),e._v(" "),t("p",[e._v("If there is a problem, either in the format string or in the command-line arguments\nthemselves, an ArgsExceptionwill be thrown. A convenient description of what went\nwrong can be retrieved from the errorMessage method of the exception.")]),e._v(" "),t("h2",{attrs:{id:"args-implementation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#args-implementation"}},[e._v("#")]),e._v(" Args Implementation")]),e._v(" "),t("p",[e._v("Listing 14-2 is the implementation of the Argsclass. Please read it very carefully. I worked\nhard on the style and structure and hope it is worth emulating.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-1\nSimple use of Args\npublic static void main(String[] args) {\ntry {\nArgs arg = new Args(\"l,p#,d*\", args);\nboolean logging = arg.getBoolean('l');\nint port = arg.getInt('p');\nString directory = arg.getString('d');\nexecuteApplication(logging, port, directory);\n} catch (ArgsException e) {\nSystem.out.printf(\"Argument error: %s\\n\", e.errorMessage());\n}\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-2\nArgs.java\npackage com.objectmentor.utilities.args;\nimport static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;\nimport java.util.*;\npublic class Args {\nprivate Map<Character, ArgumentMarshaler> marshalers;\n")])])]),t("p",[t("strong",[e._v("Args Implementation")]),e._v(" 195")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('private Set<Character> argsFound;\nprivate ListIterator<String> currentArgument;\npublic Args(String schema, String[] args) throws ArgsException {\nmarshalers = new HashMap<Character, ArgumentMarshaler>();\nargsFound = new HashSet<Character>();\nparseSchema(schema);\nparseArgumentStrings(Arrays.asList(args));\n}\nprivate void parseSchema(String schema) throws ArgsException {\nfor (String element : schema.split(","))\nif (element.length() > 0)\nparseSchemaElement(element.trim());\n}\nprivate void parseSchemaElement(String element) throws ArgsException {\nchar elementId = element.charAt(0);\nString elementTail = element.substring(1);\nvalidateSchemaElementId(elementId);\nif (elementTail.length() == 0)\nmarshalers.put(elementId, new BooleanArgumentMarshaler());\nelse if (elementTail.equals("*"))\nmarshalers.put(elementId, new StringArgumentMarshaler());\nelse if (elementTail.equals("#"))\nmarshalers.put(elementId, new IntegerArgumentMarshaler());\nelse if (elementTail.equals("##"))\nmarshalers.put(elementId, new DoubleArgumentMarshaler());\nelse if (elementTail.equals("[*]"))\nmarshalers.put(elementId, new StringArrayArgumentMarshaler());\nelse\nthrow new ArgsException(INVALID_ARGUMENT_FORMAT, elementId, elementTail);\n}\nprivate void validateSchemaElementId(char elementId) throws ArgsException {\nif (!Character.isLetter(elementId))\nthrow new ArgsException(INVALID_ARGUMENT_NAME, elementId, null);\n}\nprivate void parseArgumentStrings(List<String> argsList) throws ArgsException\n{\nfor (currentArgument = argsList.listIterator(); currentArgument.hasNext();)\n{\nString argString = currentArgument.next();\nif (argString.startsWith("-")) {\nparseArgumentCharacters(argString.substring(1));\n} else {\ncurrentArgument.previous();\nbreak;\n}\n}\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-2 (continued)\nArgs.java\n")])])]),t("p",[e._v("196 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("p",[e._v("Notice that you can read this code from the top to the bottom without a lot of jumping\naround or looking ahead. The one thing you may have had to look ahead for is the defini-\ntion of ArgumentMarshaler, which I left out intentionally. Having read this code carefully,")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private void parseArgumentCharacters(String argChars) throws ArgsException {\nfor (int i = 0; i < argChars.length(); i++)\nparseArgumentCharacter(argChars.charAt(i));\n}\nprivate void parseArgumentCharacter(char argChar) throws ArgsException {\nArgumentMarshaler m = marshalers.get(argChar);\nif (m == null) {\nthrow new ArgsException(UNEXPECTED_ARGUMENT, argChar, null);\n} else {\nargsFound.add(argChar);\ntry {\nm.set(currentArgument);\n} catch (ArgsException e) {\ne.setErrorArgumentId(argChar);\nthrow e;\n}\n}\n}\npublic boolean has(char arg) {\nreturn argsFound.contains(arg);\n}\npublic int nextArgument() {\nreturn currentArgument.nextIndex();\n}\npublic boolean getBoolean(char arg) {\nreturn BooleanArgumentMarshaler.getValue(marshalers.get(arg));\n}\npublic String getString(char arg) {\nreturn StringArgumentMarshaler.getValue(marshalers.get(arg));\n}\npublic int getInt(char arg) {\nreturn IntegerArgumentMarshaler.getValue(marshalers.get(arg));\n}\npublic double getDouble(char arg) {\nreturn DoubleArgumentMarshaler.getValue(marshalers.get(arg));\n}\npublic String[] getStringArray(char arg) {\nreturn StringArrayArgumentMarshaler.getValue(marshalers.get(arg));\n}\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-2 (continued)\nArgs.java\n")])])]),t("p",[t("strong",[e._v("Args Implementation")]),e._v(" 197")]),e._v(" "),t("p",[e._v("you should understand what the ArgumentMarshalerinterface is and what its derivatives do.\nI’ll show a few of them to you now (Listing 14-3 through Listing 14-6).")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-3\nArgumentMarshaler.java\npublic interface ArgumentMarshaler {\nvoid set(Iterator<String> currentArgument) throws ArgsException;\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-4\nBooleanArgumentMarshaler.java\npublic class BooleanArgumentMarshaler implements ArgumentMarshaler {\nprivate boolean booleanValue = false;\npublic void set(Iterator<String> currentArgument) throws ArgsException {\nbooleanValue = true;\n}\npublic static boolean getValue(ArgumentMarshaler am) {\nif (am != null && am instanceof BooleanArgumentMarshaler)\nreturn ((BooleanArgumentMarshaler) am).booleanValue;\nelse\nreturn false;\n}\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('Listing 14-5\nStringArgumentMarshaler.java\nimport static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;\npublic class StringArgumentMarshaler implements ArgumentMarshaler {\nprivate String stringValue = "";\npublic void set(Iterator<String> currentArgument) throws ArgsException {\ntry {\nstringValue = currentArgument.next();\n} catch (NoSuchElementException e) {\nthrow new ArgsException(MISSING_STRING);\n}\n}\npublic static String getValue(ArgumentMarshaler am) {\nif (am != null && am instanceof StringArgumentMarshaler)\nreturn ((StringArgumentMarshaler) am).stringValue;\nelse\nreturn "";\n}\n}\n')])])]),t("p",[e._v("198 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("p",[e._v("The other ArgumentMarshalerderivatives simply replicate this pattern for doublesand\nString arrays and would serve to clutter this chapter. I’ll leave them to you as an exercise.")]),e._v(" "),t("p",[e._v("One other bit of information might be troubling you: the definition of the error code\nconstants. They are in the ArgsException class (Listing 14-7).")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-6\nIntegerArgumentMarshaler.java\nimport static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;\npublic class IntegerArgumentMarshaler implements ArgumentMarshaler {\nprivate int intValue = 0;\npublic void set(Iterator<String> currentArgument) throws ArgsException {\nString parameter = null;\ntry {\nparameter = currentArgument.next();\nintValue = Integer.parseInt(parameter);\n} catch (NoSuchElementException e) {\nthrow new ArgsException(MISSING_INTEGER);\n} catch (NumberFormatException e) {\nthrow new ArgsException(INVALID_INTEGER, parameter);\n}\n}\npublic static int getValue(ArgumentMarshaler am) {\nif (am != null && am instanceof IntegerArgumentMarshaler)\nreturn ((IntegerArgumentMarshaler) am).intValue;\nelse\nreturn 0;\n}\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-7\nArgsException.java\nimport static com.objectmentor.utilities.args.ArgsException.ErrorCode.*;\npublic class ArgsException extends Exception {\nprivate char errorArgumentId = '\\0';\nprivate String errorParameter = null;\nprivate ErrorCode errorCode = OK;\npublic ArgsException() {}\npublic ArgsException(String message) {super(message);}\npublic ArgsException(ErrorCode errorCode) {\nthis.errorCode = errorCode;\n}\npublic ArgsException(ErrorCode errorCode, String errorParameter) {\nthis.errorCode = errorCode;\nthis.errorParameter = errorParameter;\n}\n")])])]),t("p",[t("strong",[e._v("Args Implementation")]),e._v(" 199")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public ArgsException(ErrorCode errorCode,\nchar errorArgumentId, String errorParameter) {\nthis.errorCode = errorCode;\nthis.errorParameter = errorParameter;\nthis.errorArgumentId = errorArgumentId;\n}\npublic char getErrorArgumentId() {\nreturn errorArgumentId;\n}\npublic void setErrorArgumentId(char errorArgumentId) {\nthis.errorArgumentId = errorArgumentId;\n}\npublic String getErrorParameter() {\nreturn errorParameter;\n}\npublic void setErrorParameter(String errorParameter) {\nthis.errorParameter = errorParameter;\n}\npublic ErrorCode getErrorCode() {\nreturn errorCode;\n}\npublic void setErrorCode(ErrorCode errorCode) {\nthis.errorCode = errorCode;\n}\npublic String errorMessage() {\nswitch (errorCode) {\ncase OK:\nreturn "TILT: Should not get here.";\ncase UNEXPECTED_ARGUMENT:\nreturn String.format("Argument -%c unexpected.", errorArgumentId);\ncase MISSING_STRING:\nreturn String.format("Could not find string parameter for -%c.",\nerrorArgumentId);\ncase INVALID_INTEGER:\nreturn String.format("Argument -%c expects an integer but was \'%s\'.",\nerrorArgumentId, errorParameter);\ncase MISSING_INTEGER:\nreturn String.format("Could not find integer parameter for -%c.",\nerrorArgumentId);\ncase INVALID_DOUBLE:\nreturn String.format("Argument -%c expects a double but was \'%s\'.",\nerrorArgumentId, errorParameter);\ncase MISSING_DOUBLE:\nreturn String.format("Could not find double parameter for -%c.",\nerrorArgumentId);\ncase INVALID_ARGUMENT_NAME:\nreturn String.format("\'%c\' is not a valid argument name.",\nerrorArgumentId);\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-7 (continued)\nArgsException.java\n")])])]),t("p",[e._v("200 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("p",[e._v("It’s remarkable how much code is required to flesh out the details of this simple con-\ncept. One of the reasons for this is that we are using a particularly wordy language. Java,\nbeing a statically typed language, requires a lot of words in order to satisfy the type sys-\ntem. In a language like Ruby, Python, or Smalltalk, this program is much smaller.^1")]),e._v(" "),t("p",[e._v("Please read the code over one more time. Pay special attention to the way things are\nnamed, the size of the functions, and the formatting of the code. If you are an experienced\nprogrammer, you may have some quibbles here and there with various parts of the style or\nstructure. Overall, however, I hope you conclude that this program is nicely written and\nhas a clean structure.")]),e._v(" "),t("p",[e._v("For example, it should be obvious how you would add a new argument type, such as a\ndate argument or a complex number argument, and that such an addition would require a\ntrivial amount of effort. In short, it would simply require a new derivative of Argument-\nMarshaler, a new getXXXfunction, and a new case statement in the parseSchemaElement\nfunction. There would also probably be a new ArgsException.ErrorCodeand a new error\nmessage.")]),e._v(" "),t("h3",{attrs:{id:"how-did-i-do-this"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#how-did-i-do-this"}},[e._v("#")]),e._v(" How Did I Do This? ...")]),e._v(" "),t("p",[e._v("Let me set your mind at rest. I did not simply write this program from beginning to end in\nits current form. More importantly, I am not expecting you to be able to write clean and\nelegant programs in one pass. If we have learned anything over the last couple of decades,\nit is that programming is a craft more than it is a science. To write clean code, you must\nfirst write dirty code "),t("em",[e._v("and then clean it")]),e._v(".")]),e._v(" "),t("p",[e._v("This should not be a surprise to you. We learned this truth in grade school when our\nteachers tried (usually in vain) to get us to write rough drafts of our compositions. The\nprocess, they told us, was that we should write a rough draft, then a second draft, then sev-\neral subsequent drafts until we had our final version. Writing clean compositions, they\ntried to tell us, is a matter of successive refinement.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('case INVALID_ARGUMENT_FORMAT:\nreturn String.format("\'%s\' is not a valid argument format.",\nerrorParameter);\n}\nreturn "";\n}\npublic enum ErrorCode {\nOK, INVALID_ARGUMENT_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME,\nMISSING_STRING,\nMISSING_INTEGER, INVALID_INTEGER,\nMISSING_DOUBLE, INVALID_DOUBLE}\n}\n')])])]),t("ol",[t("li",[e._v("I recently rewrote this module in Ruby. It was 1/7th the size and had a subtly better structure.")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-7 (continued)\nArgsException.java\n")])])]),t("p",[t("strong",[e._v("Args: The Rough Draft")]),e._v(" 201")]),e._v(" "),t("p",[e._v("Most freshman programmers (like most grade-schoolers) don’t follow this advice par-\nticularly well. They believe that the primary goal is to get the program working. Once it’s\n“working,” they move on to the next task, leaving the “working” program in whatever state\nthey finally got it to “work.” Most seasoned programmers know that this is professional\nsuicide.")]),e._v(" "),t("h2",{attrs:{id:"args-the-rough-draft"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#args-the-rough-draft"}},[e._v("#")]),e._v(" Args: The Rough Draft .")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-8 shows an earlier version of the Args class. It “works.” And it’s messy.\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('Listing 14-8\nArgs.java (first draft)\nimport java.text.ParseException;\nimport java.util.*;\npublic class Args {\nprivate String schema;\nprivate String[] args;\nprivate boolean valid = true;\nprivate Set<Character> unexpectedArguments = new TreeSet<Character>();\nprivate Map<Character, Boolean> booleanArgs =\nnew HashMap<Character, Boolean>();\nprivate Map<Character, String> stringArgs = new HashMap<Character, String>();\nprivate Map<Character, Integer> intArgs = new HashMap<Character, Integer>();\nprivate Set<Character> argsFound = new HashSet<Character>();\nprivate int currentArgument;\nprivate char errorArgumentId = \'\\0\';\nprivate String errorParameter = "TILT";\nprivate ErrorCode errorCode = ErrorCode.OK;\nprivate enum ErrorCode {\nOK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT}\npublic Args(String schema, String[] args) throws ParseException {\nthis.schema = schema;\nthis.args = args;\nvalid = parse();\n}\nprivate boolean parse() throws ParseException {\nif (schema.length() == 0 && args.length == 0)\nreturn true;\nparseSchema();\ntry {\nparseArguments();\n} catch (ArgsException e) {\n}\nreturn valid;\n}\nprivate boolean parseSchema() throws ParseException {\nfor (String element : schema.split(",")) {\n')])])]),t("p",[e._v("202 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('if (element.length() > 0) {\nString trimmedElement = element.trim();\nparseSchemaElement(trimmedElement);\n}\n}\nreturn true;\n}\nprivate void parseSchemaElement(String element) throws ParseException {\nchar elementId = element.charAt(0);\nString elementTail = element.substring(1);\nvalidateSchemaElementId(elementId);\nif (isBooleanSchemaElement(elementTail))\nparseBooleanSchemaElement(elementId);\nelse if (isStringSchemaElement(elementTail))\nparseStringSchemaElement(elementId);\nelse if (isIntegerSchemaElement(elementTail)) {\nparseIntegerSchemaElement(elementId);\n} else {\nthrow new ParseException(\nString.format("Argument: %c has invalid format: %s.",\nelementId, elementTail), 0);\n}\n}\nprivate void validateSchemaElementId(char elementId) throws ParseException {\nif (!Character.isLetter(elementId)) {\nthrow new ParseException(\n"Bad character:" + elementId + "in Args format: " + schema, 0);\n}\n}\nprivate void parseBooleanSchemaElement(char elementId) {\nbooleanArgs.put(elementId, false);\n}\nprivate void parseIntegerSchemaElement(char elementId) {\nintArgs.put(elementId, 0);\n}\nprivate void parseStringSchemaElement(char elementId) {\nstringArgs.put(elementId, "");\n}\nprivate boolean isStringSchemaElement(String elementTail) {\nreturn elementTail.equals("*");\n}\nprivate boolean isBooleanSchemaElement(String elementTail) {\nreturn elementTail.length() == 0;\n}\nprivate boolean isIntegerSchemaElement(String elementTail) {\nreturn elementTail.equals("#");\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-8 (continued)\nArgs.java (first draft)\n")])])]),t("p",[t("strong",[e._v("Args: The Rough Draft")]),e._v(" 203")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('private boolean parseArguments() throws ArgsException {\nfor (currentArgument = 0; currentArgument < args.length; currentArgument++)\n{\nString arg = args[currentArgument];\nparseArgument(arg);\n}\nreturn true;\n}\nprivate void parseArgument(String arg) throws ArgsException {\nif (arg.startsWith("-"))\nparseElements(arg);\n}\nprivate void parseElements(String arg) throws ArgsException {\nfor (int i = 1; i < arg.length(); i++)\nparseElement(arg.charAt(i));\n}\nprivate void parseElement(char argChar) throws ArgsException {\nif (setArgument(argChar))\nargsFound.add(argChar);\nelse {\nunexpectedArguments.add(argChar);\nerrorCode = ErrorCode.UNEXPECTED_ARGUMENT;\nvalid = false;\n}\n}\nprivate boolean setArgument(char argChar) throws ArgsException {\nif (isBooleanArg(argChar))\nsetBooleanArg(argChar, true);\nelse if (isStringArg(argChar))\nsetStringArg(argChar);\nelse if (isIntArg(argChar))\nsetIntArg(argChar);\nelse\nreturn false;\nreturn true;\n}\nprivate boolean isIntArg(char argChar) {return intArgs.containsKey(argChar);}\nprivate void setIntArg(char argChar) throws ArgsException {\ncurrentArgument++;\nString parameter = null;\ntry {\nparameter = args[currentArgument];\nintArgs.put(argChar, new Integer(parameter));\n} catch (ArrayIndexOutOfBoundsException e) {\nvalid = false;\nerrorArgumentId = argChar;\nerrorCode = ErrorCode.MISSING_INTEGER;\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-8 (continued)\nArgs.java (first draft)\n")])])]),t("p",[e._v("204 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('throw new ArgsException();\n} catch (NumberFormatException e) {\nvalid = false;\nerrorArgumentId = argChar;\nerrorParameter = parameter;\nerrorCode = ErrorCode.INVALID_INTEGER;\nthrow new ArgsException();\n}\n}\nprivate void setStringArg(char argChar) throws ArgsException {\ncurrentArgument++;\ntry {\nstringArgs.put(argChar, args[currentArgument]);\n} catch (ArrayIndexOutOfBoundsException e) {\nvalid = false;\nerrorArgumentId = argChar;\nerrorCode = ErrorCode.MISSING_STRING;\nthrow new ArgsException();\n}\n}\nprivate boolean isStringArg(char argChar) {\nreturn stringArgs.containsKey(argChar);\n}\nprivate void setBooleanArg(char argChar, boolean value) {\nbooleanArgs.put(argChar, value);\n}\nprivate boolean isBooleanArg(char argChar) {\nreturn booleanArgs.containsKey(argChar);\n}\npublic int cardinality() {\nreturn argsFound.size();\n}\npublic String usage() {\nif (schema.length() > 0)\nreturn "-[" + schema + "]";\nelse\nreturn "";\n}\npublic String errorMessage() throws Exception {\nswitch (errorCode) {\ncase OK:\nthrow new Exception("TILT: Should not get here.");\ncase UNEXPECTED_ARGUMENT:\nreturn unexpectedArgumentMessage();\ncase MISSING_STRING:\nreturn String.format("Could not find string parameter for -%c.",\nerrorArgumentId);\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-8 (continued)\nArgs.java (first draft)\n")])])]),t("p",[t("strong",[e._v("Args: The Rough Draft")]),e._v(" 205")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('case INVALID_INTEGER:\nreturn String.format("Argument -%c expects an integer but was \'%s\'.",\nerrorArgumentId, errorParameter);\ncase MISSING_INTEGER:\nreturn String.format("Could not find integer parameter for -%c.",\nerrorArgumentId);\n}\nreturn "";\n}\nprivate String unexpectedArgumentMessage() {\nStringBuffer message = new StringBuffer("Argument(s) -");\nfor (char c : unexpectedArguments) {\nmessage.append(c);\n}\nmessage.append(" unexpected.");\nreturn message.toString();\n}\nprivate boolean falseIfNull(Boolean b) {\nreturn b != null && b;\n}\nprivate int zeroIfNull(Integer i) {\nreturn i == null? 0 : i;\n}\nprivate String blankIfNull(String s) {\nreturn s == null? "" : s;\n}\npublic String getString(char arg) {\nreturn blankIfNull(stringArgs.get(arg));\n}\npublic int getInt(char arg) {\nreturn zeroIfNull(intArgs.get(arg));\n}\npublic boolean getBoolean(char arg) {\nreturn falseIfNull(booleanArgs.get(arg));\n}\npublic boolean has(char arg) {\nreturn argsFound.contains(arg);\n}\npublic boolean isValid() {\nreturn valid;\n}\nprivate class ArgsException extends Exception {\n}\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-8 (continued)\nArgs.java (first draft)\n")])])]),t("p",[e._v("206 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("p",[e._v("I hope your initial reaction to this mass of code is “I’m certainly glad he didn’t leave it\nlike that!” If you feel like this, then remember that’s how other people are going to feel\nabout code that you leave in rough-draft form.")]),e._v(" "),t("p",[e._v("Actually “rough draft” is probably the kindest thing you can say about this code. It’s\nclearly a work in progress. The sheer number of instance variables is daunting. The odd\nstrings like “TILT,”theHashSetsandTreeSets, and the try-catch-catchblocks all add up to\na festering pile.")]),e._v(" "),t("p",[e._v("I had not wanted to write a festering pile. Indeed, I was trying to keep things reason-\nably well organized. You can probably tell that from my choice of function and variable\nnames and the fact that there is a crude structure to the program. But, clearly, I had let the\nproblem get away from me.")]),e._v(" "),t("p",[e._v("The mess built gradually. Earlier versions had not been nearly so nasty. For example,\nListing 14-9 shows an earlier version in which only Boolean arguments were working.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('Listing 14-9\nArgs.java (Boolean only)\npackage com.objectmentor.utilities.getopts;\nimport java.util.*;\npublic class Args {\nprivate String schema;\nprivate String[] args;\nprivate boolean valid;\nprivate Set<Character> unexpectedArguments = new TreeSet<Character>();\nprivate Map<Character, Boolean> booleanArgs =\nnew HashMap<Character, Boolean>();\nprivate int numberOfArguments = 0;\npublic Args(String schema, String[] args) {\nthis.schema = schema;\nthis.args = args;\nvalid = parse();\n}\npublic boolean isValid() {\nreturn valid;\n}\nprivate boolean parse() {\nif (schema.length() == 0 && args.length == 0)\nreturn true;\nparseSchema();\nparseArguments();\nreturn unexpectedArguments.size() == 0;\n}\nprivate boolean parseSchema() {\nfor (String element : schema.split(",")) {\nparseSchemaElement(element);\n}\n')])])]),t("p",[t("strong",[e._v("Args: The Rough Draft")]),e._v(" 207")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('return true;\n}\nprivate void parseSchemaElement(String element) {\nif (element.length() == 1) {\nparseBooleanSchemaElement(element);\n}\n}\nprivate void parseBooleanSchemaElement(String element) {\nchar c = element.charAt(0);\nif (Character.isLetter(c)) {\nbooleanArgs.put(c, false);\n}\n}\nprivate boolean parseArguments() {\nfor (String arg : args)\nparseArgument(arg);\nreturn true;\n}\nprivate void parseArgument(String arg) {\nif (arg.startsWith("-"))\nparseElements(arg);\n}\nprivate void parseElements(String arg) {\nfor (int i = 1; i < arg.length(); i++)\nparseElement(arg.charAt(i));\n}\nprivate void parseElement(char argChar) {\nif (isBoolean(argChar)) {\nnumberOfArguments++;\nsetBooleanArg(argChar, true);\n} else\nunexpectedArguments.add(argChar);\n}\nprivate void setBooleanArg(char argChar, boolean value) {\nbooleanArgs.put(argChar, value);\n}\nprivate boolean isBoolean(char argChar) {\nreturn booleanArgs.containsKey(argChar);\n}\npublic int cardinality() {\nreturn numberOfArguments;\n}\npublic String usage() {\nif (schema.length() > 0)\nreturn "-["+schema+"]";\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-9 (continued)\nArgs.java (Boolean only)\n")])])]),t("p",[e._v("208 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("p",[e._v("Although you can find plenty to complain about in this code, it’s really not that bad.\nIt’s compact and simple and easy to understand. However, within this code it is easy to see\nthe seeds of the later festering pile. It’s quite clear how this grew into the latter mess.")]),e._v(" "),t("p",[e._v("Notice that the latter mess has only two more argument types than this: Stringand\ninteger. The addition of just two more argument types had a massively negative impact on\nthe code. It converted it from something that would have been reasonably maintainable\ninto something that I would expect to become riddled with bugs and warts.")]),e._v(" "),t("p",[e._v("I added the two argument types incrementally. First, I added the Stringargument,\nwhich yielded this:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('else\nreturn "";\n}\npublic String errorMessage() {\nif (unexpectedArguments.size() > 0) {\nreturn unexpectedArgumentMessage();\n} else\nreturn "";\n}\nprivate String unexpectedArgumentMessage() {\nStringBuffer message = new StringBuffer("Argument(s) -");\nfor (char c : unexpectedArguments) {\nmessage.append(c);\n}\nmessage.append(" unexpected.");\nreturn message.toString();\n}\npublic boolean getBoolean(char arg) {\nreturn booleanArgs.get(arg);\n}\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-10\nArgs.java (Boolean and String)\npackage com.objectmentor.utilities.getopts;\nimport java.text.ParseException;\nimport java.util.*;\npublic class Args {\nprivate String schema;\nprivate String[] args;\nprivate boolean valid = true;\nprivate Set<Character> unexpectedArguments = new TreeSet<Character>();\nprivate Map<Character, Boolean> booleanArgs =\nnew HashMap<Character, Boolean>();\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-9 (continued)\nArgs.java (Boolean only)\n")])])]),t("p",[t("strong",[e._v("Args: The Rough Draft")]),e._v(" 209")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('private Map<Character, String> stringArgs =\nnew HashMap<Character, String>();\nprivate Set<Character> argsFound = new HashSet<Character>();\nprivate int currentArgument;\nprivate char errorArgument = \'\\0\';\nenum ErrorCode {\nOK, MISSING_STRING}\nprivate ErrorCode errorCode = ErrorCode.OK;\npublic Args(String schema, String[] args) throws ParseException {\nthis.schema = schema;\nthis.args = args;\nvalid = parse();\n}\nprivate boolean parse() throws ParseException {\nif (schema.length() == 0 && args.length == 0)\nreturn true;\nparseSchema();\nparseArguments();\nreturn valid;\n}\nprivate boolean parseSchema() throws ParseException {\nfor (String element : schema.split(",")) {\nif (element.length() > 0) {\nString trimmedElement = element.trim();\nparseSchemaElement(trimmedElement);\n}\n}\nreturn true;\n}\nprivate void parseSchemaElement(String element) throws ParseException {\nchar elementId = element.charAt(0);\nString elementTail = element.substring(1);\nvalidateSchemaElementId(elementId);\nif (isBooleanSchemaElement(elementTail))\nparseBooleanSchemaElement(elementId);\nelse if (isStringSchemaElement(elementTail))\nparseStringSchemaElement(elementId);\n}\nprivate void validateSchemaElementId(char elementId) throws ParseException {\nif (!Character.isLetter(elementId)) {\nthrow new ParseException(\n"Bad character:" + elementId + "in Args format: " + schema, 0);\n}\n}\nprivate void parseStringSchemaElement(char elementId) {\nstringArgs.put(elementId, "");\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-10 (continued)\nArgs.java (Boolean and String)\n")])])]),t("p",[e._v("210 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('private boolean isStringSchemaElement(String elementTail) {\nreturn elementTail.equals("*");\n}\nprivate boolean isBooleanSchemaElement(String elementTail) {\nreturn elementTail.length() == 0;\n}\nprivate void parseBooleanSchemaElement(char elementId) {\nbooleanArgs.put(elementId, false);\n}\nprivate boolean parseArguments() {\nfor (currentArgument = 0; currentArgument < args.length; currentArgument++)\n{\nString arg = args[currentArgument];\nparseArgument(arg);\n}\nreturn true;\n}\nprivate void parseArgument(String arg) {\nif (arg.startsWith("-"))\nparseElements(arg);\n}\nprivate void parseElements(String arg) {\nfor (int i = 1; i < arg.length(); i++)\nparseElement(arg.charAt(i));\n}\nprivate void parseElement(char argChar) {\nif (setArgument(argChar))\nargsFound.add(argChar);\nelse {\nunexpectedArguments.add(argChar);\nvalid = false;\n}\n}\nprivate boolean setArgument(char argChar) {\nboolean set = true;\nif (isBoolean(argChar))\nsetBooleanArg(argChar, true);\nelse if (isString(argChar))\nsetStringArg(argChar, "");\nelse\nset = false;\nreturn set;\n}\nprivate void setStringArg(char argChar, String s) {\ncurrentArgument++;\ntry {\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-10 (continued)\nArgs.java (Boolean and String)\n")])])]),t("p",[t("strong",[e._v("Args: The Rough Draft")]),e._v(" 211")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('stringArgs.put(argChar, args[currentArgument]);\n} catch (ArrayIndexOutOfBoundsException e) {\nvalid = false;\nerrorArgument = argChar;\nerrorCode = ErrorCode.MISSING_STRING;\n}\n}\nprivate boolean isString(char argChar) {\nreturn stringArgs.containsKey(argChar);\n}\nprivate void setBooleanArg(char argChar, boolean value) {\nbooleanArgs.put(argChar, value);\n}\nprivate boolean isBoolean(char argChar) {\nreturn booleanArgs.containsKey(argChar);\n}\npublic int cardinality() {\nreturn argsFound.size();\n}\npublic String usage() {\nif (schema.length() > 0)\nreturn "-[" + schema + "]";\nelse\nreturn "";\n}\npublic String errorMessage() throws Exception {\nif (unexpectedArguments.size() > 0) {\nreturn unexpectedArgumentMessage();\n} else\nswitch (errorCode) {\ncase MISSING_STRING:\nreturn String.format("Could not find string parameter for -%c.",\nerrorArgument);\ncase OK:\nthrow new Exception("TILT: Should not get here.");\n}\nreturn "";\n}\nprivate String unexpectedArgumentMessage() {\nStringBuffer message = new StringBuffer("Argument(s) -");\nfor (char c : unexpectedArguments) {\nmessage.append(c);\n}\nmessage.append(" unexpected.");\nreturn message.toString();\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-10 (continued)\nArgs.java (Boolean and String)\n")])])]),t("p",[e._v("212 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("p",[e._v("You can see that this is starting to get out of hand. It’s still not horrible, but the mess is\ncertainly starting to grow. It’s a pile, but it’s not festering quite yet. It took the addition of\nthe integer argument type to get this pile really fermenting and festering.")]),e._v(" "),t("h3",{attrs:{id:"so-i-stopped"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#so-i-stopped"}},[e._v("#")]),e._v(" So I Stopped ...")]),e._v(" "),t("p",[e._v("I had at least two more argument types to add, and I could tell that they would make things\nmuch worse. If I bulldozed my way forward, I could probably get them to work, but I’d\nleave behind a mess that was too large to fix. If the structure of this code was ever going to\nbe maintainable, now was the time to fix it.")]),e._v(" "),t("p",[e._v("So I stopped adding features and started refactoring. Having just added the Stringand\nintegerarguments, I knew that each argument type required new code in three major\nplaces. First, each argument type required some way to parse its schema element in order\nto select the HashMapfor that type. Next, each argument type needed to be parsed in the\ncommand-line strings and converted to its true type. Finally, each argument type needed a\ngetXXX method so that it could be returned to the caller as its true type.")]),e._v(" "),t("p",[e._v("Many different types, all with similar methods—that sounds like a class to me. And so\ntheArgumentMarshaler concept was born.")]),e._v(" "),t("h3",{attrs:{id:"on-incrementalism"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#on-incrementalism"}},[e._v("#")]),e._v(" On Incrementalism .")]),e._v(" "),t("p",[e._v("One of the best ways to ruin a program is to make massive changes to its structure in the name of\nimprovement. Some programs never recover from such “improvements.” The problem is that\nit’s very hard to get the program working the same way it worked before the “improvement.”")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public boolean getBoolean(char arg) {\nreturn falseIfNull(booleanArgs.get(arg));\n}\nprivate boolean falseIfNull(Boolean b) {\nreturn b == null? false : b;\n}\npublic String getString(char arg) {\nreturn blankIfNull(stringArgs.get(arg));\n}\nprivate String blankIfNull(String s) {\nreturn s == null? "" : s;\n}\npublic boolean has(char arg) {\nreturn argsFound.contains(arg);\n}\npublic boolean isValid() {\nreturn valid;\n}\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-10 (continued)\nArgs.java (Boolean and String)\n")])])]),t("p",[t("strong",[e._v("Args: The Rough Draft")]),e._v(" 213")]),e._v(" "),t("p",[e._v("To avoid this, I use the discipline of Test-Driven Development (TDD). One of the cen-\ntral doctrines of this approach is to keep the system running at all times. In other words,\nusing TDD, I am not allowed to make a change to the system that breaks that system.\nEvery change I make must keep the system working as it worked before.")]),e._v(" "),t("p",[e._v("To achieve this, I need a suite of automated tests that I can run on a whim and that ver-\nifies that the behavior of the system is unchanged. For the Argsclass I had created a suite\nof unit and acceptance tests while I was building the festering pile. The unit tests were\nwritten in Javaand administered by JUnit. The acceptance tests were written as wiki pages\ninFitNesse. I could run these tests any time I wanted, and if they passed, I was confident\nthat the system was working as I specified.")]),e._v(" "),t("p",[e._v("So I proceeded to make a large number of very tiny changes. Each change moved the\nstructure of the system toward the ArgumentMarshalerconcept. And yet each change kept\nthe system working. The first change I made was to add the skeleton of the\nArgumentMarshaller to the end of the festering pile (Listing 14-11).")]),e._v(" "),t("p",[e._v("Clearly, this wasn’t going to break anything. So then I made the simplest modification\nI could, one that would break as little as possible. I changed the HashMapfor the Boolean\narguments to take an ArgumentMarshaler.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private Map<Character, ArgumentMarshaler > booleanArgs =\nnew HashMap<Character, ArgumentMarshaler >();\n")])])]),t("p",[e._v("This broke a few statements, which I quickly fixed.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("...\nprivate void parseBooleanSchemaElement(char elementId) {\nbooleanArgs.put(elementId, new BooleanArgumentMarshaler() );\n}\n..\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-11\nArgumentMarshaller appended to Args.java\nprivate class ArgumentMarshaler {\nprivate boolean booleanValue = false;\npublic void setBoolean(boolean value) {\nbooleanValue = value;\n}\npublic boolean getBoolean() {return booleanValue;}\n}\nprivate class BooleanArgumentMarshaler extends ArgumentMarshaler {\n}\nprivate class StringArgumentMarshaler extends ArgumentMarshaler {\n}\nprivate class IntegerArgumentMarshaler extends ArgumentMarshaler {\n}\n}\n")])])]),t("p",[e._v("214 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("p",[e._v("private void setBooleanArg(char argChar, boolean value) {\nbooleanArgs. "),t("strong",[e._v("get")]),e._v(" (argChar) "),t("strong",[e._v(".setBoolean")]),e._v(" (value);\n}\npublic boolean getBoolean(char arg) {\nreturn falseIfNull(booleanArgs.get(arg). "),t("strong",[e._v("getBoolean()")]),e._v(" );\n}\nNotice how these changes are in exactly the areas that I mentioned before: the parse,\nset, and getfor the argument type. Unfortunately, small as this change was, some of the\ntests started failing. If you look carefully at getBoolean, you’ll see that if you call it with\n'y,'but there is no yargument, then booleanArgs.get('y')will return null, and the func-\ntion will throw a NullPointerException. The falseIfNullfunction had been used to protect\nagainst this, but the change I made caused that function to become irrelevant.")]),e._v(" "),t("p",[e._v("Incrementalism demanded that I get this working quickly before making any other\nchanges. Indeed, the fix was not too difficult. I just had to move the check for null. It was\nno longer the booleanbeing null that I needed to check; it was the ArgumentMarshaller.")]),e._v(" "),t("p",[e._v("First, I removed the falseIfNullcall in the getBooleanfunction. It was useless now, so\nI also eliminated the function itself. The tests still failed in the same way, so I was confi-\ndent that I hadn’t introduced any new errors.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public boolean getBoolean(char arg) {\nreturn booleanArgs.get(arg).getBoolean();\n}\n")])])]),t("p",[e._v("Next, I split the function into two lines and put the ArgumentMarshallerinto its own vari-\nable named argumentMarshaller. I didn’t care for the long variable name; it was badly\nredundant and cluttered up the function. So I shortened it to am [N5].")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public boolean getBoolean(char arg) {\nArgs.ArgumentMarshaler am = booleanArgs.get(arg);\nreturn am .getBoolean();\n}\n")])])]),t("p",[e._v("And then I put in the null detection logic.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public boolean getBoolean(char arg) {\nArgs.ArgumentMarshaler am = booleanArgs.get(arg);\nreturn am != null && am.getBoolean();\n}\n")])])]),t("h2",{attrs:{id:"string-arguments"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#string-arguments"}},[e._v("#")]),e._v(" String Arguments ..")]),e._v(" "),t("p",[e._v("AddingStringarguments was very similar to adding booleanarguments. I had to change\ntheHashMapand get the parse,set, and getfunctions working. There shouldn’t be any sur-\nprises in what follows except, perhaps, that I seem to be putting all the marshalling imple-\nmentation in the ArgumentMarshaller base class instead of distributing it to the derivatives.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private Map<Character , ArgumentMarshaler > stringArgs =\nnew HashMap<Character , ArgumentMarshaler >();\n...\n")])])]),t("p",[t("strong",[e._v("String Arguments")]),e._v(" 215")]),e._v(" "),t("p",[e._v("private void parseStringSchemaElement(char elementId) {\nstringArgs.put(elementId "),t("strong",[e._v(", new StringArgumentMarshaler()")]),e._v(" );\n}\n...\nprivate void setStringArg(char argChar) throws ArgsException {\ncurrentArgument++;\ntry {\nstringArgs "),t("strong",[e._v(".get")]),e._v(" (argChar) "),t("strong",[e._v(".setString")]),e._v(" (args[currentArgument]);\n} catch (ArrayIndexOutOfBoundsException e) {\nvalid = false;\nerrorArgumentId = argChar;\nerrorCode = ErrorCode.MISSING_STRING;\nthrow new ArgsException();\n}\n}\n...\npublic String getString(char arg) {\n"),t("strong",[e._v("Args.ArgumentMarshaler am =")]),e._v(" stringArgs.get(arg);\nreturn "),t("strong",[e._v('am == null? ""')]),e._v(" : am.getString();\n}\n...\nprivate class ArgumentMarshaler {\nprivate boolean booleanValue = false;\n"),t("strong",[e._v("private String stringValue;")]),e._v("\npublic void setBoolean(boolean value) {\nbooleanValue = value;\n}\npublic boolean getBoolean() {\nreturn booleanValue;\n}\n"),t("strong",[e._v('public void setString(String s) {\nstringValue = s;\n}\npublic String getString() {\nreturn stringValue == null? "" : stringValue;\n}')]),e._v("\n}\nAgain, these changes were made one at a time and in such a way that the tests kept\nrunning, if not passing. When a test broke, I made sure to get it passing again before con-\ntinuing with the next change.")]),e._v(" "),t("p",[e._v("By now you should be able to see my intent. Once I get all the current marshalling\nbehavior into the ArgumentMarshalerbase class, I’m going to start pushing that behavior\ndown into the derivatives. This will allow me to keep everything running while I gradually\nchange the shape of this program.")]),e._v(" "),t("p",[e._v("The obvious next step was to move the int argument functionality into the\nArgumentMarshaler. Again, there weren’t any surprises.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private Map<Character , ArgumentMarshaler > intArgs =\nnew HashMap<Character , ArgumentMarshaler >();\n...\n")])])]),t("p",[e._v("216 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('private void parseIntegerSchemaElement(char elementId) {\nintArgs.put(elementId, new IntegerArgumentMarshaler() );\n}\n...\nprivate void setIntArg(char argChar) throws ArgsException {\ncurrentArgument++;\nString parameter = null;\ntry {\nparameter = args[currentArgument];\nintArgs .get (argChar) .setInteger (Integer.parseInt(parameter));\n} catch (ArrayIndexOutOfBoundsException e) {\nvalid = false;\nerrorArgumentId = argChar;\nerrorCode = ErrorCode.MISSING_INTEGER;\nthrow new ArgsException();\n} catch (NumberFormatException e) {\nvalid = false;\nerrorArgumentId = argChar;\nerrorParameter = parameter;\nerrorCode = ErrorCode.INVALID_INTEGER;\nthrow new ArgsException();\n}\n}\n...\npublic int getInt(char arg) {\nArgs.ArgumentMarshaler am = intArgs.get(arg);\nreturn am == null? 0 : am.getInteger();\n}\n...\nprivate class ArgumentMarshaler {\nprivate boolean booleanValue = false;\nprivate String stringValue;\nprivate int integerValue;\npublic void setBoolean(boolean value) {\nbooleanValue = value;\n}\npublic boolean getBoolean() {\nreturn booleanValue;\n}\npublic void setString(String s) {\nstringValue = s;\n}\npublic String getString() {\nreturn stringValue == null? "" : stringValue;\n}\npublic void setInteger(int i) {\nintegerValue = i;\n}\npublic int getInteger() {\nreturn integerValue;\n}\n}\n')])])]),t("p",[t("strong",[e._v("String Arguments")]),e._v(" 217")]),e._v(" "),t("p",[e._v("With all the marshalling moved to the ArgumentMarshaler, I started pushing functional-\nity into the derivatives. The first step was to move the setBooleanfunction into the\nBooleanArgumentMarshallerand make sure it got called correctly. So I created an abstract\nset method.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('private abstract class ArgumentMarshaler {\nprotected boolean booleanValue = false;\nprivate String stringValue;\nprivate int integerValue;\npublic void setBoolean(boolean value) {\nbooleanValue = value;\n}\npublic boolean getBoolean() {\nreturn booleanValue;\n}\npublic void setString(String s) {\nstringValue = s;\n}\npublic String getString() {\nreturn stringValue == null? "" : stringValue;\n}\npublic void setInteger(int i) {\nintegerValue = i;\n}\npublic int getInteger() {\nreturn integerValue;\n}\npublic abstract void set(String s);\n}\n')])])]),t("p",[e._v("Then I implemented the set method in BooleanArgumentMarshaller.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private class BooleanArgumentMarshaler extends ArgumentMarshaler {\npublic void set(String s) {\nbooleanValue = true;\n}\n}\n")])])]),t("p",[e._v("And finally I replaced the call to setBoolean with a call to set.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('private void setBooleanArg(char argChar, boolean value) {\nbooleanArgs.get(argChar) .set("true");\n}\n')])])]),t("p",[e._v("The tests all still passed. Because this change caused setto be deployed to the Boolean-\nArgumentMarshaler, I removed the setBooleanmethod from the ArgumentMarshalerbase\nclass.")]),e._v(" "),t("p",[e._v("Notice that the abstract setfunction takes a Stringargument, but the implementation\nin the BooleanArgumentMarshallerdoes not use it. I put that argument in there because I\nknew that the StringArgumentMarshaller and IntegerArgumentMarshaller "),t("em",[e._v("would")]),e._v(" use it.")]),e._v(" "),t("p",[e._v("218 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("p",[e._v("Next, I wanted to deploy the getmethod into BooleanArgumentMarshaler. Deploying\ngetfunctions is always ugly because the return type has to be Object, and in this case\nneeds to be cast to a Boolean.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public boolean getBoolean(char arg) {\nArgs.ArgumentMarshaler am = booleanArgs.get(arg);\nreturn am != null && (Boolean) am. get ();\n}\n")])])]),t("p",[e._v("Just to get this to compile, I added the get function to the ArgumentMarshaler.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private abstract class ArgumentMarshaler {\n...\npublic Object get() {\nreturn null;\n}\n}\n")])])]),t("p",[e._v("This compiled and obviously failed the tests. Getting the tests working again was simply a\nmatter of making get abstract and implementing it in BooleanAgumentMarshaler.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private abstract class ArgumentMarshaler {\nprotected boolean booleanValue = false;\n...\npublic abstract Object get();\n}\nprivate class BooleanArgumentMarshaler extends ArgumentMarshaler {\npublic void set(String s) {\nbooleanValue = true;\n}\npublic Object get() {\nreturn booleanValue;\n}\n}\n")])])]),t("p",[e._v("Once again the tests passed. So both getandsetdeploy to the BooleanArgumentMarshaler!\nThis allowed me to remove the old getBooleanfunction from ArgumentMarshaler, move the\nprotectedbooleanValue variable down to BooleanArgumentMarshaler, and make it private.")]),e._v(" "),t("p",[e._v("I did the same pattern of changes for Strings. I deployed both setandget, deleted the\nunused functions, and moved the variables.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private void setStringArg(char argChar) throws ArgsException {\ncurrentArgument++;\ntry {\nstringArgs.get(argChar). set (args[currentArgument]);\n} catch (ArrayIndexOutOfBoundsException e) {\nvalid = false;\nerrorArgumentId = argChar;\nerrorCode = ErrorCode.MISSING_STRING;\nthrow new ArgsException();\n}\n}\n")])])]),t("p",[t("strong",[e._v("String Arguments")]),e._v(" 219")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('...\npublic String getString(char arg) {\nArgs.ArgumentMarshaler am = stringArgs.get(arg);\nreturn am == null? "" : (String) am. get ();\n}\n...\nprivate abstract class ArgumentMarshaler {\nprivate int integerValue;\npublic void setInteger(int i) {\nintegerValue = i;\n}\npublic int getInteger() {\nreturn integerValue;\n}\npublic abstract void set(String s);\npublic abstract Object get();\n}\nprivate class BooleanArgumentMarshaler extends ArgumentMarshaler {\nprivate boolean booleanValue = false;\npublic void set(String s) {\nbooleanValue = true;\n}\npublic Object get() {\nreturn booleanValue;\n}\n}\nprivate class StringArgumentMarshaler extends ArgumentMarshaler {\nprivate String stringValue = "";\npublic void set(String s) {\nstringValue = s;\n}\npublic Object get() {\nreturn stringValue;\n}\n}\nprivate class IntegerArgumentMarshaler extends ArgumentMarshaler {\npublic void set(String s) {\n}\npublic Object get() {\nreturn null;\n}\n}\n}\n')])])]),t("p",[e._v("220 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("p",[e._v("Finally, I repeated the process for integers. This was just a little more complicated\nbecauseintegersneeded to be parsed, and the parseoperation can throw an exception. But\nthe result is better because the whole concept of NumberFormatExceptiongot buried in the\nIntegerArgumentMarshaler.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('private boolean isIntArg(char argChar) {return intArgs.containsKey(argChar);}\nprivate void setIntArg(char argChar) throws ArgsException {\ncurrentArgument++;\nString parameter = null;\ntry {\nparameter = args[currentArgument];\nintArgs.get(argChar). set (parameter);\n} catch (ArrayIndexOutOfBoundsException e) {\nvalid = false;\nerrorArgumentId = argChar;\nerrorCode = ErrorCode.MISSING_INTEGER;\nthrow new ArgsException();\n} catch ( ArgsException e) {\nvalid = false;\nerrorArgumentId = argChar;\nerrorParameter = parameter;\nerrorCode = ErrorCode.INVALID_INTEGER;\nthrow e ;\n}\n}\n...\nprivate void setBooleanArg(char argChar) {\ntry {\nbooleanArgs.get(argChar).set("true");\n} catch (ArgsException e) {\n}\n}\n...\npublic int getInt(char arg) {\nArgs.ArgumentMarshaler am = intArgs.get(arg);\nreturn am == null? 0 : (Integer) am. get ();\n}\n...\nprivate abstract class ArgumentMarshaler {\npublic abstract void set(String s) throws ArgsException;\npublic abstract Object get();\n}\n...\nprivate class IntegerArgumentMarshaler extends ArgumentMarshaler {\nprivate int intValue = 0;\npublic void set(String s) throws ArgsException {\ntry {\nintValue = Integer.parseInt(s);\n} catch (NumberFormatException e) {\nthrow new ArgsException();\n}\n}\npublic Object get() {\nreturn intValue;\n}\n}\n')])])]),t("p",[t("strong",[e._v("String Arguments")]),e._v(" 221")]),e._v(" "),t("p",[e._v("Of course, the tests continued to pass. Next, I got rid of the three different maps up at\nthe top of the algorithm. This made the whole system much more generic. However, I\ncouldn’t get rid of them just by deleting them because that would break the system.\nInstead, I added a new Mapfor the ArgumentMarshalerand then one by one changed the\nmethods to use it instead of the three original maps.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public class Args {\n...\nprivate Map<Character, ArgumentMarshaler> booleanArgs =\nnew HashMap<Character, ArgumentMarshaler>();\nprivate Map<Character, ArgumentMarshaler> stringArgs =\nnew HashMap<Character, ArgumentMarshaler>();\nprivate Map<Character, ArgumentMarshaler> intArgs =\nnew HashMap<Character, ArgumentMarshaler>();\nprivate Map<Character, ArgumentMarshaler> marshalers =\nnew HashMap<Character, ArgumentMarshaler>();\n...\nprivate void parseBooleanSchemaElement(char elementId) {\nArgumentMarshaler m = new BooleanArgumentMarshaler();\nbooleanArgs.put(elementId, m);\nmarshalers.put(elementId, m);\n}\nprivate void parseIntegerSchemaElement(char elementId) {\nArgumentMarshaler m = new IntegerArgumentMarshaler();\nintArgs.put(elementId, m);\nmarshalers.put(elementId, m);\n}\nprivate void parseStringSchemaElement(char elementId) {\nArgumentMarshaler m = new StringArgumentMarshaler();\nstringArgs.put(elementId, m);\nmarshalers.put(elementId, m);\n}\n")])])]),t("p",[e._v("Of course the tests all still passed. Next, I changed isBooleanArg from this:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private boolean isBooleanArg(char argChar) {\nreturn booleanArgs.containsKey(argChar);\n}\n")])])]),t("p",[e._v("to this:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private boolean isBooleanArg(char argChar) {\nArgumentMarshaler m = marshalers.get(argChar);\nreturn m instanceof BooleanArgumentMarshaler;\n}\n")])])]),t("p",[e._v("The tests still passed. So I made the same change to isIntArg and isStringArg.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private boolean isIntArg(char argChar) {\nArgumentMarshaler m = marshalers.get(argChar);\nreturn m instanceof IntegerArgumentMarshaler;\n}\nprivate boolean isStringArg(char argChar) {\nArgumentMarshaler m = marshalers.get(argChar);\nreturn m instanceof StringArgumentMarshaler;\n}\n")])])]),t("p",[e._v("222 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("p",[e._v("The tests still passed. So I eliminated all the duplicate calls to marshalers.get as follows:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private boolean setArgument(char argChar) throws ArgsException {\nArgumentMarshaler m = marshalers.get(argChar);\nif (isBooleanArg( m ))\nsetBooleanArg(argChar);\nelse if (isStringArg( m ))\nsetStringArg(argChar);\nelse if (isIntArg( m ))\nsetIntArg(argChar);\nelse\nreturn false;\nreturn true;\n}\nprivate boolean isIntArg( ArgumentMarshaler m ) {\nreturn m instanceof IntegerArgumentMarshaler;\n}\nprivate boolean isStringArg( ArgumentMarshaler m ) {\nreturn m instanceof StringArgumentMarshaler;\n}\nprivate boolean isBooleanArg( ArgumentMarshaler m ) {\nreturn m instanceof BooleanArgumentMarshaler;\n}\n")])])]),t("p",[e._v("This left no good reason for the three isxxxArg methods. So I inlined them:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private boolean setArgument(char argChar) throws ArgsException {\nArgumentMarshaler m = marshalers.get(argChar);\nif ( m instanceof BooleanArgumentMarshaler )\nsetBooleanArg(argChar);\nelse if ( m instanceof StringArgumentMarshaler )\nsetStringArg(argChar);\nelse if ( m instanceof IntegerArgumentMarshaler )\nsetIntArg(argChar);\nelse\nreturn false;\nreturn true;\n}\n")])])]),t("p",[e._v("Next, I started using the marshalers map in the set functions, breaking the use of the other\nthree maps. I started with the booleans.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private boolean setArgument(char argChar) throws ArgsException {\nArgumentMarshaler m = marshalers.get(argChar);\nif (m instanceof BooleanArgumentMarshaler)\nsetBooleanArg( m );\nelse if (m instanceof StringArgumentMarshaler)\nsetStringArg(argChar);\nelse if (m instanceof IntegerArgumentMarshaler)\nsetIntArg(argChar);\nelse\nreturn false;\n")])])]),t("p",[t("strong",[e._v("String Arguments")]),e._v(" 223")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('return true;\n}\n...\nprivate void setBooleanArg( ArgumentMarshaler m ) {\ntry {\nm .set("true"); // was: booleanArgs.get(argChar).set("true");\n} catch (ArgsException e) {\n}\n}\n')])])]),t("p",[e._v("The tests still passed, so I did the same with StringsandIntegers. This allowed me to inte-\ngrate some of the ugly exception management code into the setArgument function.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private boolean setArgument(char argChar) throws ArgsException {\nArgumentMarshaler m = marshalers.get(argChar);\ntry {\nif (m instanceof BooleanArgumentMarshaler)\nsetBooleanArg(m);\nelse if (m instanceof StringArgumentMarshaler)\nsetStringArg( m );\nelse if (m instanceof IntegerArgumentMarshaler)\nsetIntArg( m );\nelse\nreturn false;\n} catch (ArgsException e) {\nvalid = false;\nerrorArgumentId = argChar;\nthrow e;\n}\nreturn true;\n}\nprivate void setIntArg( ArgumentMarshaler m ) throws ArgsException {\ncurrentArgument++;\nString parameter = null;\ntry {\nparameter = args[currentArgument];\nm .set(parameter);\n} catch (ArrayIndexOutOfBoundsException e) {\nerrorCode = ErrorCode.MISSING_INTEGER;\nthrow new ArgsException();\n} catch (ArgsException e) {\nerrorParameter = parameter;\nerrorCode = ErrorCode.INVALID_INTEGER;\nthrow e;\n}\n}\nprivate void setStringArg( ArgumentMarshaler m ) throws ArgsException {\ncurrentArgument++;\ntry {\nm .set(args[currentArgument]);\n} catch (ArrayIndexOutOfBoundsException e) {\nerrorCode = ErrorCode.MISSING_STRING;\nthrow new ArgsException();\n}\n}\n")])])]),t("p",[e._v("224 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("p",[e._v("I was close to being able to remove the three old maps. First, I needed to change the\ngetBoolean function from this:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public boolean getBoolean(char arg) {\nArgs.ArgumentMarshaler am = booleanArgs.get(arg);\nreturn am != null && (Boolean) am.get();\n}\n")])])]),t("p",[e._v("to this:")]),e._v(" "),t("p",[e._v("public boolean getBoolean(char arg) {\nArgs.ArgumentMarshaler am = marshalers.get(arg);\n"),t("strong",[e._v("boolean b = false;\ntry {\nb =")]),e._v(" am != null && (Boolean) am.get();\n"),t("strong",[e._v("} catch (ClassCastException e) {\nb = false;\n}\nreturn b;")]),e._v("\n}\nThis last change might have been a surprise. Why did I suddenly decide to deal with\ntheClassCastException? The reason is that I have a set of unit tests and a separate set of\nacceptance tests written in FitNesse. It turns out that the FitNesse tests made sure that if\nyou called getBooleanon a nonboolean argument, you got a false. The unit tests did not.\nUp to this point I had only been running the unit tests.^2")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("This last change allowed me to pull out another use of the boolean map:\nprivate void parseBooleanSchemaElement(char elementId) {\nArgumentMarshaler m = new BooleanArgumentMarshaler();\nbooleanArgs.put(elementId, m);\nmarshalers.put(elementId, m);\n}\n")])])]),t("p",[e._v("And now we can delete the boolean map.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public class Args {\n...\nprivate Map<Character, ArgumentMarshaler> booleanArgs =\nnew HashMap<Character, ArgumentMarshaler>();\nprivate Map<Character, ArgumentMarshaler> stringArgs =\nnew HashMap<Character, ArgumentMarshaler>();\nprivate Map<Character, ArgumentMarshaler> intArgs =\nnew HashMap<Character, ArgumentMarshaler>();\nprivate Map<Character, ArgumentMarshaler> marshalers =\nnew HashMap<Character, ArgumentMarshaler>();\n...\n")])])]),t("p",[e._v("Next, I migrated the StringandIntegerarguments in the same manner and did a little\ncleanup with the booleans.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private void parseBooleanSchemaElement(char elementId) {\nmarshalers.put(elementId, new BooleanArgumentMarshaler() );\n}\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[e._v("To prevent further surprises of this kind, I added a new unit test that invoked all the FitNesse tests.")])]),e._v(" "),t("p",[t("strong",[e._v("String Arguments")]),e._v(" 225")]),e._v(" "),t("p",[e._v("private void parseIntegerSchemaElement(char elementId) {\nmarshalers.put(elementId, "),t("strong",[e._v("new IntegerArgumentMarshaler()")]),e._v(" );\n}\nprivate void parseStringSchemaElement(char elementId) {\nmarshalers.put(elementId, "),t("strong",[e._v("new StringArgumentMarshaler()")]),e._v(" );\n}\n...\npublic String getString(char arg) {\nArgs.ArgumentMarshaler am = "),t("strong",[e._v("marshalers")]),e._v(" .get(arg);\n"),t("strong",[e._v("try {")]),e._v('\nreturn am == null? "" : (String) am.get();\n'),t("strong",[e._v('} catch (ClassCastException e) {\nreturn "";\n}')]),e._v("\n}\npublic int getInt(char arg) {\nArgs.ArgumentMarshaler am = "),t("strong",[e._v("marshalers")]),e._v(" .get(arg);\n"),t("strong",[e._v("try {")]),e._v("\nreturn am == null? 0 : (Integer) am.get();\n"),t("strong",[e._v("} catch (Exception e) {\nreturn 0;\n}")]),e._v("\n}\n...\npublic class Args {\n...\n"),t("strong",[e._v("private Map<Character, ArgumentMarshaler> stringArgs =\nnew HashMap<Character, ArgumentMarshaler>();\nprivate Map<Character, ArgumentMarshaler> intArgs =\nnew HashMap<Character, ArgumentMarshaler>();")]),e._v("\nprivate Map<Character, ArgumentMarshaler> marshalers =\nnew HashMap<Character, ArgumentMarshaler>();\n...\nNext, I inlined the three parse methods because they didn’t do much anymore:\nprivate void parseSchemaElement(String element) throws ParseException {\nchar elementId = element.charAt(0);\nString elementTail = element.substring(1);\nvalidateSchemaElementId(elementId);\nif (isBooleanSchemaElement(elementTail))\n"),t("strong",[e._v("marshalers.put(elementId, new BooleanArgumentMarshaler());")]),e._v("\nelse if (isStringSchemaElement(elementTail))\n"),t("strong",[e._v("marshalers.put(elementId, new StringArgumentMarshaler());")]),e._v("\nelse if (isIntegerSchemaElement(elementTail)) {\n"),t("strong",[e._v("marshalers.put(elementId, new IntegerArgumentMarshaler());")]),e._v('\n} else {\nthrow new ParseException(String.format(\n"Argument: %c has invalid format: %s.", elementId, elementTail), 0);\n}\n}\nOkay, so now let’s look at the whole picture again. Listing 14-12 shows the current\nform of the Args class.')]),e._v(" "),t("p",[e._v("226 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('Listing 14-12\nArgs.java (After first refactoring)\npackage com.objectmentor.utilities.getopts;\nimport java.text.ParseException;\nimport java.util.*;\npublic class Args {\nprivate String schema;\nprivate String[] args;\nprivate boolean valid = true;\nprivate Set<Character> unexpectedArguments = new TreeSet<Character>();\nprivate Map<Character, ArgumentMarshaler> marshalers =\nnew HashMap<Character, ArgumentMarshaler>();\nprivate Set<Character> argsFound = new HashSet<Character>();\nprivate int currentArgument;\nprivate char errorArgumentId = \'\\0\';\nprivate String errorParameter = "TILT";\nprivate ErrorCode errorCode = ErrorCode.OK;\nprivate enum ErrorCode {\nOK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT}\npublic Args(String schema, String[] args) throws ParseException {\nthis.schema = schema;\nthis.args = args;\nvalid = parse();\n}\nprivate boolean parse() throws ParseException {\nif (schema.length() == 0 && args.length == 0)\nreturn true;\nparseSchema();\ntry {\nparseArguments();\n} catch (ArgsException e) {\n}\nreturn valid;\n}\nprivate boolean parseSchema() throws ParseException {\nfor (String element : schema.split(",")) {\nif (element.length() > 0) {\nString trimmedElement = element.trim();\nparseSchemaElement(trimmedElement);\n}\n}\nreturn true;\n}\nprivate void parseSchemaElement(String element) throws ParseException {\nchar elementId = element.charAt(0);\nString elementTail = element.substring(1);\nvalidateSchemaElementId(elementId);\nif (isBooleanSchemaElement(elementTail))\nmarshalers.put(elementId, new BooleanArgumentMarshaler());\nelse if (isStringSchemaElement(elementTail))\nmarshalers.put(elementId, new StringArgumentMarshaler());\n')])])]),t("p",[t("strong",[e._v("String Arguments")]),e._v(" 227")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('else if (isIntegerSchemaElement(elementTail)) {\nmarshalers.put(elementId, new IntegerArgumentMarshaler());\n} else {\nthrow new ParseException(String.format(\n"Argument: %c has invalid format: %s.", elementId, elementTail), 0);\n}\n}\nprivate void validateSchemaElementId(char elementId) throws ParseException {\nif (!Character.isLetter(elementId)) {\nthrow new ParseException(\n"Bad character:" + elementId + "in Args format: " + schema, 0);\n}\n}\nprivate boolean isStringSchemaElement(String elementTail) {\nreturn elementTail.equals("*");\n}\nprivate boolean isBooleanSchemaElement(String elementTail) {\nreturn elementTail.length() == 0;\n}\nprivate boolean isIntegerSchemaElement(String elementTail) {\nreturn elementTail.equals("#");\n}\nprivate boolean parseArguments() throws ArgsException {\nfor (currentArgument=0; currentArgument<args.length; currentArgument++) {\nString arg = args[currentArgument];\nparseArgument(arg);\n}\nreturn true;\n}\nprivate void parseArgument(String arg) throws ArgsException {\nif (arg.startsWith("-"))\nparseElements(arg);\n}\nprivate void parseElements(String arg) throws ArgsException {\nfor (int i = 1; i < arg.length(); i++)\nparseElement(arg.charAt(i));\n}\nprivate void parseElement(char argChar) throws ArgsException {\nif (setArgument(argChar))\nargsFound.add(argChar);\nelse {\nunexpectedArguments.add(argChar);\nerrorCode = ErrorCode.UNEXPECTED_ARGUMENT;\nvalid = false;\n}\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-12 (continued)\nArgs.java (After first refactoring)\n")])])]),t("p",[e._v("228 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('private boolean setArgument(char argChar) throws ArgsException {\nArgumentMarshaler m = marshalers.get(argChar);\ntry {\nif (m instanceof BooleanArgumentMarshaler)\nsetBooleanArg(m);\nelse if (m instanceof StringArgumentMarshaler)\nsetStringArg(m);\nelse if (m instanceof IntegerArgumentMarshaler)\nsetIntArg(m);\nelse\nreturn false;\n} catch (ArgsException e) {\nvalid = false;\nerrorArgumentId = argChar;\nthrow e;\n}\nreturn true;\n}\nprivate void setIntArg(ArgumentMarshaler m) throws ArgsException {\ncurrentArgument++;\nString parameter = null;\ntry {\nparameter = args[currentArgument];\nm.set(parameter);\n} catch (ArrayIndexOutOfBoundsException e) {\nerrorCode = ErrorCode.MISSING_INTEGER;\nthrow new ArgsException();\n} catch (ArgsException e) {\nerrorParameter = parameter;\nerrorCode = ErrorCode.INVALID_INTEGER;\nthrow e;\n}\n}\nprivate void setStringArg(ArgumentMarshaler m) throws ArgsException {\ncurrentArgument++;\ntry {\nm.set(args[currentArgument]);\n} catch (ArrayIndexOutOfBoundsException e) {\nerrorCode = ErrorCode.MISSING_STRING;\nthrow new ArgsException();\n}\n}\nprivate void setBooleanArg(ArgumentMarshaler m) {\ntry {\nm.set("true");\n} catch (ArgsException e) {\n}\n}\npublic int cardinality() {\nreturn argsFound.size();\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-12 (continued)\nArgs.java (After first refactoring)\n")])])]),t("p",[t("strong",[e._v("String Arguments")]),e._v(" 229")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public String usage() {\nif (schema.length() > 0)\nreturn "-[" + schema + "]";\nelse\nreturn "";\n}\npublic String errorMessage() throws Exception {\nswitch (errorCode) {\ncase OK:\nthrow new Exception("TILT: Should not get here.");\ncase UNEXPECTED_ARGUMENT:\nreturn unexpectedArgumentMessage();\ncase MISSING_STRING:\nreturn String.format("Could not find string parameter for -%c.",\nerrorArgumentId);\ncase INVALID_INTEGER:\nreturn String.format("Argument -%c expects an integer but was \'%s\'.",\nerrorArgumentId, errorParameter);\ncase MISSING_INTEGER:\nreturn String.format("Could not find integer parameter for -%c.",\nerrorArgumentId);\n}\nreturn "";\n}\nprivate String unexpectedArgumentMessage() {\nStringBuffer message = new StringBuffer("Argument(s) -");\nfor (char c : unexpectedArguments) {\nmessage.append(c);\n}\nmessage.append(" unexpected.");\nreturn message.toString();\n}\npublic boolean getBoolean(char arg) {\nArgs.ArgumentMarshaler am = marshalers.get(arg);\nboolean b = false;\ntry {\nb = am != null && (Boolean) am.get();\n} catch (ClassCastException e) {\nb = false;\n}\nreturn b;\n}\npublic String getString(char arg) {\nArgs.ArgumentMarshaler am = marshalers.get(arg);\ntry {\nreturn am == null? "" : (String) am.get();\n} catch (ClassCastException e) {\nreturn "";\n}\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-12 (continued)\nArgs.java (After first refactoring)\n")])])]),t("p",[e._v("230 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public int getInt(char arg) {\nArgs.ArgumentMarshaler am = marshalers.get(arg);\ntry {\nreturn am == null? 0 : (Integer) am.get();\n} catch (Exception e) {\nreturn 0;\n}\n}\npublic boolean has(char arg) {\nreturn argsFound.contains(arg);\n}\npublic boolean isValid() {\nreturn valid;\n}\nprivate class ArgsException extends Exception {\n}\nprivate abstract class ArgumentMarshaler {\npublic abstract void set(String s) throws ArgsException;\npublic abstract Object get();\n}\nprivate class BooleanArgumentMarshaler extends ArgumentMarshaler {\nprivate boolean booleanValue = false;\npublic void set(String s) {\nbooleanValue = true;\n}\npublic Object get() {\nreturn booleanValue;\n}\n}\nprivate class StringArgumentMarshaler extends ArgumentMarshaler {\nprivate String stringValue = "";\npublic void set(String s) {\nstringValue = s;\n}\npublic Object get() {\nreturn stringValue;\n}\n}\nprivate class IntegerArgumentMarshaler extends ArgumentMarshaler {\nprivate int intValue = 0;\npublic void set(String s) throws ArgsException {\ntry {\nintValue = Integer.parseInt(s);\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-12 (continued)\nArgs.java (After first refactoring)\n")])])]),t("p",[t("strong",[e._v("String Arguments")]),e._v(" 231")]),e._v(" "),t("p",[e._v("After all that work, this is a bit disappointing. The structure is a bit better, but we still\nhave all those variables up at the top; there’s still a horrible type-case in setArgument; and\nall those setfunctions are really ugly. Not to mention all the error processing. We still\nhave a lot of work ahead of us.")]),e._v(" "),t("p",[e._v("I’d really like to get rid of that type-case up in setArgument[G23]. What I’d like in\nsetArgumentis a single call to ArgumentMarshaler.set. This means I need to push\nsetIntArg,setStringArg, and setBooleanArgdown into the appropriate ArgumentMarshaler\nderivatives. But there is a problem.")]),e._v(" "),t("p",[e._v("If you look closely at setIntArg, you’ll notice that it uses two instance variables: args\nandcurrentArg. To move setIntArgdown into BooleanArgumentMarshaler, I’ll have to pass\nbothargsandcurrentArgsas function arguments. That’s dirty [F1]. I’d rather pass one\nargument instead of two. Fortunately, there is a simple solution. We can convert the args\narray into a listand pass an Iteratordown to the setfunctions. The following took me\nten steps, passing all the tests after each. But I’ll just show you the result. You should be\nable to figure out what most of the tiny little steps were.\npublic class Args {\nprivate String schema;\n"),t("strong",[e._v("private String[] args;")]),e._v("\nprivate boolean valid = true;\nprivate Set"),t("Character",[e._v(" unexpectedArguments = new TreeSet"),t("Character",[e._v("();\nprivate Map<Character, ArgumentMarshaler> marshalers =\nnew HashMap<Character, ArgumentMarshaler>();\nprivate Set"),t("Character",[e._v(" argsFound = new HashSet"),t("Character",[e._v("();\nprivate "),t("strong",[e._v("Iterator"),t("String")],1),e._v(" currentArgument;\nprivate char errorArgumentId = '\\0';\nprivate String errorParameter = \"TILT\";\nprivate ErrorCode errorCode = ErrorCode.OK;\n"),t("strong",[e._v("private List"),t("String",[e._v(" argsList;")])],1),e._v("\nprivate enum ErrorCode {\nOK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT}\npublic Args(String schema, String[] args) throws ParseException {\nthis.schema = schema;\n"),t("strong",[e._v("argsList = Arrays.asList(args);")]),e._v("\nvalid = parse();\n}")])],1)],1)],1)],1),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("} catch (NumberFormatException e) {\nthrow new ArgsException();\n}\n}\npublic Object get() {\nreturn intValue;\n}\n}\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-12 (continued)\nArgs.java (After first refactoring)\n")])])]),t("p",[e._v("232 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private boolean parse() throws ParseException {\nif (schema.length() == 0 && argsList.size() == 0)\nreturn true;\nparseSchema();\ntry {\nparseArguments();\n} catch (ArgsException e) {\n}\nreturn valid;\n}\n---\nprivate boolean parseArguments() throws ArgsException {\nfor (currentArgument = argsList.iterator() ; currentArgument. hasNext() ;) {\nString arg = currentArgument. next() ;\nparseArgument(arg);\n}\nreturn true;\n}\n---\nprivate void setIntArg(ArgumentMarshaler m) throws ArgsException {\nString parameter = null;\ntry {\nparameter = currentArgument. next() ;\nm.set(parameter);\n} catch ( NoSuchElementException e) {\nerrorCode = ErrorCode.MISSING_INTEGER;\nthrow new ArgsException();\n} catch (ArgsException e) {\nerrorParameter = parameter;\nerrorCode = ErrorCode.INVALID_INTEGER;\nthrow e;\n}\n}\nprivate void setStringArg(ArgumentMarshaler m) throws ArgsException {\ntry {\nm.set(currentArgument .next() );\n} catch ( NoSuchElementException e) {\nerrorCode = ErrorCode.MISSING_STRING;\nthrow new ArgsException();\n}\n}\n")])])]),t("p",[e._v("These were simple changes that kept all the tests passing. Now we can start moving the set\nfunctions down into the appropriate derivatives. First, I need to make the following change\ninsetArgument:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private boolean setArgument(char argChar) throws ArgsException {\nArgumentMarshaler m = marshalers.get(argChar);\nif (m == null)\nreturn false;\ntry {\nif (m instanceof BooleanArgumentMarshaler)\nsetBooleanArg(m);\nelse if (m instanceof StringArgumentMarshaler)\nsetStringArg(m);\nelse if (m instanceof IntegerArgumentMarshaler)\nsetIntArg(m);\n")])])]),t("p",[t("strong",[e._v("String Arguments")]),e._v(" 233")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("else\nreturn false;\n} catch (ArgsException e) {\nvalid = false;\nerrorArgumentId = argChar;\nthrow e;\n}\nreturn true;\n}\n")])])]),t("p",[e._v("This change is important because we want to completely eliminate the if-elsechain.\nTherefore, we needed to get the error condition out of it.")]),e._v(" "),t("p",[e._v("Now we can start to move the setfunctions. The setBooleanArgfunction is trivial, so\nwe’ll prepare that one first. Our goal is to change the setBooleanArgfunction to simply for-\nward to the BooleanArgumentMarshaler.")]),e._v(" "),t("h2",{attrs:{id:"private-boolean-setargument-char-argchar-throws-argsexception-argumentmarshaler-m-marshalers-get-argchar-if-m-null-return-false-try-if-m-instanceof-booleanargumentmarshaler-setbooleanarg-m-currentargument-else-if-m-instanceof-stringargumentmarshaler-setstringarg-m-else-if-m-instanceof-integerargumentmarshaler-setintarg-m-catch-argsexception-e-valid-false-errorargumentid-argchar-throw-e-return-true"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#private-boolean-setargument-char-argchar-throws-argsexception-argumentmarshaler-m-marshalers-get-argchar-if-m-null-return-false-try-if-m-instanceof-booleanargumentmarshaler-setbooleanarg-m-currentargument-else-if-m-instanceof-stringargumentmarshaler-setstringarg-m-else-if-m-instanceof-integerargumentmarshaler-setintarg-m-catch-argsexception-e-valid-false-errorargumentid-argchar-throw-e-return-true"}},[e._v("#")]),e._v(" private boolean setArgument(char argChar) throws ArgsException {\nArgumentMarshaler m = marshalers.get(argChar);\nif (m == null)\nreturn false;\ntry {\nif (m instanceof BooleanArgumentMarshaler)\nsetBooleanArg(m, "),t("strong",[e._v("currentArgument")]),e._v(" );\nelse if (m instanceof StringArgumentMarshaler)\nsetStringArg(m);\nelse if (m instanceof IntegerArgumentMarshaler)\nsetIntArg(m);\n} catch (ArgsException e) {\nvalid = false;\nerrorArgumentId = argChar;\nthrow e;\n}\nreturn true;\n}")]),e._v(" "),t("p",[e._v("private void setBooleanArg(ArgumentMarshaler m,\n"),t("strong",[e._v("Iterator"),t("String",[e._v(" currentArgument)")])],1),e._v("\nthrows ArgsException {\n"),t("strong",[e._v("try {")]),e._v('\nm.set("true");\n'),t("strong",[e._v("catch (ArgsException e) {\n}")]),e._v("\n}\nDidn’t we just put that exception processing in? Putting things in so you can take\nthem out again is pretty common in refactoring. The smallness of the steps and the need to\nkeep the tests running means that you move things around a lot. Refactoring is a lot like\nsolving a Rubik’s cube. There are lots of little steps required to achieve a large goal. Each\nstep enables the next.")]),e._v(" "),t("p",[e._v("Why did we pass that iteratorwhensetBooleanArgcertainly doesn’t need it? Because\nsetIntArgandsetStringArgwill! And because I want to deploy all three of these functions\nthrough an abstract method in ArgumentMarshaller, I need to pass it to setBooleanArg.")]),e._v(" "),t("p",[e._v("234 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("p",[e._v("So now setBooleanArgis useless. If there were a setfunction in ArgumentMarshaler, we\ncould call it directly. So it’s time to make that function! The first step is to add the new\nabstract method to ArgumentMarshaler.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private abstract class ArgumentMarshaler {\npublic abstract void set(Iterator<String> currentArgument)\nthrows ArgsException;\npublic abstract void set(String s) throws ArgsException;\npublic abstract Object get();\n}\n")])])]),t("p",[e._v("Of course this breaks all the derivatives. So let’s implement the new method in each.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('private class BooleanArgumentMarshaler extends ArgumentMarshaler {\nprivate boolean booleanValue = false;\npublic void set(Iterator<String> currentArgument) throws ArgsException {\nbooleanValue = true;\n}\npublic void set(String s) {\nbooleanValue = true;\n}\npublic Object get() {\nreturn booleanValue;\n}\n}\nprivate class StringArgumentMarshaler extends ArgumentMarshaler {\nprivate String stringValue = "";\npublic void set(Iterator<String> currentArgument) throws ArgsException {\n}\npublic void set(String s) {\nstringValue = s;\n}\npublic Object get() {\nreturn stringValue;\n}\n}\nprivate class IntegerArgumentMarshaler extends ArgumentMarshaler {\nprivate int intValue = 0;\npublic void set(Iterator<String> currentArgument) throws ArgsException {\n}\npublic void set(String s) throws ArgsException {\ntry {\nintValue = Integer.parseInt(s);\n} catch (NumberFormatException e) {\nthrow new ArgsException();\n}\n}\n')])])]),t("p",[t("strong",[e._v("String Arguments")]),e._v(" 235")]),e._v(" "),t("p",[e._v("public Object get() {\nreturn intValue;\n}\n}\nAnd now we can eliminate setBooleanArg!")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private boolean setArgument(char argChar) throws ArgsException {\nArgumentMarshaler m = marshalers.get(argChar);\nif (m == null)\nreturn false;\ntry {\nif (m instanceof BooleanArgumentMarshaler)\nm.set (currentArgument);\nelse if (m instanceof StringArgumentMarshaler)\nsetStringArg(m);\nelse if (m instanceof IntegerArgumentMarshaler)\nsetIntArg(m);\n} catch (ArgsException e) {\nvalid = false;\nerrorArgumentId = argChar;\nthrow e;\n}\nreturn true;\n}\n")])])]),t("p",[e._v("The tests all pass, and the set function is deploying to BooleanArgumentMarshaler!")]),e._v(" "),t("p",[e._v("Now we can do the same for Strings and Integers.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('private boolean setArgument(char argChar) throws ArgsException {\nArgumentMarshaler m = marshalers.get(argChar);\nif (m == null)\nreturn false;\ntry {\nif (m instanceof BooleanArgumentMarshaler)\nm.set(currentArgument);\nelse if (m instanceof StringArgumentMarshaler)\nm.set(currentArgument);\nelse if (m instanceof IntegerArgumentMarshaler)\nm.set(currentArgument);\n} catch (ArgsException e) {\nvalid = false;\nerrorArgumentId = argChar;\nthrow e;\n}\nreturn true;\n}\n---\nprivate class StringArgumentMarshaler extends ArgumentMarshaler {\nprivate String stringValue = "";\npublic void set(Iterator<String> currentArgument) throws ArgsException {\ntry {\nstringValue = currentArgument.next();\n} catch (NoSuchElementException e) {\nerrorCode = ErrorCode.MISSING_STRING;\n')])])]),t("p",[e._v("236 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("throw new ArgsException();\n}\n}\npublic void set(String s) {\n}\npublic Object get() {\nreturn stringValue;\n}\n}\nprivate class IntegerArgumentMarshaler extends ArgumentMarshaler {\nprivate int intValue = 0;\npublic void set(Iterator<String> currentArgument) throws ArgsException {\nString parameter = null;\ntry {\nparameter = currentArgument.next();\nset(parameter);\n} catch (NoSuchElementException e) {\nerrorCode = ErrorCode.MISSING_INTEGER;\nthrow new ArgsException();\n} catch (ArgsException e) {\nerrorParameter = parameter;\nerrorCode = ErrorCode.INVALID_INTEGER;\nthrow e;\n}\n}\npublic void set(String s) throws ArgsException {\ntry {\nintValue = Integer.parseInt(s);\n} catch (NumberFormatException e) {\nthrow new ArgsException();\n}\n}\npublic Object get() {\nreturn intValue;\n}\n}\n")])])]),t("p",[e._v("And so the "),t("em",[e._v("coup de grace")]),e._v(" : The type-case can be removed! Touche!")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private boolean setArgument(char argChar) throws ArgsException {\nArgumentMarshaler m = marshalers.get(argChar);\nif (m == null)\nreturn false;\ntry {\nm.set(currentArgument);\nreturn true;\n} catch (ArgsException e) {\nvalid = false;\nerrorArgumentId = argChar;\nthrow e;\n}\n}\n")])])]),t("p",[t("strong",[e._v("String Arguments")]),e._v(" 237")]),e._v(" "),t("p",[e._v("Now we can get rid of some crufty functions in IntegerArgumentMarshalerand clean it up\na bit.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private class IntegerArgumentMarshaler extends ArgumentMarshaler {\nprivate int intValue = 0\npublic void set(Iterator<String> currentArgument) throws ArgsException {\nString parameter = null;\ntry {\nparameter = currentArgument.next();\nintValue = Integer.parseInt (parameter);\n} catch (NoSuchElementException e) {\nerrorCode = ErrorCode.MISSING_INTEGER;\nthrow new ArgsException();\n} catch ( NumberFormatException e) {\nerrorParameter = parameter;\nerrorCode = ErrorCode.INVALID_INTEGER;\nthrow new ArgsException();\n}\n}\npublic Object get() {\nreturn intValue;\n}\n}\n")])])]),t("p",[e._v("We can also turn "),t("strong",[e._v("ArgumentMarshaler")]),e._v(" into an interface.")]),e._v(" "),t("p",[e._v("private "),t("strong",[e._v("interface")]),e._v(" ArgumentMarshaler {\nvoid set(Iterator"),t("String",[e._v(" currentArgument) throws ArgsException;\nObject get();\n}\nSo now let’s see how easy it is to add a new argument type to our structure. It should\nrequire very few changes, and those changes should be isolated. First, we begin by adding\na new test case to check that the double argument works correctly.")])],1),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public void testSimpleDoublePresent() throws Exception {\nArgs args = new Args("x##", new String[] {"-x","42.3"});\nassertTrue(args.isValid());\nassertEquals(1, args.cardinality());\nassertTrue(args.has(\'x\'));\nassertEquals(42.3, args.getDouble(\'x\'), .001);\n}\n')])])]),t("p",[e._v("Now we clean up the schema parsing code and add the ##detection for the double\nargument type.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('private void parseSchemaElement(String element) throws ParseException {\nchar elementId = element.charAt(0);\nString elementTail = element.substring(1);\nvalidateSchemaElementId(elementId);\nif (elementTail. length() == 0 )\nmarshalers.put(elementId, new BooleanArgumentMarshaler());\nelse if (elementTail. equals("*") )\nmarshalers.put(elementId, new StringArgumentMarshaler());\nelse if (elementTail. equals("#") )\nmarshalers.put(elementId, new IntegerArgumentMarshaler());\n')])])]),t("p",[e._v("238 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('else if (elementTail.equals("##"))\nmarshalers.put(elementId, new DoubleArgumentMarshaler());\nelse\nthrow new ParseException(String.format(\n"Argument: %c has invalid format: %s.", elementId, elementTail), 0);\n}\n')])])]),t("p",[e._v("Next, we write the DoubleArgumentMarshaler class.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private class DoubleArgumentMarshaler implements ArgumentMarshaler {\nprivate double doubleValue = 0;\npublic void set(Iterator<String> currentArgument) throws ArgsException {\nString parameter = null;\ntry {\nparameter = currentArgument.next();\ndoubleValue = Double.parseDouble(parameter);\n} catch (NoSuchElementException e) {\nerrorCode = ErrorCode.MISSING_DOUBLE;\nthrow new ArgsException();\n} catch (NumberFormatException e) {\nerrorParameter = parameter;\nerrorCode = ErrorCode.INVALID_DOUBLE;\nthrow new ArgsException();\n}\n}\npublic Object get() {\nreturn doubleValue;\n}\n}\n")])])]),t("p",[e._v("This forces us to add a new ErrorCode.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("private enum ErrorCode {\nOK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT,\nMISSING_DOUBLE, INVALID_DOUBLE }\n")])])]),t("p",[e._v("And we need a getDouble function.")]),e._v(" "),t("p",[t("strong",[e._v("public double getDouble(char arg) {\nArgs.ArgumentMarshaler am = marshalers.get(arg);\ntry {\nreturn am == null? 0 : (Double) am.get();\n} catch (Exception e) {\nreturn 0.0;\n}\n}")]),e._v("\nAnd all the tests pass! That was pretty painless. So now let’s make sure all the error\nprocessing works correctly. The next test case checks that an error is declared if an\nunparseable string is fed to a ##argument.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public void testInvalidDouble() throws Exception {\nArgs args = new Args("x##", new String[] {"-x","Forty two"});\nassertFalse(args.isValid());\nassertEquals(0, args.cardinality());\nassertFalse(args.has(\'x\'));\nassertEquals(0, args.getInt(\'x\'));\n')])])]),t("p",[t("strong",[e._v("String Arguments")]),e._v(" 239")]),e._v(" "),t("h2",{attrs:{id:"assertequals-argument-x-expects-a-double-but-was-forty-two-args-errormessage"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#assertequals-argument-x-expects-a-double-but-was-forty-two-args-errormessage"}},[e._v("#")]),e._v(" assertEquals(\"Argument -x expects a double but was 'Forty two'.\",\nargs.errorMessage());\n}")]),e._v(" "),t("p",[e._v('public String errorMessage() throws Exception {\nswitch (errorCode) {\ncase OK:\nthrow new Exception("TILT: Should not get here.");\ncase UNEXPECTED_ARGUMENT:\nreturn unexpectedArgumentMessage();\ncase MISSING_STRING:\nreturn String.format("Could not find string parameter for -%c.",\nerrorArgumentId);\ncase INVALID_INTEGER:\nreturn String.format("Argument -%c expects an integer but was \'%s\'.",\nerrorArgumentId, errorParameter);\ncase MISSING_INTEGER:\nreturn String.format("Could not find integer parameter for -%c.",\nerrorArgumentId);\n'),t("strong",[e._v('case INVALID_DOUBLE:\nreturn String.format("Argument -%c expects a double but was \'%s\'.",\nerrorArgumentId, errorParameter);\ncase MISSING_DOUBLE:\nreturn String.format("Could not find double parameter for -%c.",\nerrorArgumentId);')]),e._v('\n}\nreturn "";\n}\nAnd the tests pass. The next test makes sure we detect a missing doubleargument properly.')]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public void testMissingDouble() throws Exception {\nArgs args = new Args("x##", new String[]{"-x"});\nassertFalse(args.isValid());\nassertEquals(0, args.cardinality());\nassertFalse(args.has(\'x\'));\nassertEquals(0.0, args.getDouble(\'x\'), 0.01);\nassertEquals("Could not find double parameter for -x.",\nargs.errorMessage());\n}\n')])])]),t("p",[e._v("This passes as expected. We wrote it simply for completeness.")]),e._v(" "),t("p",[e._v("The exception code is pretty ugly and doesn’t really belong in the Argsclass. We are\nalso throwing out ParseException, which doesn’t really belong to us. So let’s merge all the\nexceptions into a single ArgsException class and move it into its own module.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public class ArgsException extends Exception {\nprivate char errorArgumentId = '\\0';\nprivate String errorParameter = \"TILT\";\nprivate ErrorCode errorCode = ErrorCode.OK;\npublic ArgsException() {}\npublic ArgsException(String message) {super(message);}\npublic enum ErrorCode {\nOK, MISSING_STRING, MISSING_INTEGER, INVALID_INTEGER, UNEXPECTED_ARGUMENT,\nMISSING_DOUBLE, INVALID_DOUBLE}\n}\n---\n")])])]),t("p",[e._v("240 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public class Args {\n...\nprivate char errorArgumentId = \'\\0\';\nprivate String errorParameter = "TILT";\nprivate ArgsException .ErrorCode errorCode = ArgsException .ErrorCode.OK;\nprivate List<String> argsList;\npublic Args(String schema, String[] args) throws ArgsException {\nthis.schema = schema;\nargsList = Arrays.asList(args);\nvalid = parse();\n}\nprivate boolean parse() throws ArgsException {\nif (schema.length() == 0 && argsList.size() == 0)\nreturn true;\nparseSchema();\ntry {\nparseArguments();\n} catch ( ArgsException e) {\n}\nreturn valid;\n}\nprivate boolean parseSchema() throws ArgsException {\n...\n}\nprivate void parseSchemaElement(String element) throws ArgsException {\n...\nelse\nthrow new ArgsException (\nString.format("Argument: %c has invalid format: %s.",\nelementId,elementTail));\n}\nprivate void validateSchemaElementId(char elementId) throws ArgsException {\nif (!Character.isLetter(elementId)) {\nthrow new ArgsException (\n"Bad character:" + elementId + "in Args format: " + schema);\n}\n}\n...\nprivate void parseElement(char argChar) throws ArgsException {\nif (setArgument(argChar))\nargsFound.add(argChar);\nelse {\nunexpectedArguments.add(argChar);\nerrorCode = ArgsException .ErrorCode.UNEXPECTED_ARGUMENT;\nvalid = false;\n}\n}\n...\n')])])]),t("p",[t("strong",[e._v("String Arguments")]),e._v(" 241")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('private class StringArgumentMarshaler implements ArgumentMarshaler {\nprivate String stringValue = "";\npublic void set(Iterator<String> currentArgument) throws ArgsException {\ntry {\nstringValue = currentArgument.next();\n} catch (NoSuchElementException e) {\nerrorCode = ArgsException .ErrorCode.MISSING_STRING;\nthrow new ArgsException();\n}\n}\npublic Object get() {\nreturn stringValue;\n}\n}\nprivate class IntegerArgumentMarshaler implements ArgumentMarshaler {\nprivate int intValue = 0;\npublic void set(Iterator<String> currentArgument) throws ArgsException {\nString parameter = null;\ntry {\nparameter = currentArgument.next();\nintValue = Integer.parseInt(parameter);\n} catch (NoSuchElementException e) {\nerrorCode = ArgsException.ErrorCode.MISSING_INTEGER;\nthrow new ArgsException ();\n} catch (NumberFormatException e) {\nerrorParameter = parameter;\nerrorCode = ArgsException .ErrorCode.INVALID_INTEGER;\nthrow new ArgsException ();\n}\n}\npublic Object get() {\nreturn intValue;\n}\n}\nprivate class DoubleArgumentMarshaler implements ArgumentMarshaler {\nprivate double doubleValue = 0;\npublic void set(Iterator<String> currentArgument) throws ArgsException {\nString parameter = null;\ntry {\nparameter = currentArgument.next();\ndoubleValue = Double.parseDouble(parameter);\n} catch (NoSuchElementException e) {\nerrorCode = ArgsException .ErrorCode.MISSING_DOUBLE;\nthrow new ArgsException();\n} catch (NumberFormatException e) {\nerrorParameter = parameter;\nerrorCode = ArgsException .ErrorCode.INVALID_DOUBLE;\nthrow new ArgsException();\n}\n}\n')])])]),t("p",[e._v("242 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("p",[e._v("public Object get() {\nreturn doubleValue;\n}\n}\n}\nThis is nice. Now the only exception thrown by ArgsisArgsException. Moving\nArgsExceptioninto its own module means that we can move a lot of the miscellaneous\nerror support code into that module and out of the Argsmodule. It provides a natural and\nobvious place to put all that code and will really help us clean up the Argsmodule going\nforward.")]),e._v(" "),t("p",[e._v("So now we have completely separated the exception and error code from the Args\nmodule. (See Listing 14-13 through Listing 14-16.) This was achieved through a series of\nabout 30 tiny steps, keeping the tests passing between each step.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('Listing 14-13\nArgsTest.java\npackage com.objectmentor.utilities.args;\nimport junit.framework.TestCase;\npublic class ArgsTest extends TestCase {\npublic void testCreateWithNoSchemaOrArguments() throws Exception {\nArgs args = new Args("", new String[0]);\nassertEquals(0, args.cardinality());\n}\npublic void testWithNoSchemaButWithOneArgument() throws Exception {\ntry {\nnew Args("", new String[]{"-x"});\nfail();\n} catch (ArgsException e) {\nassertEquals(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,\ne.getErrorCode());\nassertEquals(\'x\', e.getErrorArgumentId());\n}\n}\npublic void testWithNoSchemaButWithMultipleArguments() throws Exception {\ntry {\nnew Args("", new String[]{"-x", "-y"});\nfail();\n} catch (ArgsException e) {\nassertEquals(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,\ne.getErrorCode());\nassertEquals(\'x\', e.getErrorArgumentId());\n}\n}\npublic void testNonLetterSchema() throws Exception {\ntry {\nnew Args("*", new String[]{});\nfail("Args constructor should have thrown exception");\n} catch (ArgsException e) {\n')])])]),t("p",[t("strong",[e._v("String Arguments")]),e._v(" 243")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('assertEquals(ArgsException.ErrorCode.INVALID_ARGUMENT_NAME,\ne.getErrorCode());\nassertEquals(\'*\', e.getErrorArgumentId());\n}\n}\npublic void testInvalidArgumentFormat() throws Exception {\ntry {\nnew Args("f~", new String[]{});\nfail("Args constructor should have throws exception");\n} catch (ArgsException e) {\nassertEquals(ArgsException.ErrorCode.INVALID_FORMAT, e.getErrorCode());\nassertEquals(\'f\', e.getErrorArgumentId());\n}\n}\npublic void testSimpleBooleanPresent() throws Exception {\nArgs args = new Args("x", new String[]{"-x"});\nassertEquals(1, args.cardinality());\nassertEquals(true, args.getBoolean(\'x\'));\n}\npublic void testSimpleStringPresent() throws Exception {\nArgs args = new Args("x*", new String[]{"-x", "param"});\nassertEquals(1, args.cardinality());\nassertTrue(args.has(\'x\'));\nassertEquals("param", args.getString(\'x\'));\n}\npublic void testMissingStringArgument() throws Exception {\ntry {\nnew Args("x*", new String[]{"-x"});\nfail();\n} catch (ArgsException e) {\nassertEquals(ArgsException.ErrorCode.MISSING_STRING, e.getErrorCode());\nassertEquals(\'x\', e.getErrorArgumentId());\n}\n}\npublic void testSpacesInFormat() throws Exception {\nArgs args = new Args("x, y", new String[]{"-xy"});\nassertEquals(2, args.cardinality());\nassertTrue(args.has(\'x\'));\nassertTrue(args.has(\'y\'));\n}\npublic void testSimpleIntPresent() throws Exception {\nArgs args = new Args("x#", new String[]{"-x", "42"});\nassertEquals(1, args.cardinality());\nassertTrue(args.has(\'x\'));\nassertEquals(42, args.getInt(\'x\'));\n}\npublic void testInvalidInteger() throws Exception {\ntry {\nnew Args("x#", new String[]{"-x", "Forty two"});\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-13 (continued)\nArgsTest.java\n")])])]),t("p",[e._v("244 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('fail();\n} catch (ArgsException e) {\nassertEquals(ArgsException.ErrorCode.INVALID_INTEGER, e.getErrorCode());\nassertEquals(\'x\', e.getErrorArgumentId());\nassertEquals("Forty two", e.getErrorParameter());\n}\n}\npublic void testMissingInteger() throws Exception {\ntry {\nnew Args("x#", new String[]{"-x"});\nfail();\n} catch (ArgsException e) {\nassertEquals(ArgsException.ErrorCode.MISSING_INTEGER, e.getErrorCode());\nassertEquals(\'x\', e.getErrorArgumentId());\n}\n}\npublic void testSimpleDoublePresent() throws Exception {\nArgs args = new Args("x##", new String[]{"-x", "42.3"});\nassertEquals(1, args.cardinality());\nassertTrue(args.has(\'x\'));\nassertEquals(42.3, args.getDouble(\'x\'), .001);\n}\npublic void testInvalidDouble() throws Exception {\ntry {\nnew Args("x##", new String[]{"-x", "Forty two"});\nfail();\n} catch (ArgsException e) {\nassertEquals(ArgsException.ErrorCode.INVALID_DOUBLE, e.getErrorCode());\nassertEquals(\'x\', e.getErrorArgumentId());\nassertEquals("Forty two", e.getErrorParameter());\n}\n}\npublic void testMissingDouble() throws Exception {\ntry {\nnew Args("x##", new String[]{"-x"});\nfail();\n} catch (ArgsException e) {\nassertEquals(ArgsException.ErrorCode.MISSING_DOUBLE, e.getErrorCode());\nassertEquals(\'x\', e.getErrorArgumentId());\n}\n}\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-14\nArgsExceptionTest.java\npublic class ArgsExceptionTest extends TestCase {\npublic void testUnexpectedMessage() throws Exception {\nArgsException e =\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-13 (continued)\nArgsTest.java\n")])])]),t("p",[t("strong",[e._v("String Arguments")]),e._v(" 245")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("new ArgsException(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,\n'x', null);\nassertEquals(\"Argument -x unexpected.\", e.errorMessage());\n}\npublic void testMissingStringMessage() throws Exception {\nArgsException e = new ArgsException(ArgsException.ErrorCode.MISSING_STRING,\n'x', null);\nassertEquals(\"Could not find string parameter for -x.\", e.errorMessage());\n}\npublic void testInvalidIntegerMessage() throws Exception {\nArgsException e =\nnew ArgsException(ArgsException.ErrorCode.INVALID_INTEGER,\n'x', \"Forty two\");\nassertEquals(\"Argument -x expects an integer but was 'Forty two'.\",\ne.errorMessage());\n}\npublic void testMissingIntegerMessage() throws Exception {\nArgsException e =\nnew ArgsException(ArgsException.ErrorCode.MISSING_INTEGER, 'x', null);\nassertEquals(\"Could not find integer parameter for -x.\", e.errorMessage());\n}\npublic void testInvalidDoubleMessage() throws Exception {\nArgsException e = new ArgsException(ArgsException.ErrorCode.INVALID_DOUBLE,\n'x', \"Forty two\");\nassertEquals(\"Argument -x expects a double but was 'Forty two'.\",\ne.errorMessage());\n}\npublic void testMissingDoubleMessage() throws Exception {\nArgsException e = new ArgsException(ArgsException.ErrorCode.MISSING_DOUBLE,\n'x', null);\nassertEquals(\"Could not find double parameter for -x.\", e.errorMessage());\n}\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-15\nArgsException.java\npublic class ArgsException extends Exception {\nprivate char errorArgumentId = '\\0';\nprivate String errorParameter = \"TILT\";\nprivate ErrorCode errorCode = ErrorCode.OK;\npublic ArgsException() {}\npublic ArgsException(String message) {super(message);}\npublic ArgsException(ErrorCode errorCode) {\nthis.errorCode = errorCode;\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-14 (continued)\nArgsExceptionTest.java\n")])])]),t("p",[e._v("246 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public ArgsException(ErrorCode errorCode, String errorParameter) {\nthis.errorCode = errorCode;\nthis.errorParameter = errorParameter;\n}\npublic ArgsException(ErrorCode errorCode, char errorArgumentId,\nString errorParameter) {\nthis.errorCode = errorCode;\nthis.errorParameter = errorParameter;\nthis.errorArgumentId = errorArgumentId;\n}\npublic char getErrorArgumentId() {\nreturn errorArgumentId;\n}\npublic void setErrorArgumentId(char errorArgumentId) {\nthis.errorArgumentId = errorArgumentId;\n}\npublic String getErrorParameter() {\nreturn errorParameter;\n}\npublic void setErrorParameter(String errorParameter) {\nthis.errorParameter = errorParameter;\n}\npublic ErrorCode getErrorCode() {\nreturn errorCode;\n}\npublic void setErrorCode(ErrorCode errorCode) {\nthis.errorCode = errorCode;\n}\npublic String errorMessage() throws Exception {\nswitch (errorCode) {\ncase OK:\nthrow new Exception("TILT: Should not get here.");\ncase UNEXPECTED_ARGUMENT:\nreturn String.format("Argument -%c unexpected.", errorArgumentId);\ncase MISSING_STRING:\nreturn String.format("Could not find string parameter for -%c.",\nerrorArgumentId);\ncase INVALID_INTEGER:\nreturn String.format("Argument -%c expects an integer but was \'%s\'.",\nerrorArgumentId, errorParameter);\ncase MISSING_INTEGER:\nreturn String.format("Could not find integer parameter for -%c.",\nerrorArgumentId);\ncase INVALID_DOUBLE:\nreturn String.format("Argument -%c expects a double but was \'%s\'.",\nerrorArgumentId, errorParameter);\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-15 (continued)\nArgsException.java\n")])])]),t("p",[t("strong",[e._v("String Arguments")]),e._v(" 247")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('case MISSING_DOUBLE:\nreturn String.format("Could not find double parameter for -%c.",\nerrorArgumentId);\n}\nreturn "";\n}\npublic enum ErrorCode {\nOK, INVALID_FORMAT, UNEXPECTED_ARGUMENT, INVALID_ARGUMENT_NAME,\nMISSING_STRING,\nMISSING_INTEGER, INVALID_INTEGER,\nMISSING_DOUBLE, INVALID_DOUBLE}\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('Listing 14-16\nArgs.java\npublic class Args {\nprivate String schema;\nprivate Map<Character, ArgumentMarshaler> marshalers =\nnew HashMap<Character, ArgumentMarshaler>();\nprivate Set<Character> argsFound = new HashSet<Character>();\nprivate Iterator<String> currentArgument;\nprivate List<String> argsList;\npublic Args(String schema, String[] args) throws ArgsException {\nthis.schema = schema;\nargsList = Arrays.asList(args);\nparse();\n}\nprivate void parse() throws ArgsException {\nparseSchema();\nparseArguments();\n}\nprivate boolean parseSchema() throws ArgsException {\nfor (String element : schema.split(",")) {\nif (element.length() > 0) {\nparseSchemaElement(element.trim());\n}\n}\nreturn true;\n}\nprivate void parseSchemaElement(String element) throws ArgsException {\nchar elementId = element.charAt(0);\nString elementTail = element.substring(1);\nvalidateSchemaElementId(elementId);\nif (elementTail.length() == 0)\nmarshalers.put(elementId, new BooleanArgumentMarshaler());\nelse if (elementTail.equals("*"))\nmarshalers.put(elementId, new StringArgumentMarshaler());\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-15 (continued)\nArgsException.java\n")])])]),t("p",[e._v("248 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('else if (elementTail.equals("#"))\nmarshalers.put(elementId, new IntegerArgumentMarshaler());\nelse if (elementTail.equals("##"))\nmarshalers.put(elementId, new DoubleArgumentMarshaler());\nelse\nthrow new ArgsException(ArgsException.ErrorCode.INVALID_FORMAT,\nelementId, elementTail);\n}\nprivate void validateSchemaElementId(char elementId) throws ArgsException {\nif (!Character.isLetter(elementId)) {\nthrow new ArgsException(ArgsException.ErrorCode.INVALID_ARGUMENT_NAME,\nelementId, null);\n}\n}\nprivate void parseArguments() throws ArgsException {\nfor (currentArgument = argsList.iterator(); currentArgument.hasNext();) {\nString arg = currentArgument.next();\nparseArgument(arg);\n}\n}\nprivate void parseArgument(String arg) throws ArgsException {\nif (arg.startsWith("-"))\nparseElements(arg);\n}\nprivate void parseElements(String arg) throws ArgsException {\nfor (int i = 1; i < arg.length(); i++)\nparseElement(arg.charAt(i));\n}\nprivate void parseElement(char argChar) throws ArgsException {\nif (setArgument(argChar))\nargsFound.add(argChar);\nelse {\nthrow new ArgsException(ArgsException.ErrorCode.UNEXPECTED_ARGUMENT,\nargChar, null);\n}\n}\nprivate boolean setArgument(char argChar) throws ArgsException {\nArgumentMarshaler m = marshalers.get(argChar);\nif (m == null)\nreturn false;\ntry {\nm.set(currentArgument);\nreturn true;\n} catch (ArgsException e) {\ne.setErrorArgumentId(argChar);\nthrow e;\n}\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-16 (continued)\nArgs.java\n")])])]),t("p",[t("strong",[e._v("String Arguments")]),e._v(" 249")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('public int cardinality() {\nreturn argsFound.size();\n}\npublic String usage() {\nif (schema.length() > 0)\nreturn "-[" + schema + "]";\nelse\nreturn "";\n}\npublic boolean getBoolean(char arg) {\nArgumentMarshaler am = marshalers.get(arg);\nboolean b = false;\ntry {\nb = am != null && (Boolean) am.get();\n} catch (ClassCastException e) {\nb = false;\n}\nreturn b;\n}\npublic String getString(char arg) {\nArgumentMarshaler am = marshalers.get(arg);\ntry {\nreturn am == null? "" : (String) am.get();\n} catch (ClassCastException e) {\nreturn "";\n}\n}\npublic int getInt(char arg) {\nArgumentMarshaler am = marshalers.get(arg);\ntry {\nreturn am == null? 0 : (Integer) am.get();\n} catch (Exception e) {\nreturn 0;\n}\n}\n')])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("public double getDouble(char arg) {\nArgumentMarshaler am = marshalers.get(arg);\ntry {\nreturn am == null? 0 : (Double) am.get();\n} catch (Exception e) {\nreturn 0.0;\n}\n}\npublic boolean has(char arg) {\nreturn argsFound.contains(arg);\n}\n}\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Listing 14-16 (continued)\nArgs.java\n")])])]),t("p",[e._v("250 "),t("strong",[e._v("Chapter 14: Successive Refinement")])]),e._v(" "),t("p",[e._v("The majority of the changes to the Argsclass were deletions. A lot of code just got\nmoved out of Args and put into ArgsException. Nice. We also moved all the\nArgumentMarshallers into their own files. Nicer!")]),e._v(" "),t("p",[e._v("Much of good software design is simply about partitioning—creating appropriate\nplaces to put different kinds of code. This separation of concerns makes the code much\nsimpler to understand and maintain.")]),e._v(" "),t("p",[e._v("Of special interest is the errorMessagemethod of ArgsException. Clearly it was a vio-\nlation of the SRP to put the error message formatting into Args.Argsshould be about the\nprocessing of arguments, not about the format of the error messages. However, does it\nreally make sense to put the error message formatting code into ArgsException?")]),e._v(" "),t("p",[e._v("Frankly, it’s a compromise. Users who don’t like the error messages supplied by\nArgsExceptionwill have to write their own. But the convenience of having canned error\nmessages already prepared for you is not insignificant.")]),e._v(" "),t("p",[e._v("By now it should be clear that we are within striking distance of the final solution that\nappeared at the start of this chapter. I’ll leave the final transformations to you as an exercise.")]),e._v(" "),t("h2",{attrs:{id:"conclusion"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[e._v("#")]),e._v(" Conclusion .")]),e._v(" "),t("p",[e._v("It is not enough for code to work. Code that works is often badly broken. Programmers\nwho satisfy themselves with merely working code are behaving unprofessionally. They\nmay fear that they don’t have time to improve the structure and design of their code, but I\ndisagree. Nothing has a more profound and long-term degrading effect upon a develop-\nment project than bad code. Bad schedules can be redone, bad requirements can be rede-\nfined. Bad team dynamics can be repaired. But bad code rots and ferments, becoming an\ninexorable weight that drags the team down. Time and time again I have seen teams grind\nto a crawl because, in their haste, they created a malignant morass of code that forever\nthereafter dominated their destiny.")]),e._v(" "),t("p",[e._v("Of course bad code can be cleaned up. But it’s very expensive. As code rots, the mod-\nules insinuate themselves into each other, creating lots of hidden and tangled dependen-\ncies. Finding and breaking old dependencies is a long and arduous task. On the other hand,\nkeeping code clean is relatively easy. If you made a mess in a module in the morning, it is\neasy to clean it up in the afternoon. Better yet, if you made a mess five minutes ago, it’s\nvery easy to clean it up right now.")]),e._v(" "),t("p",[e._v("So the solution is to continuously keep your code as clean and simple as it can be.\nNever let the rot get started.")])])}),[],!1,null,null,null);r.default=a.exports}}]);