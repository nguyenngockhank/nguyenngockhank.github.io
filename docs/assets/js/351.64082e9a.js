(window.webpackJsonp=window.webpackJsonp||[]).push([[351],{1e3:function(e,t,a){"use strict";a.r(t);var n=a(7),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"chapter-6-version-stamps"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#chapter-6-version-stamps"}},[e._v("#")]),e._v(" Chapter 6. Version Stamps")]),e._v(" "),a("p",[e._v("Many critics of NoSQL databases focus on the lack of support for transactions. Transactions are a\nuseful tool that helps programmers support consistency. One reason why many NoSQL proponents\nworry less about a lack of transactions is that aggregate-oriented NoSQL databases do support atomic\nupdates within an aggregate—and aggregates are designed so that their data forms a natural unit of\nupdate. That said, it’s true that transactional needs are something to take into account when you\ndecide what database to use.")]),e._v(" "),a("p",[e._v("As part of this, it’s important to remember that transactions have limitations. Even within a\ntransactional system we still have to deal with updates that require human intervention and usually\ncannot be run within transactions because they would involve holding a transaction open for too long.\nWe can cope with these using "),a("strong",[e._v("version stamps")]),e._v(" —which turn out to be handy in other situations as well,\nparticularly as we move away from the single-server distribution model.")]),e._v(" "),a("h2",{attrs:{id:"_6-1-business-and-system-transactions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-1-business-and-system-transactions"}},[e._v("#")]),e._v(" 6.1. Business and System Transactions")]),e._v(" "),a("p",[e._v("The need to support update consistency without transactions is actually a common feature of systems\neven when they are built on top of transactional databases. When users think about transactions, they\nusually mean "),a("strong",[e._v("business transactions")]),e._v(". A business transaction may be something like browsing a\nproduct catalog, choosing a bottle of Talisker at a good price, filling in credit card information, and\nconfirming the order. Yet all of this usually won’t occur within the "),a("strong",[e._v("system transaction")]),e._v(" provided by\nthe database because this would mean locking the database elements while the user is trying to find\ntheir credit card and gets called off to lunch by their colleagues.")]),e._v(" "),a("p",[e._v("Usually applications only begin a system transaction at the end of the interaction with the user, so\nthat the locks are only held for a short period of time. The problem, however, is that calculations and\ndecisions may have been made based on data that’s changed. The price list may have updated the\nprice of the Talisker, or someone may have updated the customer’s address, changing the shipping\ncharges.")]),e._v(" "),a("p",[e._v("The broad techniques for handling this are offline concurrency [Fowler PoEAA], useful in NoSQL\nsituations too. A particularly useful approach is the Optimistic Offline Lock [Fowler PoEAA], a form\nof conditional update where a client operation rereads any information that the business transaction\nrelies on and checks that it hasn’t changed since it was originally read and displayed to the user. A\ngood way of doing this is to ensure that records in the database contain some form of "),a("strong",[e._v("version stamp")]),e._v(" :\na field that changes every time the underlying data in the record changes. When you read the data you\nkeep a note of the version stamp, so that when you write data you can check to see if the version has\nchanged.")]),e._v(" "),a("p",[e._v("You may have come across this technique with updating resources with HTTP. One way\nof doing this is to use etags. Whenever you get a resource, the server responds with an etag in the\nheader. This etag is an opaque string that indicates the version of the resource. If you then update that resource, you can use a conditional update by supplying the etag that you got from your last GET. If the resource has changed on the server, the etags won’t match and the server will refuse the update,\nreturning a "),a("em",[e._v("412 (Precondition Failed)")]),e._v(" response.")]),e._v(" "),a("p",[e._v("Some databases provide a similar mechanism of conditional update that allows you to ensure\nupdates won’t be based on stale data. You can do this check yourself, although you then have to")]),e._v(" "),a("p",[e._v("ensure no other thread can run against the resource between your read and your update. (Sometimes\nthis is called a compare-and-set (CAS) operation, whose name comes from the CAS operations done\nin processors. The difference is that a processor CAS compares a value before setting it, while a\ndatabase conditional update compares a version stamp of the value.)")]),e._v(" "),a("p",[e._v("There are various ways you can construct your version stamps. You can use a counter, always\nincrementing it when you update the resource. Counters are useful since they make it easy to tell if one\nversion is more recent than another. On the other hand, they require the server to generate the counter\nvalue, and also need a single master to ensure the counters aren’t duplicated.")]),e._v(" "),a("p",[e._v("Another approach is to create a GUID, a large random number that’s guaranteed to be unique.\nThese use some combination of dates, hardware information, and whatever other sources of\nrandomness they can pick up. The nice thing about GUIDs is that they can be generated by anyone and\nyou’ll never get a duplicate; a disadvantage is that they are large and can’t be compared directly for\nrecentness.")]),e._v(" "),a("p",[e._v("A third approach is to make a hash of the contents of the resource. With a big enough hash key size,\na content hash can be globally unique like a GUID and can also be generated by anyone; the advantage\nis that they are deterministic—any node will generate the same content hash for same resource data.\nHowever, like GUIDs they can’t be directly compared for recentness, and they can be lengthy.")]),e._v(" "),a("p",[e._v("A fourth approach is to use the timestamp of the last update. Like counters, they are reasonably\nshort and can be directly compared for recentness, yet have the advantage of not needing a single\nmaster. Multiple machines can generate timestamps—but to work properly, their clocks have to be\nkept in sync. One node with a bad clock can cause all sorts of data corruptions. There’s also a danger\nthat if the timestamp is too granular you can get duplicates—it’s no good using timestamps of a\nmillisecond precision if you get many updates per millisecond.")]),e._v(" "),a("p",[e._v("You can blend the advantages of these different version stamp schemes by using more than one of\nthem to create a composite stamp. For example, CouchDB uses a combination of counter and content\nhash. Most of the time this allows version stamps to be compared for recentness, even when you use\npeer-to-peer replication. Should two peers update at the same time, the combination of the same count\nand different content hashes makes it easy to spot the conflict.")]),e._v(" "),a("p",[e._v("As well as helping to avoid update conflicts, version stamps are also useful for providing session\nconsistency (p. 52 ).")]),e._v(" "),a("h2",{attrs:{id:"_6-2-version-stamps-on-multiple-nodes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-2-version-stamps-on-multiple-nodes"}},[e._v("#")]),e._v(" 6.2. Version Stamps on Multiple Nodes")]),e._v(" "),a("p",[e._v("The basic version stamp works well when you have a single authoritative source for data, such as a\nsingle server or master-slave replication. In that case the version stamp is controlled by the master.\nAny slaves follow the master’s stamps. But this system has to be enhanced in a peer-to-peer\ndistribution model because there’s no longer a single place to set the version stamps.")]),e._v(" "),a("p",[e._v("If you’re asking two nodes for some data, you run into the chance that they may give you different\nanswers. If this happens, your reaction may vary depending on the cause of that difference. It may be\nthat an update has only reached one node but not the other, in which case you can accept the latest\n(assuming you can tell which one that is). Alternatively, you may have run into an inconsistent update,\nin which case you need to decide how to deal with that. In this situation, a simple GUID or etag won’t\nsuffice, since these don’t tell you enough about the relationships.")]),e._v(" "),a("p",[e._v("The simplest form of version stamp is a counter. Each time a node updates the data, it increments the counter and puts the value of the counter into the version stamp. If you have blue and green slave\nreplicas of a single master, and the blue node answers with a version stamp of 4 and the green node\nwith 6, you know that the green’s answer is more recent.")]),e._v(" "),a("p",[e._v("In multiple-master cases, we need something fancier. One approach, used by distributed version\ncontrol systems, is to ensure that all nodes contain a history of version stamps. That way you can see\nif the blue node’s answer is an ancestor of the green’s answer. This would either require the clients to\nhold onto version stamp histories, or the server nodes to keep version stamp histories and include\nthem when asked for data. This also detects an inconsistency, which we would see if we get two\nversion stamps and neither of them has the other in their histories. Although version control systems\nkeep these kinds of histories, they aren’t found in NoSQL databases.")]),e._v(" "),a("p",[e._v("A simple but problematic approach is to use timestamps. The main problem here is that it’s usually\ndifficult to ensure that all the nodes have a consistent notion of time, particularly if updates can\nhappen rapidly. Should a node’s clock get out of sync, it can cause all sorts of trouble. In addition,\nyou can’t detect write-write conflicts with timestamps, so it would only work well for the single-\nmaster case—and then a counter is usually better.")]),e._v(" "),a("p",[e._v("The most common approach used by peer-to-peer NoSQL systems is a special form of version\nstamp which we call a vector stamp. In essence, a "),a("strong",[e._v("vector stamp")]),e._v(" is a set of counters, one for each\nnode. A vector stamp for "),a("em",[e._v("three nodes (blue, green, black)")]),e._v(" would look something like "),a("em",[a("code",[e._v("[blue: 43, green: 54, black: 12]")])]),e._v(". Each time a node has an internal update, it updates its own counter, so an\nupdate in the green node would change the vector to "),a("em",[a("code",[e._v("[blue: 43, green: 55, black: 12]")])]),e._v(".\nWhenever two nodes communicate, they synchronize their vector stamps. There are several variations\nof exactly how this synchronization is done. We’re coining the term “vector stamp” as a general term\nin this book; you’ll also come across "),a("strong",[e._v("vector clocks")]),e._v(" and "),a("strong",[e._v("version vectors")]),e._v(" —these are specific forms of vector stamps that differ in how they synchronize.")]),e._v(" "),a("p",[e._v("By using this scheme you can tell if one version stamp is newer than another because the newer\nstamp will have all its counters greater than or equal to those in the older stamp. So "),a("em",[a("code",[e._v("[blue: 1, green: 2, black: 5]")])]),e._v(" is newer than "),a("em",[a("code",[e._v("[blue:1, green: 1, black 5]")])]),e._v(" since one of its counters is\ngreater. If both stamps have a counter greater than the other, e.g. "),a("em",[a("code",[e._v("[blue: 1, green: 2, black: 5]* and *[blue: 2, green: 1, black: 5]")])]),e._v(", then you have a write-write conflict.")]),e._v(" "),a("p",[e._v("There may be missing values in the vector, in which case we use treat the missing value as 0. So\n"),a("em",[a("code",[e._v("[blue: 6, black: 2]")])]),e._v(" would be treated as "),a("em",[a("code",[e._v("[blue: 6, green: 0, black: 2]")])]),e._v(". This allows you to\neasily add new nodes without invalidating the existing vector stamps.")]),e._v(" "),a("p",[e._v("Vector stamps are a valuable tool that spots inconsistencies, but doesn’t resolve them. Any conflict resolution will depend on the domain you are working in. This is part of the consistency/latency tradeoff. You either have to live with the fact that network partitions may make your system unavailable, or you have to detect and deal with inconsistencies.")]),e._v(" "),a("h2",{attrs:{id:"_6-3-key-points"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-3-key-points"}},[e._v("#")]),e._v(" 6.3. Key Points")]),e._v(" "),a("ul",[a("li",[e._v("Version stamps help you detect concurrency conflicts. When you read data, then update it, you can check the version stamp to ensure nobody updated the data between your read and write.")]),e._v(" "),a("li",[e._v("Version stamps can be implemented using counters, GUIDs, content hashes, timestamps, or a combination of these.")]),e._v(" "),a("li",[e._v("With distributed systems, a vector of version stamps allows you to detect when different nodes have conflicting updates.")])])])}),[],!1,null,null,null);t.default=s.exports}}]);