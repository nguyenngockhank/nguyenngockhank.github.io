(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{1424:function(e,s,t){"use strict";t.r(s);var a=t(7),n=Object(a.a)({},(function(){var e=this,s=e.$createElement,a=e._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"design-facebook-messenger"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#design-facebook-messenger"}},[e._v("#")]),e._v(" Design Facebook Messenger")]),e._v(" "),a("p",[e._v("Let's design an instant messaging service like Facebook Messenger\nwhere users can send text messages to each other through web and\nmobile interfaces.")]),e._v(" "),a("h2",{attrs:{id:"_1-what-is-facebook-messenger"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-what-is-facebook-messenger"}},[e._v("#")]),e._v(" "),a("strong",[e._v("1. What is Facebook Messenger?")])]),e._v(" "),a("p",[e._v("Facebook Messenger is a software application which provides text-based\ninstant messaging services to its users. Messenger users can chat with\ntheir Facebook friends both from cell-phones and Facebook's website.")]),e._v(" "),a("h2",{attrs:{id:"_2-requirements-and-goals-of-the-system"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-requirements-and-goals-of-the-system"}},[e._v("#")]),e._v(" "),a("strong",[e._v("2. Requirements and Goals of the System")])]),e._v(" "),a("p",[e._v("Our Messenger should meet the following requirements:")]),e._v(" "),a("h3",{attrs:{id:"functional-requirements"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#functional-requirements"}},[e._v("#")]),e._v(" "),a("strong",[e._v("Functional Requirements:")])]),e._v(" "),a("ol",[a("li",[e._v("Messenger should support one-on-one conversations between users.")]),e._v(" "),a("li",[e._v("Messenger should keep track of the online/offline statuses of its users.")]),e._v(" "),a("li",[e._v("Messenger should support persistent storage of chat history.")])]),e._v(" "),a("h3",{attrs:{id:"non-functional-requirements"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#non-functional-requirements"}},[e._v("#")]),e._v(" "),a("strong",[e._v("Non-functional Requirements:")])]),e._v(" "),a("ol",[a("li",[e._v("Users should have real-time chat experience with minimum latency.")]),e._v(" "),a("li",[e._v("Our system should be highly consistent; users should be able to see the same chat history on all their devices.")]),e._v(" "),a("li",[e._v("Messenger's high availability is desirable; we can tolerate lower availability in the interest of consistency.")])]),e._v(" "),a("h3",{attrs:{id:"extended-requirements"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#extended-requirements"}},[e._v("#")]),e._v(" "),a("strong",[e._v("Extended Requirements:")])]),e._v(" "),a("ul",[a("li",[e._v("Group Chats: Messenger should support multiple people talking to each other in a group.")]),e._v(" "),a("li",[e._v("Push notifications: Messenger should be able to notify users of new messages when they are offline.")])]),e._v(" "),a("h2",{attrs:{id:"_3-capacity-estimation-and-constraints"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-capacity-estimation-and-constraints"}},[e._v("#")]),e._v(" "),a("strong",[e._v("3. Capacity Estimation and Constraints")])]),e._v(" "),a("p",[e._v("Let's assume that we have 500 million daily active users and on\naverage each user sends 40 messages daily; this gives us 20 billion\nmessages per day.")]),e._v(" "),a("p",[a("strong",[e._v("Storage Estimation:")]),e._v(" Let's assume that on average a message is 100\nbytes, so to store all the messages for one day we would need 2TB of\nstorage.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("20 billion messages * 100 bytes =2 TB/day\n")])])]),a("p",[e._v("To store five years of chat history, we would need 3.6 petabytes of storage.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("2 TB * 365 days * 5 years ~= 3.6 PB\n")])])]),a("p",[e._v("Other than the chat messages, we would also need to store users'\ninformation, messages' metadata (ID, Timestamp, etc.). Not to mention,\nthe above calculation doesn't take data compression and replication in\nconsideration.")]),e._v(" "),a("p",[a("strong",[e._v("Bandwidth Estimation:")]),e._v(" If our service is getting 2TB of data every\nday, this will give us 25MB of incoming data for each second.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("2 TB / 86400 sec ~= 25 MB/s\n")])])]),a("p",[e._v("Since each incoming message needs to go out to another user, we will\nneed the same amount of bandwidth 25MB/s for both upload and download.")]),e._v(" "),a("p",[a("strong",[e._v("High level estimates:")])]),e._v(" "),a("p",[e._v("Total messages 20 billion per day"),a("br"),e._v("\nStorage for each day 2TB"),a("br"),e._v("\nStorage for 5 years 3.6PB"),a("br"),e._v("\nIncomming data 25MB/s"),a("br"),e._v("\nOutgoing data 25MB/s")]),e._v(" "),a("h2",{attrs:{id:"_4-high-level-design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-high-level-design"}},[e._v("#")]),e._v(" "),a("strong",[e._v("4. High Level Design")])]),e._v(" "),a("p",[e._v("At a high-level, we will need a chat server that will be the central\npiece, orchestrating all the"),a("br"),e._v("\ncommunications between users. When a user wants to send a message to\nanother user, they will connect to the chat server and send the\nmessage to the server; the server then passes that message to the\nother user and also stores it in the database.")]),e._v(" "),a("p",[a("img",{attrs:{src:t(617),alt:"img"}}),a("br"),e._v(" "),a("em",[e._v("Request flow for sending a message")])]),e._v(" "),a("p",[e._v("The detailed workflow would look like this:")]),e._v(" "),a("ol",[a("li",[e._v("User-A sends a message to User-B through the chat server.")]),e._v(" "),a("li",[e._v("The server receives the message and sends an acknowledgment to User-A.")]),e._v(" "),a("li",[e._v("The server stores the message in its database and sends the message to User-B.")]),e._v(" "),a("li",[e._v("User-B receives the message and sends the acknowledgment to the server.")]),e._v(" "),a("li",[e._v("The server notifies User-A that the message has been delivered successfully to User-B.")])]),e._v(" "),a("h2",{attrs:{id:"_5-detailed-component-design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-detailed-component-design"}},[e._v("#")]),e._v(" "),a("strong",[e._v("5. Detailed Component Design")])]),e._v(" "),a("p",[e._v("Let's try to build a simple solution first where everything runs on\none server. At the high level our system needs to handle the following\nuse cases:")]),e._v(" "),a("ol",[a("li",[e._v("Receive incoming messages and deliver outgoing messages.")]),e._v(" "),a("li",[e._v("Store and retrieve messages from the database.")]),e._v(" "),a("li",[e._v("Keep a record of which user is online or has gone offline, and notify all the relevant users about these status changes.")])]),e._v(" "),a("p",[e._v("Let's talk about these scenarios one by one:")]),e._v(" "),a("h3",{attrs:{id:"a-messages-handling"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#a-messages-handling"}},[e._v("#")]),e._v(" "),a("strong",[e._v("a. Messages Handling")])]),e._v(" "),a("p",[a("strong",[e._v("How would we efficiently send/receive messages?")]),e._v(" To send messages,\na user needs to connect to the server and post messages for the other\nusers. To get a message from the server, the user has two options:")]),e._v(" "),a("ol",[a("li",[a("strong",[e._v("Pull model:")]),e._v(" Users can periodically ask the server if there are any new messages for them.")]),e._v(" "),a("li",[a("strong",[e._v("Push model:")]),e._v(" Users can keep a connection open with the server and can depend upon the server to notify them whenever there are new messages.")])]),e._v(" "),a("p",[e._v("If we go with our first approach, then the server needs to keep track\nof messages that are still waiting to be delivered, and as soon as the\nreceiving user connects to the server to ask for any new message, the\nserver can return all the pending messages. To minimize latency for\nthe user, they have to check the server quite frequently, and most of\nthe time they will be getting an empty response if there are no\npending message. This will waste a lot of resources and does not look\nlike an efficient solution.")]),e._v(" "),a("p",[e._v("If we go with our second approach, where all the active users keep a\nconnection open with the server, then as soon as the server receives a\nmessage it can immediately pass the message to the intended user. This\nway, the server does not need to keep track of the pending messages,\nand we will have minimum latency, as the messages are delivered\ninstantly on the opened connection.")]),e._v(" "),a("p",[a("strong",[e._v("How will clients maintain an open connection with the server?")]),e._v(" We can use HTTP Long Polling or\nWebSockets. In long polling, clients can request information from the server\nwith the expectation that the server may not respond immediately. If\nthe server has no new data for the client when the poll is received,\ninstead of sending an empty response, the server holds the request open and waits for\nresponse information to become available. Once it does have new\ninformation, the server immediately sends the response to the client,\ncompleting the open request. Upon receipt of the server response, the\nclient can immediately issue another server request for future updates.\nThis gives a lot of improvements in latencies, throughputs, and\nperformance. The long polling request can timeout or can receive a\ndisconnect from the server, in that case, the client has to open a new\nrequest.")]),e._v(" "),a("p",[a("strong",[e._v("How can the server keep track of all the opened connection to redirect messages to the users efficiently?")]),e._v(' The server can maintain a hash table, where "key" would be the UserID and "value" would be the connection object. So whenever the server receives a message for a user, it looks up that user in the hash table to find the connection object\nand sends the message on the open request.')]),e._v(" "),a("p",[a("strong",[e._v("What will happen when the server receives a message for a user who has gone offline?")]),e._v(" If the receiver has disconnected, the server can notify the sender about the delivery failure. If it is a temporary disconnect, e.g., the receiver's long-poll request just timed out, then we should expect a reconnect from the user. In that case, we can ask the sender to retry sending the message. This retry could be embedded in the client's logic so that users don't have to retype the message. The server can also store the message for a while and retry sending it once the receiver reconnects.")]),e._v(" "),a("p",[a("strong",[e._v("How many chat servers we need?")]),e._v(" Let's plan for 500 million\nconnections at any time. Assuming a modern server can handle 50K\nconcurrent connections at any time, we would need 10K such servers.")]),e._v(" "),a("p",[a("strong",[e._v("How do we know which server holds the connection to which user?")]),e._v(" We\ncan introduce a software load balancer in front of our chat servers;\nthat can map each UserID to a server to redirect the request.")]),e._v(" "),a("p",[a("strong",[e._v("How should the server process a 'deliver message' request?")]),e._v(" The\nserver needs to do the following things upon receiving a new message:")]),e._v(" "),a("ol",[a("li",[e._v("Store the message in the database")]),e._v(" "),a("li",[e._v("Send the message to the receiver and")]),e._v(" "),a("li",[e._v("Send an acknowledgment to the sender.")])]),e._v(" "),a("p",[e._v("The chat server will first find the server that holds the connection for\nthe receiver and pass the message to that server to send it to the\nreceiver. The chat server can then send the acknowledgment to the\nsender; we don't need to wait for storing the message in the database\n(this can happen in the background). Storing the message is discussed in the next section.")]),e._v(" "),a("p",[a("strong",[e._v("How does the messenger maintain the sequencing of the messages?")]),e._v(" We\ncan store a timestamp with each message, which is the time the message\nis received by the server. This will still not ensure correct ordering\nof messages for clients. The scenario where the server timestamp cannot\ndetermine the exact order of messages would look like this:")]),e._v(" "),a("ol",[a("li",[e._v("User-1 sends a message M1 to the server for User-2.")]),e._v(" "),a("li",[e._v("The server receives M1 at T1.")]),e._v(" "),a("li",[e._v("Meanwhile, User-2 sends a message M2 to the server for User-1.")]),e._v(" "),a("li",[e._v("The server receives the message M2 at T2, such that T2 \\T1.")]),e._v(" "),a("li",[e._v("The server sends message M1 to User-2 and M2 to User-1.")])]),e._v(" "),a("p",[e._v("So User-1 will see M1 first and then M2, whereas User-2 will see M2\nfirst and then M1.")]),e._v(" "),a("p",[e._v("To resolve this, we need to keep a sequence number with every message\nfor each client. This sequence number will determine the exact ordering\nof messages for EACH user. With this solution both clients will see a\ndifferent view of the message sequence, but this view will be consistent\nfor them on all devices.")]),e._v(" "),a("h3",{attrs:{id:"b-storing-and-retrieving-the-messages-from-the-database"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#b-storing-and-retrieving-the-messages-from-the-database"}},[e._v("#")]),e._v(" "),a("strong",[e._v("b. Storing and retrieving the messages from the database")])]),e._v(" "),a("p",[e._v("Whenever the chat server receives a new message, it needs to store it in\nthe database. To do so, we have two options:")]),e._v(" "),a("ol",[a("li",[e._v("Start a separate thread, which will work with the database to store the message.")]),e._v(" "),a("li",[e._v("Send an asynchronous request to the database to store the message.")])]),e._v(" "),a("p",[e._v("We have to keep certain things in mind while designing our database:")]),e._v(" "),a("ol",[a("li",[e._v("How to efficiently work with the database connection pool.")]),e._v(" "),a("li",[e._v("How to retry failed requests.")]),e._v(" "),a("li",[e._v("Where to log those requests that failed even after some retries.")]),e._v(" "),a("li",[e._v("How to retry these logged requests (that failed after the retry) when all the issues have resolved.")])]),e._v(" "),a("p",[a("strong",[e._v("Which storage system we should use?")]),e._v(" We need to have a database that\ncan support a very high rate of small updates and also fetch a range of\nrecords quickly. This is required because we have a huge number of small\nmessages that need to be inserted in the database and, while querying, a\nuser is mostly interested in sequentially accessing the messages.")]),e._v(" "),a("p",[e._v("We cannot use RDBMS like MySQL or NoSQL like MongoDB because we cannot\nafford to read/write a row from the database every time a user\nreceives/sends a message. This will not only make the basic operations\nof our service run with high latency, but also create a huge load on\ndatabases.")]),e._v(" "),a("p",[e._v("Both of our requirements can be easily met with a wide-column database\nsolution like "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Apache_HBase",target:"_blank",rel:"noopener noreferrer"}},[e._v("HBase"),a("OutboundLink")],1),e._v(". HBase is a column-oriented key-value NoSQL database that cmultiple values against one key into multiple columns. HBase is modeled after Google's "),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Bigtable",target:"_blank",rel:"noopener noreferrer"}},[e._v("Bigtable"),a("OutboundLink")],1),e._v(" and runs on top of Hadoop Distributed File System ("),a("a",{attrs:{href:"https://en.wikipedia.org/wiki/Apache_Hadoop",target:"_blank",rel:"noopener noreferrer"}},[e._v("HFFS"),a("OutboundLink")],1),e._v(").\nHBase groups data together to store new data in a memory buffer and,\nonce the buffer is full, it dumps the data to the disk. This way of\nstorage not only helps storing a lot of small data quickly, but also\nfetching rows by the key or scanning ranges of rows. HBase is also an\nefficient database to store variably sized data, which is also required\nby our service.")]),e._v(" "),a("p",[a("strong",[e._v("How should clients efficiently fetch data from the server?")]),e._v(" Clients\nshould paginate while fetching data from the server. Page size could be\ndifferent for different clients, e.g., cell phones have smaller screens,\nso we need a fewer number of message/conversations in the viewport.")]),e._v(" "),a("h3",{attrs:{id:"c-managing-user-s-status"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#c-managing-user-s-status"}},[e._v("#")]),e._v(" "),a("strong",[e._v("c. Managing user's status")])]),e._v(" "),a("p",[e._v("We need to keep track of user's online/offline status and notify all the\nrelevant users whenever a status change happens. Since we are\nmaintaining a connection object on the server for all active users, we\ncan easily figure out the user's current status from this. With 500M\nactive users at any time, if we have to broadcast each status change to all the relevant active users, it will\nconsume a lot of resources. We can do the following optimization\naround this:")]),e._v(" "),a("ol",[a("li",[e._v("Whenever a client starts the app, it can pull the current status\nof all users in their friends' list. 2. Whenever a user sends a\nmessage to another user that has gone offline, we can send a failure\nto the sender and update the status on the client.")]),e._v(" "),a("li",[e._v("Whenever a user comes online, the server can always broadcast that\nstatus with a delay of a few seconds to see if the user does not go\noffline immediately.")]),e._v(" "),a("li",[e._v("Client's can pull the status from the server about those users\nthat are being shown on the user's viewport. This should not be a\nfrequent operation, as the server is broadcasting the online status of\nusers and we can live with the stale offline status of users for a\nwhile.")]),e._v(" "),a("li",[e._v("Whenever the client starts a new chat with another user, we can\npull the status at that time.")])]),e._v(" "),a("p",[a("img",{attrs:{src:t(618),alt:"img"}}),e._v(" "),a("em",[e._v("Detailed component design for Facebook messenger")])]),e._v(" "),a("p",[a("strong",[e._v("Design Summary:")]),e._v(" Clients will open a connection to the chat server\nto send a message; the server will then pass it to the requested user.\nAll the active users will keep a connection open with the server to\nreceive messages. Whenever a new message arrives, the chat server will\npush it to the receiving user on the long poll request. Messages can\nbe stored in HBase, which supports quick small updates, and range based searches. The servers can broadcast the online status of a user to other relevant users. Clients can pull status updates for users who\nare visible in the client's viewport on a less frequent basis.")]),e._v(" "),a("h2",{attrs:{id:"_6-data-partitioning"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-data-partitioning"}},[e._v("#")]),e._v(" "),a("strong",[e._v("6. Data partitioning")])]),e._v(" "),a("p",[e._v("Since we will be storing a lot of data (3.6PB for five years), we need\nto distribute it onto multiple database servers. What will be our\npartitioning scheme?")]),e._v(" "),a("p",[a("strong",[e._v("Partitioning based on UserID:")]),e._v(" Let's assume we partition based on\nthe hash of the UserID so that we can keep all messages of a user on\nthe same database. If one DB shard is 4TB, we will have "),a("code",[e._v('"3.6PB/4TB ~= 900"')]),e._v(" shards for five years. For simplicity, let's\nassume we keep 1K shards. So we will find the shard number by\n"),a("code",[e._v('"hash(UserID) % 1000"')]),e._v(" and then store / retrieve the data from there.\nThis partitioning scheme will also be very quick to fetch chat history\nfor any user.")]),e._v(" "),a("p",[e._v("In the beginning, we can start with fewer database servers with\nmultiple shards residing on one physical server. Since we can have\nmultiple database instances on a server, we can easily store multiple\npartitions on a single server. Our hash function needs to understand\nthis logical partitioning scheme so that it can map multiple logical\npartitions on one physical server.")]),e._v(" "),a("p",[e._v("Since we will store an unlimited history of messages, we can start\nwith a big number of logical partitions, which will be mapped to fewer\nphysical servers, and as our storage demand increases, we can add more\nphysical servers to distribute our logical partitions.")]),e._v(" "),a("p",[a("strong",[e._v("Partitioning based on MessageID:")]),e._v(" If we store different messages of\na user on separate database shards, fetching a range of messages of a\nchat would be very slow, so we should not adopt this scheme.")]),e._v(" "),a("h2",{attrs:{id:"_7-cache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-cache"}},[e._v("#")]),e._v(" "),a("strong",[e._v("7. Cache")])]),e._v(" "),a("p",[e._v("We can cache a few recent messages (say last 15) in a few recent\nconversations that are visible in a user's viewport (say last 5).\nSince we decided to store all of the user's messages on one shard,\ncache for a user should entirely reside on one machine too.")]),e._v(" "),a("h2",{attrs:{id:"_8-load-balancing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-load-balancing"}},[e._v("#")]),e._v(" "),a("strong",[e._v("8. Load balancing")])]),e._v(" "),a("p",[e._v("We will need a load balancer in front of our chat servers; that can\nmap each UserID to a server that holds the connection for the user and\nthen direct the request to that server. Similarly, we would need a\nload balancer for our cache servers.")]),e._v(" "),a("h2",{attrs:{id:"_9-fault-tolerance-and-replication"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-fault-tolerance-and-replication"}},[e._v("#")]),e._v(" "),a("strong",[e._v("9. Fault tolerance and Replication")])]),e._v(" "),a("p",[a("strong",[e._v("What will happen when a chat server fails?")]),e._v(" Our chat servers are\nholding connections with the users.")]),e._v(" "),a("p",[e._v("If a server goes down, should we devise a mechanism to transfer those\nconnections to some other server? It's extremely hard to failover TCP\nconnections to other servers; an easier approach can be to have\nclients automatically reconnect if the connection is lost.")]),e._v(" "),a("p",[a("strong",[e._v("Should we store multiple copies of user messages?")]),e._v(" We cannot have\nonly one copy of the user's data, because if the server holding the data\ncrashes or is down permanently, we don't have any mechanism to recover that data. For this, either we have to store multiple copies\nof the data on different servers or use techniques like Reed-Solomon\nencoding to distribute and replicate it.")]),e._v(" "),a("h2",{attrs:{id:"_10-extended-requirements"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-extended-requirements"}},[e._v("#")]),e._v(" "),a("strong",[e._v("10. Extended Requirements")])]),e._v(" "),a("h3",{attrs:{id:"a-group-chat"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#a-group-chat"}},[e._v("#")]),e._v(" "),a("strong",[e._v("a. Group chat")])]),e._v(" "),a("p",[e._v("We can have separate group-chat objects in our system that can be\nstored on the chat servers. A group-chat object is identified by\nGroupChatID and will also maintain a list of people who are part of\nthat chat. Our load balancer can direct each group chat message based\non GroupChatID and the server handling that group chat can iterate\nthrough all the users of the chat to find the server handling the\nconnection of each user to deliver the message.")]),e._v(" "),a("p",[e._v("In databases, we can store all the group chats in a separate table\npartitioned based on GroupChatID.")]),e._v(" "),a("h3",{attrs:{id:"b-push-notifications"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#b-push-notifications"}},[e._v("#")]),e._v(" "),a("strong",[e._v("b. Push notifications")])]),e._v(" "),a("p",[e._v("In our current design user's can only send messages to active users\nand if the receiving user is offline, we send a failure to the sending\nuser. Push notifications will enable our system to send messages to\noffline users.")]),e._v(" "),a("p",[e._v("For Push notifications, each user can opt-in from their device (or a\nweb browser) to get notifications whenever there is a new message or\nevent. Each manufacturer maintains a set of servers that handles\npushing these notifications to the user.")]),e._v(" "),a("p",[e._v("To have push notifications in our system, we would need to set up a\nNotification server, which will take the messages for offline users\nand send them to the manufacture's push notification server, which\nwill then send them to the user's device.")])])}),[],!1,null,null,null);s.default=n.exports},617:function(e,s,t){e.exports=t.p+"assets/img/8.05a93505.png"},618:function(e,s,t){e.exports=t.p+"assets/img/9.ffa87928.png"}}]);