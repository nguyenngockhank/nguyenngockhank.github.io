(window.webpackJsonp=window.webpackJsonp||[]).push([[350],{970:function(t,c,a){"use strict";a.r(c);var i=a(7),s=Object(i.a)({},(function(){var t=this,c=t.$createElement,a=t._self._c||c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"concurrent-programming"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#concurrent-programming"}},[t._v("#")]),t._v(" Concurrent Programming")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Concurrency")]),t._v(" "),a("p",[t._v("Xử lý đồng thời - Concurrency - là việc nhiều task được xử lý cùng một lúc.")])]),t._v(" "),a("h2",{attrs:{id:"multithreading"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#multithreading"}},[t._v("#")]),t._v(" Multithreading")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Multithreading")]),t._v(" "),a("p",[t._v("Hình thức đồng thời sử dụng nhiều luồng (threads) thực thi.")])]),t._v(" "),a("p",[t._v("là 1 dạng của concurrency, nhưng không phải là dạng duy nhất. Multithreading được ứng dụng ở thread pool, nơi mà các thread được phân bổ tự động để đáp ứng các request.")]),t._v(" "),a("h2",{attrs:{id:"asynchronous"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#asynchronous"}},[t._v("#")]),t._v(" Asynchronous")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Multithreading")]),t._v(" "),a("p",[t._v("Hình thức đồng thời sử dụng nhiều callbacks để tránh các threads không cần thiết.")])]),t._v(" "),a("p",[t._v("1 thể loại khác của concurrency vô cùng mạnh mẽ, sử dụng keywork async và await, lập trình đơn giản như synchronous (nonconcurrent).")]),t._v(" "),a("h2",{attrs:{id:"parallel-processing"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parallel-processing"}},[t._v("#")]),t._v(" Parallel Processing")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Parallel Processing")]),t._v(" "),a("p",[t._v("Parallel processing (hay là parallel programming) sử dụng multithreading để tối ưu hóa việc sử dụng nhiều processor. Các CPUs ngày nay đều có nhiều core, nếu có nhiều công việc cần xử lý, Parallel processing sẽ chia nhỏ công việc ra nhiều thread, và các thread có thể chạy độc lập trên mỗi core khác nhau.")])]),t._v(" "),a("p",[t._v("Parallel processing là 1 loại của Multithreading và multithreading là 1 loại của concurrency.")]),t._v(" "),a("h2",{attrs:{id:"queue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#queue"}},[t._v("#")]),t._v(" Queue")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Serial Queue")]),t._v(" "),a("p",[t._v("là hàng đợi thực hiện theo tuần tự.")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Concurrent Queue")]),t._v(" "),a("p",[t._v("là hàng đợi thực hiện đồng thời.")])]),t._v(" "),a("h2",{attrs:{id:"locking"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#locking"}},[t._v("#")]),t._v(" Locking")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("TIP")]),t._v(" "),a("p",[a("strong",[t._v("Pessimistic approaches")]),t._v(" lock data records to prevent conflicts.\n"),a("strong",[t._v("Optimistic approaches")]),t._v(" detect conflicts and fix them.")])]),t._v(" "),a("p",[t._v("Optimistic Locking sử dụng phù hợp trong các trường hợp có nghiệp vụ xác suất conflict giữa 2 transaction là thấp. Nhược điểm của Optimistic Offline Locking là chỉ verify trên các câu lệnh UPDATE và DELETE, vẫn có thể gây ra inconsistent khi read dữ liệu.")]),t._v(" "),a("p",[t._v("Pessimistic Locking sử dụng phù hợp trong các nghiệp vụ có khả năng xảy ra conflict cao. Nếu bạn sử dụng Pessimistic Lock, bạn nên cân nhắc đến việc xử lý timeout cho các long transaction để tránh deadlock.")]),t._v(" "),a("h2",{attrs:{id:"critical-section"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#critical-section"}},[t._v("#")]),t._v(" Critical section")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Critical section")]),t._v(" "),a("p",[t._v("Critical section là một đoạn code chỉ được thực thi duy nhất bởi một thread nào đó tại một thời điểm. Nếu có nhiều hơn một thread thực thi đoạn code này sẽ xảy ra lỗi.")])]),t._v(" "),a("p",[t._v("Ví dụ đó có thể là đoạn code truy cập tới các shared resources như file, data, global variables,…")]),t._v(" "),a("h2",{attrs:{id:"race-condition"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#race-condition"}},[t._v("#")]),t._v(" Race condition")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Race condition")]),t._v(" "),a("p",[t._v("Race condition: là khi nhiều threads access vào một shared source mà không đảm bảo rằng thread này kết thúc thực thi trên dữ liệu trước khi thread kia truy cập dữ liệu. Nghĩa là các threads đồng thời cùng đọc và cùng ghi trên dữ liệu. Có thể hiểu race condition là trường hợp sẽ xảy ra nếu không quản lý tốt critical section.")])]),t._v(" "),a("h2",{attrs:{id:"deadlock"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#deadlock"}},[t._v("#")]),t._v(" Deadlock")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Deadlock")]),t._v(" "),a("p",[t._v("là hiện tượng hai hay nhiều tác vụ phải chờ đợi lẫn nhau để hoàn thành.")])]),t._v(" "),a("h2",{attrs:{id:"thread-safe"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#thread-safe"}},[t._v("#")]),t._v(" Thread safe")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Thread safe")]),t._v(" "),a("p",[t._v("một code được gọi là thread safe code khi trong môi trường multi-threading, nó được thực thi mà không xảy ra bất cứ lỗi nào.")])]),t._v(" "),a("h2",{attrs:{id:"atomicity"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#atomicity"}},[t._v("#")]),t._v(" Atomicity")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Atomicity")]),t._v(" "),a("p",[t._v("một tác vụ hoặc một công việc cụ thể được cho là atomic khi nó không thể bị gián đoạn. Có nghĩa là nó được đảm bảo sẽ được hoàn thành, không có trường hợp trả ra một trạng thái không hợp lệ nào đó (lỗi). Đây cũng là một ví dụ của thread safe.")])]),t._v(" "),a("h2",{attrs:{id:"lamport-s-bakery-algorithm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#lamport-s-bakery-algorithm"}},[t._v("#")]),t._v(" Lamport's bakery algorithm")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("Lamport's bakery algorithm")]),t._v(" "),a("p",[t._v("Lamport's bakery algorithm is a computer algorithm devised by computer scientist Leslie Lamport, as part of his long study of the formal correctness of concurrent systems, which is intended to improve the safety in the usage of shared resources among multiple threads by means of mutual exclusion.")])]),t._v(" "),a("h2",{attrs:{id:"references"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[t._v("#")]),t._v(" References")]),t._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://medium.com/@lvhan/concurrent-programming-v%C3%A0-gcd-part-1-c701cf180de6",target:"_blank",rel:"noopener noreferrer"}},[t._v("Concurrent Programming và GCD (Part 1)"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://viblo.asia/p/concurrency-programming-guide-63vKjpYdl2R",target:"_blank",rel:"noopener noreferrer"}},[t._v("Concurrency Programming Guide"),a("OutboundLink")],1)]),t._v(" "),a("li",[a("a",{attrs:{href:"https://viblo.asia/p/parallel-processing-concurrency-va-async-programming-OeVKBdj0lkW",target:"_blank",rel:"noopener noreferrer"}},[t._v("Parallel Processing, Concurrency, và Async Programming"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);c.default=s.exports}}]);