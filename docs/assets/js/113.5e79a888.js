(window.webpackJsonp=window.webpackJsonp||[]).push([[113],{698:function(e,t,a){"use strict";a.r(t);var s=a(7),o=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"a-philosophy-of-software-design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#a-philosophy-of-software-design"}},[e._v("#")]),e._v(" A Philosophy of Software Design")]),e._v(" "),a("h2",{attrs:{id:"tactical-programming-vs-strategic-programming"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#tactical-programming-vs-strategic-programming"}},[e._v("#")]),e._v(" Tactical programming vs Strategic programming")]),e._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[e._v("Tactical Programming")]),e._v(" "),a("p",[e._v("In the tactical approach, your main focus is to get something working, such as a new feature or a bug fix. At first glance this seems totally reasonable: what could be more important than writing code that works? However, tactical programming makes it nearly impossible to produce a good system design.")])]),e._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[e._v("Strategic Programming")]),e._v(" "),a("p",[e._v("The first step towards becoming a good software designer is to realize that "),a("strong",[e._v("working code isn‚Äôt enough.")]),e._v(" It‚Äôs not acceptable to introduce unnecessary complexities in order to finish your current task faster. The most important thing is the long-term structure of the system. Most of the code in any system is written by extending the existing code base, so your most important job as a developer is to facilitate those future extensions. Thus, you should not think of ‚Äúworking code‚Äù as your primary goal, though of course your code must work. Your primary goal must be to produce a great design, which also happens to work. This is strategic programming.")])]),e._v(" "),a("h2",{attrs:{id:"software-trends"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#software-trends"}},[e._v("#")]),e._v(" Software trends")]),e._v(" "),a("h3",{attrs:{id:"object-oriented-programming-and-inheritance"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-oriented-programming-and-inheritance"}},[e._v("#")]),e._v(" Object-oriented programming and inheritance")]),e._v(" "),a("p",[e._v("Implementation inheritance creates dependencies between the parent class and each of its subclasses. Class instance variables in the parent class are often accessed by both the parent and child classes; this results in information leakage between the classes in the inheritance hierarchy and makes it hard to modify one class in the hierarchy without looking at the others.")]),e._v(" "),a("p",[e._v("Thus, implementation inheritance should be used with caution. Before using implementation inheritance, consider whether an approach based on composition can provide the same benefits.")]),e._v(" "),a("h3",{attrs:{id:"agile-development"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#agile-development"}},[e._v("#")]),e._v(" Agile development")]),e._v(" "),a("p",[e._v("One of the risks of agile development is that it can lead to tactical programming. Agile development tends to focus developers on features, not abstractions, and it encourages developers to put off design decisions in order to produce working software as soon as possible.")]),e._v(" "),a("p",[e._v("For example, some agile practitioners argue that you shouldn‚Äôt implement general- purpose mechanisms right away; implement a minimal special-purpose mechanism to start with, and refactor into something more generic later, once you know that it‚Äôs needed. Although these arguments make sense to a degree, they argue against an investment approach, and they encourage a more tactical style of programming. This can result in a rapid accumulation of complexity.")]),e._v(" "),a("h3",{attrs:{id:"test-driven-development"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#test-driven-development"}},[e._v("#")]),e._v(" Test-driven development")]),e._v(" "),a("p",[a("strong",[e._v("The problem with test-driven development is that it focuses attention on getting specific features working, rather than finding the best design.")])]),e._v(" "),a("h3",{attrs:{id:"design-patterns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#design-patterns"}},[e._v("#")]),e._v(" Design patterns")]),e._v(" "),a("p",[e._v("The greatest risk with design patterns is over-application. Not every problem can be solved cleanly with an existing design pattern; don‚Äôt try to force a problem into a design pattern when a custom approach will be cleaner.")]),e._v(" "),a("h3",{attrs:{id:"getters-and-setters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getters-and-setters"}},[e._v("#")]),e._v(" Getters and setters")]),e._v(" "),a("p",[e._v("Getters and setters aren‚Äôt strictly necessary, since instance variables can be made public.")]),e._v(" "),a("p",[e._v("Although it may make sense to use getters and setters if you must expose instance variables, it‚Äôs better not to expose instance variables in the first place. Exposed instance variables mean that part of the class‚Äôs implementation is visible externally, which violates the idea of information hiding and increases the complexity of the class‚Äôs interface.")]),e._v(" "),a("h2",{attrs:{id:"red-flags"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#red-flags"}},[e._v("#")]),e._v(" Red Flags")]),e._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[e._v("üö© Red Flag: Shallow Module üö©")]),e._v(" "),a("p",[e._v("A shallow module is one whose interface is complicated relative to the functionality it provides.\nShallow modules don‚Äôt help much in the battle against complexity, because the benefit they provide (not having to learn about how they work internally) is negated by the cost of learning and using their interfaces.\nSmall modules tend to be shallow.")])]),e._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[e._v("üö© Red Flag: Information Leakage üö©")]),e._v(" "),a("p",[e._v("Information leakage occurs when the same knowledge is used in multiple places, such as two different classes that both understand the format of a particular type of file")])]),e._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[e._v("üö© Red Flag: Temporal Decomposition üö©")]),e._v(" "),a("p",[e._v("In temporal decomposition, execution order is reflected in the code structure: operations that happen at different times are in different methods or classes.\nIf the same knowledge is used at different points in execution, it gets encoded in multiple places, resulting in information\nleakage.")])]),e._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[e._v("üö© Red Flag: Overexposure üö©")]),e._v(" "),a("p",[e._v("If the API for a commonly used feature forces users to learn about other features that are rarely used, this increases the cognitive load on users who don‚Äôt need the rarely used features.")])]),e._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[e._v("üö© Red Flag: Pass-Through Method üö©")]),e._v(" "),a("p",[e._v("A pass-through method is one that does nothing except pass its arguments to another method, usually with the same API as the passthrough method. This typically indicates that there is not a clean division of responsibility between the classes.")])]),e._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[e._v("üö© Red Flag: Repetition üö©")]),e._v(" "),a("p",[e._v("If the same piece of code (or code that is almost the same) appears over and over again, that‚Äôs a red flag that you haven‚Äôt found the right abstractions.")])]),e._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[e._v("üö© Red Flag: Special-General Mixture üö©")]),e._v(" "),a("p",[e._v("This red flag occurs when a general-purpose mechanism also contains code specialized for a particular use of that mechanism. This makes the mechanism more complicated and creates information leakage between the mechanism and the particular use case: future modifications to the use case are likely to require changes to the underlying mechanism as well.")])]),e._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[e._v("üö© Red Flag: Conjoined Methods üö©")]),e._v(" "),a("p",[e._v("It should be possible to understand each method independently. If you can‚Äôt understand the implementation of one method without also understanding the implementation of another, that‚Äôs a red flag.\nThis red flag can occur in other contexts as well: if two pieces of code are physically separated, but each can only be understood by looking at the other, that is a red flag.")])]),e._v(" "),a("h2",{attrs:{id:"notes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#notes"}},[e._v("#")]),e._v(" Notes")]),e._v(" "),a("blockquote",{staticClass:"highlight-quote"},[a("p",[a("em",[e._v("It is more important for a module to have a simple interface than a simple implementation")])])]),a("h2",{attrs:{id:"references"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://blog.pragmaticengineer.com/a-philosophy-of-software-design-review/",target:"_blank",rel:"noopener noreferrer"}},[e._v("A Philosophy of Software Design: My Take (and a Book Review)"),a("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=o.exports}}]);