(window.webpackJsonp=window.webpackJsonp||[]).push([[89],{1066:function(e,t,a){"use strict";a.r(t);var n=a(7),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"chapter-1-why-nosql"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#chapter-1-why-nosql"}},[e._v("#")]),e._v(" Chapter 1. Why NoSQL?")]),e._v(" "),n("p",[e._v("For almost as long as we’ve been in the software profession, relational databases have been the\ndefault choice for serious data storage, especially in the world of enterprise applications. If you’re an\narchitect starting a new project, your only choice is likely to be which relational database to use.\n(And often not even that, if your company has a dominant vendor.) There have been times when a\ndatabase technology threatened to take a piece of the action, such as object databases in the 1990’s,\nbut these alternatives never got anywhere.")]),e._v(" "),n("p",[e._v("After such a long period of dominance, the current excitement about NoSQL databases comes as a\nsurprise. In this chapter we’ll explore why relational databases became so dominant, and why we\nthink the current rise of NoSQL databases isn’t a flash in the pan.")]),e._v(" "),n("h2",{attrs:{id:"_1-1-the-value-of-relational-databases"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-the-value-of-relational-databases"}},[e._v("#")]),e._v(" 1.1. The Value of Relational Databases")]),e._v(" "),n("p",[e._v("Relational databases have become such an embedded part of our computing culture that it’s easy to\ntake them for granted. It’s therefore useful to revisit the benefits they provide.")]),e._v(" "),n("p",[n("strong",[e._v("1.1.1. Getting at Persistent Data")])]),e._v(" "),n("p",[e._v("Probably the most obvious value of a database is keeping large amounts of persistent data. Most\ncomputer architectures have the notion of two areas of memory: a fast volatile “main memory” and a\nlarger but slower “backing store.” Main memory is both limited in space and loses all data when you\nlose power or something bad happens to the operating system. Therefore, to keep data around, we\nwrite it to a backing store, commonly seen a disk (although these days that disk can be persistent\nmemory).")]),e._v(" "),n("p",[e._v("The backing store can be organized in all sorts of ways. For many productivity applications (such\nas word processors), it’s a file in the file system of the operating system. For most enterprise\napplications, however, the backing store is a database. The database allows more flexibility than a\nfile system in storing large amounts of data in a way that allows an application program to get at\nsmall bits of that information quickly and easily.")]),e._v(" "),n("p",[n("strong",[e._v("1.1.2. Concurrency")])]),e._v(" "),n("p",[e._v("Enterprise applications tend to have many people looking at the same body of data at once, possibly\nmodifying that data. Most of the time they are working on different areas of that data, but occasionally\nthey operate on the same bit of data. As a result, we have to worry about coordinating these\ninteractions to avoid such things as double booking of hotel rooms.")]),e._v(" "),n("p",[e._v("Concurrency is notoriously difficult to get right, with all sorts of errors that can trap even the most\ncareful programmers. Since enterprise applications can have lots of users and other systems all\nworking concurrently, there’s a lot of room for bad things to happen. Relational databases help handle\nthis by controlling all access to their data through transactions. While this isn’t a cure-all (you still\nhave to handle a transactional error when you try to book a room that’s just gone), the transactional\nmechanism has worked well to contain the complexity of concurrency.")]),e._v(" "),n("p",[e._v("Transactions also play a role in error handling. With transactions, you can make a change, and if an\nerror occurs during the processing of the change you can roll back the transaction to clean things up.")]),e._v(" "),n("p",[n("strong",[e._v("1.1.3. Integration")])]),e._v(" "),n("p",[e._v("Enterprise applications live in a rich ecosystem that requires multiple applications, written by\ndifferent teams, to collaborate in order to get things done. This kind of inter-application collaboration\nis awkward because it means pushing the human organizational boundaries. Applications often need\nto use the same data and updates made through one application have to be visible to others.")]),e._v(" "),n("p",[e._v("A common way to do this is "),n("strong",[e._v("shared database integration")]),e._v(" [Hohpe and Woolf] where multiple\napplications store their data in a single database. Using a single database allows all the applications\nto use each others’ data easily, while the database’s concurrency control handles multiple\napplications in the same way as it handles multiple users in a single application.")]),e._v(" "),n("p",[n("strong",[e._v("1.1.4. A (Mostly) Standard Model")])]),e._v(" "),n("p",[e._v("Relational databases have succeeded because they provide the core benefits we outlined earlier in a\n(mostly) standard way. As a result, developers and database professionals can learn the basic\nrelational model and apply it in many projects. Although there are differences between different\nrelational databases, the core mechanisms remain the same: Different vendors’ SQL dialects are\nsimilar, transactions operate in mostly the same way.")]),e._v(" "),n("h2",{attrs:{id:"_1-2-impedance-mismatch"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-impedance-mismatch"}},[e._v("#")]),e._v(" 1.2. Impedance Mismatch")]),e._v(" "),n("p",[e._v("Relational databases provide many advantages, but they are by no means perfect. Even from their\nearly days, there have been lots of frustrations with them.")]),e._v(" "),n("p",[e._v("For application developers, the biggest frustration has been what’s commonly called the\n"),n("strong",[e._v("impedance mismatch")]),e._v(" : the difference between the relational model and the in-memory data structures.\nThe relational data model organizes data into a structure of tables and rows, or more properly,\nrelations and tuples. In the relational model, a "),n("strong",[e._v("tuple")]),e._v(" is a set of name-value pairs and a "),n("strong",[e._v("relation")]),e._v(" is a\nset of tuples. (The relational definition of a tuple is slightly different from that in mathematics and\nmany programming languages with a tuple data type, where a tuple is a sequence of values.) All\noperations in SQL consume and return relations, which leads to the mathematically elegant relational\nalgebra.")]),e._v(" "),n("p",[e._v("This foundation on relations provides a certain elegance and simplicity, but it also introduces\nlimitations. In particular, the values in a relational tuple have to be simple—they cannot contain any\nstructure, such as a nested record or a list. This limitation isn’t true for in-memory data structures,\nwhich can take on much richer structures than relations. As a result, if you want to use a richer in-\nmemory data structure, you have to translate it to a relational representation to store it on disk. Hence\nthe impedance mismatch—two different representations that require translation (see Figure 1.1).")]),e._v(" "),n("p",[n("img",{attrs:{src:a(661),alt:"Img"}}),e._v(" "),n("strong",[e._v("Figure 1.1. An order, which looks like a single aggregate structure in the UI, is split into many\nrows from many tables in a relational database")])]),e._v(" "),n("p",[e._v("The impedance mismatch is a major source of frustration to application developers, and in the\n1990s many people believed that it would lead to relational databases being replaced with databases\nthat replicate the in-memory data structures to disk. That decade was marked with the growth of\nobject-oriented programming languages, and with them came object-oriented databases—both\nlooking to be the dominant environment for software development in the new millennium.")]),e._v(" "),n("p",[e._v("However, while object-oriented languages succeeded in becoming the major force in\nprogramming, object-oriented databases faded into obscurity. Relational databases saw off the\nchallenge by stressing their role as an integration mechanism, supported by a mostly standard\nlanguage of data manipulation (SQL) and a growing professional divide between application\ndevelopers and database administrators.")]),e._v(" "),n("p",[e._v("Impedance mismatch has been made much easier to deal with by the wide availability of object-\nrelational mapping frameworks, such as Hibernate and iBATIS that implement well-known mapping\npatterns [Fowler PoEAA], but the mapping problem is still an issue. Object-relational mapping\nframeworks remove a lot of grunt work, but can become a problem of their own when people try too\nhard to ignore the database and query performance suffers.")]),e._v(" "),n("p",[e._v("Relational databases continued to dominate the enterprise computing world in the 2000s, but during\nthat decade cracks began to open in their dominance.")]),e._v(" "),n("h2",{attrs:{id:"_1-3-application-and-integration-databases"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-3-application-and-integration-databases"}},[e._v("#")]),e._v(" 1.3. Application and Integration Databases")]),e._v(" "),n("p",[e._v("The exact reasons why relational databases triumphed over OO databases are still the subject of an\noccasional pub debate for developers of a certain age. But in our view, the primary factor was the\nrole of SQL as an integration mechanism between applications. In this scenario, the database acts as")]),e._v(" "),n("p",[e._v("an "),n("strong",[e._v("integration database")]),e._v(" —with multiple applications, usually developed by separate teams, storing\ntheir data in a common database. This improves communication because all the applications are\noperating on a consistent set of persistent data.")]),e._v(" "),n("p",[e._v("There are downsides to shared database integration. A structure that’s designed to integrate many\napplications ends up being more complex—indeed, often dramatically more complex—than any\nsingle application needs. Furthermore, should an application want to make changes to its data storage,\nit needs to coordinate with all the other applications using the database. Different applications have\ndifferent structural and performance needs, so an index required by one application may cause a\nproblematic hit on inserts for another. The fact that each application is usually a separate team also\nmeans that the database usually cannot trust applications to update the data in a way that preserves\ndatabase integrity and thus needs to take responsibility for that within the database itself.")]),e._v(" "),n("p",[e._v("A different approach is to treat your database as an "),n("strong",[e._v("application database")]),e._v(" —which is only directly\naccessed by a single application codebase that’s looked after by a single team. With an application\ndatabase, only the team using the application needs to know about the database structure, which\nmakes it much easier to maintain and evolve the schema. Since the application team controls both the\ndatabase and the application code, the responsibility for database integrity can be put in the\napplication code.")]),e._v(" "),n("p",[e._v("Interoperability concerns can now shift to the interfaces of the application, allowing for better\ninteraction protocols and providing support for changing them. During the 2000s we saw a distinct\nshift to web services [Daigneau], where applications would communicate over HTTP. Web services\nenabled a new form of a widely used communication mechanism—a challenger to using the SQL with\nshared databases. (Much of this work was done under the banner of “Service-Oriented\nArchitecture”—a term most notable for its lack of a consistent meaning.)")]),e._v(" "),n("p",[e._v("An interesting aspect of this shift to web services as an integration mechanism was that it resulted\nin more flexibility for the structure of the data that was being exchanged. If you communicate with\nSQL, the data must be structured as relations. However, with a service, you are able to use richer\ndata structures with nested records and lists. These are usually represented as documents in XML or,\nmore recently, JSON. In general, with remote communication you want to reduce the number of round\ntrips involved in the interaction, so it’s useful to be able to put a rich structure of information into a\nsingle request or response.")]),e._v(" "),n("p",[e._v("If you are going to use services for integration, most of the time web services—using text over\nHTTP—is the way to go. However, if you are dealing with highly performance-sensitive interactions,\nyou may need a binary protocol. Only do this if you are sure you have the need, as text protocols are\neasier to work with—consider the example of the Internet.")]),e._v(" "),n("p",[e._v("Once you have made the decision to use an application database, you get more freedom of choosing\na database. Since there is a decoupling between your internal database and the services with which\nyou talk to the outside world, the outside world doesn’t have to care how you store your data,\nallowing you to consider nonrelational options. Furthermore, there are many features of relational\ndatabases, such as security, that are less useful to an application database because they can be done\nby the enclosing application instead.")]),e._v(" "),n("p",[e._v("Despite this freedom, however, it wasn’t apparent that application databases led to a big rush to\nalternative data stores. Most teams that embraced the application database approach stuck with\nrelational databases. After all, using an application database yields many advantages even ignoring")]),e._v(" "),n("p",[e._v("the database flexibility (which is why we generally recommend it). Relational databases are familiar\nand usually work very well or, at least, well enough. Perhaps, given time, we might have seen the\nshift to application databases to open a real crack in the relational hegemony—but such cracks came\nfrom another source.")]),e._v(" "),n("h2",{attrs:{id:"_1-4-attack-of-the-clusters"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-4-attack-of-the-clusters"}},[e._v("#")]),e._v(" 1.4. Attack of the Clusters")]),e._v(" "),n("p",[e._v("At the beginning of the new millennium the technology world was hit by the busting of the 1990s dot-\ncom bubble. While this saw many people questioning the economic future of the Internet, the 2000s\ndid see several large web properties dramatically increase in scale.")]),e._v(" "),n("p",[e._v("This increase in scale was happening along many dimensions. Websites started tracking activity\nand structure in a very detailed way. Large sets of data appeared: links, social networks, activity in\nlogs, mapping data. With this growth in data came a growth in users—as the biggest websites grew to\nbe vast estates regularly serving huge numbers of visitors.")]),e._v(" "),n("p",[e._v("Coping with the increase in data and traffic required more computing resources. To handle this\nkind of increase, you have two choices: up or out. Scaling up implies bigger machines, more\nprocessors, disk storage, and memory. But bigger machines get more and more expensive, not to\nmention that there are real limits as your size increases. The alternative is to use lots of small\nmachines in a cluster. A cluster of small machines can use commodity hardware and ends up being\ncheaper at these kinds of scales. It can also be more resilient—while individual machine failures are\ncommon, the overall cluster can be built to keep going despite such failures, providing high\nreliability.")]),e._v(" "),n("p",[e._v("As large properties moved towards clusters, that revealed a new problem—relational databases\nare not designed to be run on clusters. Clustered relational databases, such as the Oracle RAC or\nMicrosoft SQL Server, work on the concept of a shared disk subsystem. They use a cluster-aware file\nsystem that writes to a highly available disk subsystem—but this means the cluster still has the disk\nsubsystem as a single point of failure. Relational databases could also be run as separate servers for\ndifferent sets of data, effectively sharding (“Sharding,” p. 38 ) the database. While this separates the\nload, all the sharding has to be controlled by the application which has to keep track of which\ndatabase server to talk to for each bit of data. Also, we lose any querying, referential integrity,\ntransactions, or consistency controls that cross shards. A phrase we often hear in this context from\npeople who’ve done this is “unnatural acts.”")]),e._v(" "),n("p",[e._v("These technical issues are exacerbated by licensing costs. Commercial relational databases are\nusually priced on a single-server assumption, so running on a cluster raised prices and led to\nfrustrating negotiations with purchasing departments.")]),e._v(" "),n("p",[e._v("This mismatch between relational databases and clusters led some organization to consider an\nalternative route to data storage. Two companies in particular—Google and Amazon—have been\nvery influential. Both were on the forefront of running large clusters of this kind; furthermore, they\nwere capturing huge amounts of data. These things gave them the motive. Both were successful and\ngrowing companies with strong technical components, which gave them the means and opportunity. It\nwas no wonder they had murder in mind for their relational databases. As the 2000s drew on, both\ncompanies produced brief but highly influential papers about their efforts: BigTable from Google and\nDynamo from Amazon.")]),e._v(" "),n("p",[e._v("It’s often said that Amazon and Google operate at scales far removed from most organizations, so\nthe solutions they needed may not be relevant to an average organization. While it’s true that most")]),e._v(" "),n("p",[e._v("software projects don’t need that level of scale, it’s also true that more and more organizations are\nbeginning to explore what they can do by capturing and processing more data—and to run into the\nsame problems. So, as more information leaked out about what Google and Amazon had done, people\nbegan to explore making databases along similar lines—explicitly designed to live in a world of\nclusters. While the earlier menaces to relational dominance turned out to be phantoms, the threat from\nclusters was serious.")]),e._v(" "),n("h2",{attrs:{id:"_1-5-the-emergence-of-nosql"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-5-the-emergence-of-nosql"}},[e._v("#")]),e._v(" 1.5. The Emergence of NoSQL")]),e._v(" "),n("p",[e._v("It’s a wonderful irony that the term “NoSQL” first made its appearance in the late 90s as the name of\nan open-source relational database [Strozzi NoSQL]. Led by Carlo Strozzi, this database stores its\ntables as ASCII files, each tuple represented by a line with fields separated by tabs. The name comes\nfrom the fact that the database doesn’t use SQL as a query language. Instead, the database is\nmanipulated through shell scripts that can be combined into the usual UNIX pipelines. Other than the\nterminological coincidence, Strozzi’s NoSQL had no influence on the databases we describe in this\nbook.")]),e._v(" "),n("p",[e._v("The usage of “NoSQL” that we recognize today traces back to a meetup on June 11, 2009 in San\nFrancisco organized by Johan Oskarsson, a software developer based in London. The example of\nBigTable and Dynamo had inspired a bunch of projects experimenting with alternative data storage,\nand discussions of these had become a feature of the better software conferences around that time.\nJohan was interested in finding out more about some of these new databases while he was in San\nFrancisco for a Hadoop summit. Since he had little time there, he felt that it wouldn’t be feasible to\nvisit them all, so he decided to host a meetup where they could all come together and present their\nwork to whoever was interested.")]),e._v(" "),n("p",[e._v("Johan wanted a name for the meetup—something that would make a good Twitter hashtag: short,\nmemorable, and without too many Google hits so that a search on the name would quickly find the\nmeetup. He asked for suggestions on the #cassandra IRC channel and got a few, selecting the\nsuggestion of “NoSQL” from Eric Evans (a developer at Rackspace, no connection to the DDD Eric\nEvans). While it had the disadvantage of being negative and not really describing these systems, it did\nfit the hashtag criteria. At the time they were thinking of only naming a single meeting and were not\nexpecting it to catch on to name this entire technology trend [Oskarsson].")]),e._v(" "),n("p",[e._v("The term “NoSQL” caught on like wildfire, but it’s never been a term that’s had much in the way of\na strong definition. The original call [NoSQL Meetup] for the meetup asked for “open-source,\ndistributed, nonrelational databases.” The talks there [NoSQL Debrief] were from Voldemort,\nCassandra, Dynomite, HBase, Hypertable, CouchDB, and MongoDB—but the term has never been\nconfined to that original septet. There’s no generally accepted definition, nor an authority to provide\none, so all we can do is discuss some common characteristics of the databases that tend to be called\n“NoSQL.”")]),e._v(" "),n("p",[e._v("To begin with, there is the obvious point that NoSQL databases don’t use SQL. Some of them do\nhave query languages, and it makes sense for them to be similar to SQL in order to make them easier\nto learn. Cassandra’s CQL is like this—“exactly like SQL (except where it’s not)” [CQL]. But so far\nnone have implemented anything that would fit even the rather flexible notion of standard SQL. It will\nbe interesting to see what happens if an established NoSQL database decides to implement a\nreasonably standard SQL; the only predictable outcome for such an eventuality is plenty of argument.")]),e._v(" "),n("p",[e._v("Another important characteristic of these databases is that they are generally open-source projects.")]),e._v(" "),n("p",[e._v("Although the term NoSQL is frequently applied to closed-source systems, there’s a notion that\nNoSQL is an open-source phenomenon.")]),e._v(" "),n("p",[e._v("Most NoSQL databases are driven by the need to run on clusters, and this is certainly true of those\nthat were talked about during the initial meetup. This has an effect on their data model as well as their\napproach to consistency. Relational databases use ACID transactions (p. 19 ) to handle consistency\nacross the whole database. This inherently clashes with a cluster environment, so NoSQL databases\noffer a range of options for consistency and distribution.")]),e._v(" "),n("p",[e._v("However, not all NoSQL databases are strongly oriented towards running on clusters. Graph\ndatabases are one style of NoSQL databases that uses a distribution model similar to relational\ndatabases but offers a different data model that makes it better at handling data with complex\nrelationships.")]),e._v(" "),n("p",[e._v("NoSQL databases are generally based on the needs of the early 21st century web estates, so usually\nonly systems developed during that time frame are called NoSQL—thus ruling out hoards of\ndatabases created before the new millennium, let alone BC (Before Codd).")]),e._v(" "),n("p",[e._v("NoSQL databases operate without a schema, allowing you to freely add fields to database records\nwithout having to define any changes in structure first. This is particularly useful when dealing with\nnonuniform data and custom fields which forced relational databases to use names like\ncustomField6 or custom field tables that are awkward to process and understand.")]),e._v(" "),n("p",[e._v("All of the above are common characteristics of things that we see described as NoSQL databases.\nNone of these are definitional, and indeed it’s likely that there will never be a coherent definition of\n“NoSQL” (sigh). However, this crude set of characteristics has been our guide in writing this book.\nOur chief enthusiasm with this subject is that the rise of NoSQL has opened up the range of options\nfor data storage. Consequently, this opening up shouldn’t be confined to what’s usually classed as a\nNoSQL store. We hope that other data storage options will become more acceptable, including many\nthat predate the NoSQL movement. There is a limit, however, to what we can usefully discuss in this\nbook, so we’ve decided to concentrate on this noDefinition.")]),e._v(" "),n("p",[e._v("When you first hear “NoSQL,” an immediate question is what does it stand for—a “no” to SQL?\nMost people who talk about NoSQL say that it really means “Not Only SQL,” but this interpretation\nhas a couple of problems. Most people write “NoSQL” whereas “Not Only SQL” would be written\n“NOSQL.” Also, there wouldn’t be much point in calling something a NoSQL database under the “not\nonly” meaning—because then, Oracle or Postgres would fit that definition, we would prove that black\nequals white and would all get run over on crosswalks.")]),e._v(" "),n("p",[e._v("To resolve this, we suggest that you don’t worry about what the term stands for, but rather about\nwhat it means (which is recommended with most acronyms). Thus, when “NoSQL” is applied to a\ndatabase, it refers to an ill-defined set of mostly open-source databases, mostly developed in the\nearly 21st century, and mostly not using SQL.")]),e._v(" "),n("p",[e._v("The “not-only” interpretation does have its value, as it describes the ecosystem that many people\nthink is the future of databases. This is in fact what we consider to be the most important contribution\nof this way of thinking—it’s better to think of NoSQL as a movement rather than a technology. We\ndon’t think that relational databases are going away—they are still going to be the most common form\nof database in use. Even though we’ve written this book, we still recommend relational databases.\nTheir familiarity, stability, feature set, and available support are compelling arguments for most\nprojects.")]),e._v(" "),n("p",[e._v("The change is that now we see relational databases as one option for data storage. This point of\nview is often referred to as "),n("strong",[e._v("polyglot persistence")]),e._v(" —using different data stores in different\ncircumstances. Instead of just picking a relational database because everyone does, we need to\nunderstand the nature of the data we’re storing and how we want to manipulate it. The result is that\nmost organizations will have a mix of data storage technologies for different circumstances.")]),e._v(" "),n("p",[e._v("In order to make this polyglot world work, our view is that organizations also need to shift from\nintegration databases to application databases. Indeed, we assume in this book that you’ll be using a\nNoSQL database as an application database; we don’t generally consider NoSQL databases a good\nchoice for integration databases. We don’t see this as a disadvantage as we think that even if you\ndon’t use NoSQL, shifting to encapsulating data in services is a good direction to take.")]),e._v(" "),n("p",[e._v("In our account of the history of NoSQL development, we’ve concentrated on big data running on\nclusters. While we think this is the key thing that drove the opening up of the database world, it isn’t\nthe only reason we see project teams considering NoSQL databases. An equally important reason is\nthe old frustration with the impedance mismatch problem. The big data concerns have created an\nopportunity for people to think freshly about their data storage needs, and some development teams\nsee that using a NoSQL database can help their productivity by simplifying their database access even\nif they have no need to scale beyond a single machine.")]),e._v(" "),n("p",[e._v("So, as you read the rest of this book, remember there are two primary reasons for considering\nNoSQL. One is to handle data access with sizes and performance that demand a cluster; the other is to\nimprove the productivity of application development by using a more convenient data interaction\nstyle.")]),e._v(" "),n("h2",{attrs:{id:"_1-6-key-points"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_1-6-key-points"}},[e._v("#")]),e._v(" 1.6. Key Points")]),e._v(" "),n("ul",[n("li",[e._v("Relational databases have been a successful technology for twenty years, providing persistence,\nconcurrency control, and an integration mechanism.")]),e._v(" "),n("li",[e._v("Application developers have been frustrated with the impedance mismatch between the\nrelational model and the in-memory data structures.")]),e._v(" "),n("li",[e._v("There is a movement away from using databases as integration points towards encapsulating\ndatabases within applications and integrating through services.")]),e._v(" "),n("li",[e._v("The vital factor for a change in data storage was the need to support large volumes of data by\nrunning on clusters. Relational databases are not designed to run efficiently on clusters.")]),e._v(" "),n("li",[e._v("NoSQL is an accidental neologism. There is no prescriptive definition—all you can make is an\nobservation of common characteristics.")]),e._v(" "),n("li",[e._v("The common characteristics of NoSQL databases are\n"),n("ul",[n("li",[e._v("Not using the relational model")]),e._v(" "),n("li",[e._v("Running well on clusters")]),e._v(" "),n("li",[e._v("Open-source")]),e._v(" "),n("li",[e._v("Built for the 21st century web estates")]),e._v(" "),n("li",[e._v("Schemaless")])])]),e._v(" "),n("li",[e._v("The most important result of the rise of NoSQL is Polyglot Persistence.")])])])}),[],!1,null,null,null);t.default=o.exports},661:function(e,t,a){e.exports=a.p+"assets/img/image--003.f050157c.jpg"}}]);