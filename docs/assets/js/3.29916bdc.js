(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{1617:function(e,t,a){"use strict";a.r(t);var s=a(7),i=Object(s.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"ad-click-event-aggregation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ad-click-event-aggregation"}},[e._v("#")]),e._v(" Ad Click Event Aggregation")]),e._v(" "),s("p",[e._v("With the rise of Facebook, YouTube, TikTok, and the online media economy, digital advertising is taking an ever-\nbigger share of the total advertising spending. As a resul, tracking ad click events is very important. In this chapter, we explore how to design an ad click event aggregation system at Facebook or Google scale.")]),e._v(" "),s("p",[e._v("Before we dive into technical design, let’s leam about the core concepts of online advertising to better understand this topic. One core benefit of online advertising is its measurability, as quantified by real-time data.")]),e._v(" "),s("p",[e._v("Digital advertising has a core process called Real-Time Bidding (RTB), in which digital advertising inventory is\nbought and sold. Figure 1 shows how the online advertising process works.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(733),alt:"Figure 1"}}),s("br"),e._v(" "),s("em",[e._v("Figure 1 RTB process")])]),e._v(" "),s("p",[e._v("The speed of the RTB process is important as it usually occurs in less than a second")]),e._v(" "),s("p",[e._v("Data accuracy is also very important. Ad click event aggregation plays a critical role in measuring the effectiveness of online advertising, which essentially impacts how much money advertisers pay. Based on the click aggregation results, campaign managers can control the budget or adjust bidding strategies, such as changing targeted audience groups, keywords, etc. The key metrics used in online advertising, including click-through rate (CTR) [1] and conversion rate (CVR) [2], depend on aggregated ad click data.")]),e._v(" "),s("h2",{attrs:{id:"step-1-understand-the-problem-and-establish-design-scope"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#step-1-understand-the-problem-and-establish-design-scope"}},[e._v("#")]),e._v(" Step 1 - Understand the Problem and Establish Design Scope")]),e._v(" "),s("p",[e._v("The following set of questions helps to clarify requirements and narrow down the scope.")]),e._v(" "),s("p",[s("strong",[e._v("Candidate")]),e._v(": What is the format of the input data?"),s("br"),e._v(" "),s("strong",[e._v("Interviewer")]),e._v(": It's a log file located in different servers and the latest click events are appended to the end of the log\nfile. The event has the following attributes: ad_id, click_timestamp, user_id, ip, and country.")]),e._v(" "),s("p",[s("strong",[e._v("Candidate")]),e._v(": What's the data volume?"),s("br"),e._v(" "),s("strong",[e._v("Interviewer")]),e._v(": 1 billion ad clicks per day and 2 million ads in total. The number of ad click events grows 30% year-\nover-year.")]),e._v(" "),s("p",[s("strong",[e._v("Candidate")]),e._v(": What are some of the most important queries to support?"),s("br"),e._v(" "),s("strong",[e._v("Interviewer")]),e._v(": The system needs to support the following 3 queries:")]),e._v(" "),s("ul",[s("li",[e._v("Return the number of click events for a particular ad in the last M minutes.")]),e._v(" "),s("li",[e._v("Return the top 100 most clicked ads in the past 1 minute. Both parameters should be configurable. Aggregation occurs every minute.")]),e._v(" "),s("li",[e._v("Support data filtering by ip, user_id, or country for the above two queries.")])]),e._v(" "),s("p",[s("strong",[e._v("Candidate")]),e._v(": Do we need to worry about edge cases? I can think of the following:")]),e._v(" "),s("ul",[s("li",[e._v("There might be events that arrive later than expected.")]),e._v(" "),s("li",[e._v("There might be duplicated events.")]),e._v(" "),s("li",[e._v("Different parts of the system might be down at any time, so we need to consider system recovery.")])]),e._v(" "),s("p",[s("strong",[e._v("Interviewer")]),e._v(": That's a good list. Yes, take these into consideration.")]),e._v(" "),s("p",[s("strong",[e._v("Candidate")]),e._v(": What is the latency requirement?"),s("br"),e._v(" "),s("strong",[e._v("Interviewer")]),e._v(": A few minutes of end-to-end latency. Note that latency requirements for RTB and ad click aggregation\nare very different. While latency for RTB is usually less than one second due to the responsiveness requirement, a\nfew minutes of latency is acceptable for ad click event aggregation because it is primarily used for ad billing and\nreporting.")]),e._v(" "),s("p",[e._v("With the information gathered above, we have both functional and non-functional requirements.")]),e._v(" "),s("h3",{attrs:{id:"functional-requirements"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#functional-requirements"}},[e._v("#")]),e._v(" Functional requirements")]),e._v(" "),s("ul",[s("li",[e._v("Aggregate the number of clicks of "),s("em",[e._v("ad_id")]),e._v(" in the last M minutes.")]),e._v(" "),s("li",[e._v("Return the top 100 most clicked "),s("em",[e._v("ad_id")]),e._v(" every minute.")]),e._v(" "),s("li",[e._v("Support aggregation filtering by different attributes.")]),e._v(" "),s("li",[e._v("Dataset volume is at Facebook or Google scale (see the back-of-envelope estimation section below for detailed system scale requirements).")])]),e._v(" "),s("h3",{attrs:{id:"non-functional-requirements"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#non-functional-requirements"}},[e._v("#")]),e._v(" Non-functional requirements")]),e._v(" "),s("ul",[s("li",[e._v("Correctness of the aggregation result is important as the data is used for RTB and ads billing,")]),e._v(" "),s("li",[e._v("Properly handle delayed or duplicate events,")]),e._v(" "),s("li",[e._v("Robustness. The system should be resilient to partial failures,")]),e._v(" "),s("li",[e._v("Latency requirement. End-to-end latency should be a few minutes, at most.")])]),e._v(" "),s("h3",{attrs:{id:"back-of-the-envelope-estimation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#back-of-the-envelope-estimation"}},[e._v("#")]),e._v(" Back-of-the-envelope estimation")]),e._v(" "),s("p",[e._v("Let's do an estimation to understand the scale of the system and the potential challenges we will need to address.")]),e._v(" "),s("ul",[s("li",[e._v("1 billion DAU.")]),e._v(" "),s("li",[e._v("Assume on average each user clicks 1 ad per day. That's 1 billion ad click events per day.")]),e._v(" "),s("li",[e._v("Ad click QPS = 10^9 events / 10^5 seconds in a day = 10,000")]),e._v(" "),s("li",[e._v("Assume peak ad click QPS is 5 times the average number. Peak QPS = 50,000 QPS.")]),e._v(" "),s("li",[e._v("Assume a single ad click event occupies 0.1 KB storage. Daily storage requirement is: 0.1 KB * 1 billion = 100 GB. The monthly storage requirement is about 3 TB.")])]),e._v(" "),s("h2",{attrs:{id:"step-2-propose-high-level-design-and-get-buy-in"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#step-2-propose-high-level-design-and-get-buy-in"}},[e._v("#")]),e._v(" Step 2 - Propose High-Level Design and Get Buy-In")]),e._v(" "),s("p",[e._v("In this section, we discuss query API design, data model, and high-level design.")]),e._v(" "),s("h3",{attrs:{id:"query-api-design"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#query-api-design"}},[e._v("#")]),e._v(" Query API design")]),e._v(" "),s("p",[e._v("The purpose of the APl design is to have an agreement between the client and the server. In a consumer app, a client is usually the end-user who uses the product. In our case, however, a client is the dashboard user (data scientist, product manager, advertiser, etc) who runs queries against the aggregation service.")]),e._v(" "),s("p",[e._v("Let's review the functional requirements so we can better design the APIs")]),e._v(" "),s("ul",[s("li",[e._v("Aggregate the number of clicks of "),s("em",[e._v("ad_id")]),e._v(" in the last "),s("em",[e._v("M")]),e._v(" minutes,")]),e._v(" "),s("li",[e._v("Return the top N most clicked "),s("em",[e._v("ad_ids")]),e._v(" in the last "),s("em",[e._v("M")]),e._v(" minute.")]),e._v(" "),s("li",[e._v("Support aggregation filtering by different attributes.")])]),e._v(" "),s("p",[e._v("We only need two APIs to support those three use cases because filtering (the last requirement) can be supported by adding query parameters to the requests.")]),e._v(" "),s("p",[s("strong",[e._v("API 1: Aggregate the number of clicks of ad_id in the last M minutes.")])]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("API")]),e._v(" "),s("th",[e._v("Detail")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[s("code",[e._v("GET v1/ads/{:ad_id}/aggregated_count")])]),e._v(" "),s("td",[e._v("Return aggregated event count for a given ad_id")])])])]),e._v(" "),s("p",[s("em",[e._v("Table 1 API for aggregating the number of clicks")])]),e._v(" "),s("p",[e._v("Request parameters are:")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Field")]),e._v(" "),s("th",[e._v("Description")]),e._v(" "),s("th",[e._v("Type")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("from")]),e._v(" "),s("td",[e._v("Start minute (default is now minus 1 minute)")]),e._v(" "),s("td",[e._v("long")])]),e._v(" "),s("tr",[s("td",[e._v("to")]),e._v(" "),s("td",[e._v("End minute (default is now)")]),e._v(" "),s("td",[e._v("long")])]),e._v(" "),s("tr",[s("td",[e._v("fiter")]),e._v(" "),s("td",[e._v("An identifier for different filtering strategies. For example, filter = 001 filters out non-US clicks")]),e._v(" "),s("td",[e._v("long")])])])]),e._v(" "),s("p",[s("em",[e._v("Table 2 Request parameters for "),s("code",[e._v("/v1/ads/{:ad_id}/aggregated_count")])])]),e._v(" "),s("p",[e._v("Response:")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Field")]),e._v(" "),s("th",[e._v("Description")]),e._v(" "),s("th",[e._v("Type")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("adid")]),e._v(" "),s("td",[e._v("The identifier of the ad")]),e._v(" "),s("td",[e._v("string")])]),e._v(" "),s("tr",[s("td",[e._v("count")]),e._v(" "),s("td",[e._v("The aggregated count between the start and end minutes")]),e._v(" "),s("td",[e._v("long")])])])]),e._v(" "),s("p",[s("em",[e._v("Table 3 Response for "),s("code",[e._v("/v1/ads/{:ad_id}/aggregated_count")])])]),e._v(" "),s("p",[s("strong",[e._v("API 2: Return top N most dlicked ad ids in the last M minutes")])]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("API")]),e._v(" "),s("th",[e._v("Detail")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[s("code",[e._v("GET /v1/ads/popular_ads")])]),e._v(" "),s("td",[e._v("Return top N most clicked ads in the last M minutes")])])])]),e._v(" "),s("p",[s("em",[e._v("Table 4 API for "),s("code",[e._v("/v1/ads/popular_ads")])])]),e._v(" "),s("p",[e._v("Request parameters are:")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Field")]),e._v(" "),s("th",[e._v("Description")]),e._v(" "),s("th",[e._v("Type")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("count")]),e._v(" "),s("td",[e._v("Top N most clicked ads")]),e._v(" "),s("td",[e._v("integer")])]),e._v(" "),s("tr",[s("td",[e._v("window")]),e._v(" "),s("td",[e._v("The aggregation window size (M) in minutes")]),e._v(" "),s("td",[e._v("integer")])]),e._v(" "),s("tr",[s("td",[e._v("filter")]),e._v(" "),s("td",[e._v("An identifier for different filtering strategies")]),e._v(" "),s("td",[e._v("long")])])])]),e._v(" "),s("p",[s("em",[e._v("Table 5 Request parameters for "),s("code",[e._v("/v1/ads/popular_ads")])])]),e._v(" "),s("p",[e._v("Response:")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Field")]),e._v(" "),s("th",[e._v("Description")]),e._v(" "),s("th",[e._v("Type")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("ad_ids")]),e._v(" "),s("td",[e._v("A list of the most dlicked ads")]),e._v(" "),s("td",[e._v("array")])])])]),e._v(" "),s("p",[s("em",[e._v("Table 6 Response for "),s("code",[e._v("/v1/ads/popular_ads")])])]),e._v(" "),s("h3",{attrs:{id:"data-model"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#data-model"}},[e._v("#")]),e._v(" Data model")]),e._v(" "),s("p",[e._v("There are two types of data in the system: raw data and aggregated data")]),e._v(" "),s("h4",{attrs:{id:"raw-data"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#raw-data"}},[e._v("#")]),e._v(" Raw data")]),e._v(" "),s("p",[e._v("Below shows what the raw data looks like in log files:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("[AdClickEvent] ad001, 2021-01-61 00:00:01, user 1, 207.148.22.22, USA\n")])])]),s("p",[e._v("Table 7 lists what the data fields look like in a structured way. Data is scattered on different application servers")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("ad_id")]),e._v(" "),s("th",[e._v("click")]),e._v(" "),s("th",[e._v("timestamp")]),e._v(" "),s("th",[e._v("user")]),e._v(" "),s("th",[e._v("ip")]),e._v(" "),s("th",[e._v("country")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("ad001")]),e._v(" "),s("td",[e._v("2021-01-0100:0001")]),e._v(" "),s("td",[e._v("user1")]),e._v(" "),s("td",[e._v("207.148.22.22")]),e._v(" "),s("td",[e._v("USA")]),e._v(" "),s("td")]),e._v(" "),s("tr",[s("td",[e._v("ad001")]),e._v(" "),s("td",[e._v("2021-01-0100:00:02")]),e._v(" "),s("td",[e._v("user1")]),e._v(" "),s("td",[e._v("207.148.22.22")]),e._v(" "),s("td",[e._v("USA")]),e._v(" "),s("td")]),e._v(" "),s("tr",[s("td",[e._v("ad002")]),e._v(" "),s("td",[e._v("2021-01-0100:00:02")]),e._v(" "),s("td",[e._v("user2")]),e._v(" "),s("td",[e._v("209.153.56.11")]),e._v(" "),s("td",[e._v("USA")]),e._v(" "),s("td")])])]),e._v(" "),s("p",[s("em",[e._v("Table 7 Raw data")])]),e._v(" "),s("h4",{attrs:{id:"aggregated-data"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aggregated-data"}},[e._v("#")]),e._v(" Aggregated data")]),e._v(" "),s("p",[e._v("Assume that ad click events are aggregated every minute. Table 8 shows the aggregated result.")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("ad_id")]),e._v(" "),s("th",[e._v("click_minute")]),e._v(" "),s("th",[e._v("count")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("ad001")]),e._v(" "),s("td",[e._v("202101010000")]),e._v(" "),s("td",[e._v("5")])]),e._v(" "),s("tr",[s("td",[e._v("ad001")]),e._v(" "),s("td",[e._v("202101010001")]),e._v(" "),s("td",[e._v("7")])])])]),e._v(" "),s("p",[s("em",[e._v("Table 8 Aggregated data")])]),e._v(" "),s("p",[e._v("To support ad filtering, we add an additional field called "),s("em",[e._v("filter_id")]),e._v(" to the table. Records with the same "),s("em",[e._v("ad_id")]),e._v(" and "),s("em",[e._v("click_minute")]),e._v(" are grouped by "),s("em",[e._v("filter_id")]),e._v(" as shown in Table 9, and filters are defined in Table 10.")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("ad_id")]),e._v(" "),s("th",[e._v("click_minute")]),e._v(" "),s("th",[e._v("filter_id")]),e._v(" "),s("th",[e._v("count")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("ad001")]),e._v(" "),s("td",[e._v("202101010000")]),e._v(" "),s("td",[e._v("0012")]),e._v(" "),s("td",[e._v("2")])]),e._v(" "),s("tr",[s("td",[e._v("ad001")]),e._v(" "),s("td",[e._v("202101010000")]),e._v(" "),s("td",[e._v("0023")]),e._v(" "),s("td",[e._v("3")])]),e._v(" "),s("tr",[s("td",[e._v("ad001")]),e._v(" "),s("td",[e._v("202101010001")]),e._v(" "),s("td",[e._v("0012")]),e._v(" "),s("td",[e._v("1")])]),e._v(" "),s("tr",[s("td",[e._v("ad001")]),e._v(" "),s("td",[e._v("202101010001")]),e._v(" "),s("td",[e._v("0023")]),e._v(" "),s("td",[e._v("5")])])])]),e._v(" "),s("p",[s("em",[e._v("Table 9 Aggregated data with filters")])]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("filter_id")]),e._v(" "),s("th",[e._v("region")]),e._v(" "),s("th",[e._v("IP")]),e._v(" "),s("th",[e._v("user_id")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("0012")]),e._v(" "),s("td",[e._v("US")]),e._v(" "),s("td",[e._v("*")]),e._v(" "),s("td",[e._v("*")])]),e._v(" "),s("tr",[s("td",[e._v("0013")]),e._v(" "),s("td",[e._v("*")]),e._v(" "),s("td",[e._v("123.1.2.3")]),e._v(" "),s("td",[e._v("*")])])])]),e._v(" "),s("p",[s("em",[e._v("Table 10 Filter table")])]),e._v(" "),s("p",[e._v("To support the query to return the top N most clicked ads in the last M minutes, the following structure is used.")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[s("strong",[e._v("most clicked ads")])]),e._v(" "),s("th",[e._v(".")]),e._v(" "),s("th",[e._v(".")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("window_size")]),e._v(" "),s("td",[e._v("integer")]),e._v(" "),s("td",[e._v("The aggregation window size (M) in minutes")])]),e._v(" "),s("tr",[s("td",[e._v("update_time_minute")]),e._v(" "),s("td",[e._v("timestamp")]),e._v(" "),s("td",[e._v("Last updated timestamp (in 1-minute granularity)")])]),e._v(" "),s("tr",[s("td",[e._v("most_clicked_ads")]),e._v(" "),s("td",[e._v("array")]),e._v(" "),s("td",[e._v("List of ad IDs in JSON format.")])])])]),e._v(" "),s("p",[s("em",[e._v("Table 11 Support top N most clicked ads in the last M minutes")])]),e._v(" "),s("h4",{attrs:{id:"comparison"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#comparison"}},[e._v("#")]),e._v(" Comparison")]),e._v(" "),s("p",[e._v("The comparison between storing raw data and aggregated data is shown below.")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v(".")]),e._v(" "),s("th",[e._v("Raw data only")]),e._v(" "),s("th",[e._v("Aggregated data only")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("Pros")]),e._v(" "),s("td",[e._v("- Full data set "),s("br"),e._v(" - Support data filter &  recalculation")]),e._v(" "),s("td",[e._v("- Smaller data set "),s("br"),e._v(" - Fast query")])]),e._v(" "),s("tr",[s("td",[e._v("Cons")]),e._v(" "),s("td",[e._v("- Huge data storage "),s("br"),e._v(" - Slow query")]),e._v(" "),s("td",[e._v("- Data loss. This is derived data. E.g 10 entries might be aggregated to 1 entry")])])])]),e._v(" "),s("p",[s("em",[e._v("Table 12 Raw data vs aggregated data")])]),e._v(" "),s("p",[e._v("Should we store raw data or aggregated data? Our recommendation is to store both. Let's take a look at why.")]),e._v(" "),s("ul",[s("li",[e._v("It's a good idea to keep the raw data. If something goes wrong, we could use the raw data for debugging. If the\naggregated data is corrupted due to a bad bug, we can recalculate the aggregated data from the raw data,\nafter the bug is fixed.")]),e._v(" "),s("li",[e._v("Aggregated data should be stored as well. The data size of the raw data is huge. The large size makes querying\nraw data directly very inefficient. To mitigate this problem, we run read queries on aggregated data")]),e._v(" "),s("li",[e._v("Raw data serves as backup data. We usually don't need to query raw data unless recalculation is needed. Old\nraw data could be moved to cold storage to reduce costs.")]),e._v(" "),s("li",[e._v("Aggregated data serves as active data. It is tuned for query performance.")])]),e._v(" "),s("h4",{attrs:{id:"choose-the-right-database"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#choose-the-right-database"}},[e._v("#")]),e._v(" Choose the right database")]),e._v(" "),s("p",[e._v("When it comes to choosing the right database, we need to evaluate the following:")]),e._v(" "),s("ul",[s("li",[e._v("What does the data look like? Is the data relational? Is it a document or a blob?")]),e._v(" "),s("li",[e._v("Is the workflow read-heavy, write-heavy, or both?")]),e._v(" "),s("li",[e._v("Is transaction support needed?")]),e._v(" "),s("li",[e._v("Do the queries rely on many online analytical processing (OLAP) functions [3] like SUM, COUNT?")])]),e._v(" "),s("p",[e._v("Let's examine the raw data first. Even though we don't need to query the raw data during normal operations, it is\nuseful for data scientists or machine learning engineers to study user response prediction, behavioral targeting,\nrelevance feedback, etc. [4]")]),e._v(" "),s("p",[e._v("As shown in the back of the envelope estimation, the average write QPS is 10,000, and the peak QPS can be 50,000,\n50 the system is write-heavy. On the read side, raw data is used as backup and a source for recalculation, so in\ntheory, the read volume is low.")]),e._v(" "),s("p",[e._v("Relational databases can do the job, but scaling the write can be challenging. NoSQL databases like Cassandra and\nInfluxDB are more suitable because they are optimized for write and time-range queries.")]),e._v(" "),s("p",[e._v("Another option is to store the data in Amazon S3 using one of the columnar data formats like ORC [5], Parquet [6],\nor AVRO [7]. We could put a cap on the size of each file (say, 10GB) and the stream processor responsible for writing the raw data could handle the file rotation when the size cap is reached. Since this setup may be unfamiliar\nfor many, in this design we use Cassandra as an example.")]),e._v(" "),s("p",[e._v("For aggregated data, it is time-series in nature and the workflow is both read and write heavy. This is because, for\neach ad, we need to query the database every minute to display the latest aggregation count for customers. This\nfeature is useful for auto-refreshing the dashboard or triggering alerts in a timely manner. Since there are two\nmillion ads in total, the workflow is read-heavy. Data is aggregated and written every minute by the aggregation\nservice, so it's write-heavy as well. We could use the same type of database to store both raw data and aggregated\ndata.")]),e._v(" "),s("p",[e._v("Now we have discussed query API design and data model, let's put together the high-level design.")]),e._v(" "),s("h3",{attrs:{id:"high-level-design"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#high-level-design"}},[e._v("#")]),e._v(" High-level design")]),e._v(" "),s("p",[e._v("In real-time big data [8] processing, data usually flows into and out of the processing system as unbounded data\nstreams. The aggregation service works in the same way; the input is the raw data (unbounded data streams), and\nthe output is the aggregated results (see Figure 2).")]),e._v(" "),s("p",[s("img",{attrs:{src:a(734),alt:"Figure 2"}}),s("br"),e._v(" "),s("em",[e._v("Figure 2 Aggregation workflow")])]),e._v(" "),s("h4",{attrs:{id:"asynchronous-processing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#asynchronous-processing"}},[e._v("#")]),e._v(" Asynchronous processing")]),e._v(" "),s("p",[e._v("The design we currently have is synchronous. This is not good because the capacity of producers and consumers is\nnot always equal. Consider the following case; if there is a sudden increase in traffic and the number of events\nproduced is far beyond what consumers can handle, consumers might get out-of-memory errors or experience an\nunexpected shutdown. If one component in the synchronous link is down, the whole system stops working.")]),e._v(" "),s("p",[e._v("A common solution is to adopt a message queue (Kafka) to decouple producers and consumers. This makes the\nwhole process asynchronous and producers/consumers can be scaled independently.")]),e._v(" "),s("p",[e._v("Putting everything we have discussed together, we come up with the high-level design as shown in Figure 3. Log\nwatcher, aggregation service, and database are decoupled by two message queues. The database writer polls data\nfrom the message queue, transforms the data into the database format, and writes it to the database.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(735),alt:"Figure 3"}}),s("br"),e._v(" "),s("em",[e._v("Figure 3 High-level design")])]),e._v(" "),s("p",[e._v("Whatis stored in the first message queue? It contains ad click event data as shown in Table 13")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("ad_id")]),e._v(" "),s("th",[e._v("click_timestamp")]),e._v(" "),s("th",[e._v("user_id")]),e._v(" "),s("th",[e._v("ip")]),e._v(" "),s("th",[e._v("country")])])]),e._v(" "),s("tbody")]),e._v(" "),s("p",[s("em",[e._v("Table 13 Data in the first message queue")])]),e._v(" "),s("p",[e._v("Whatis stored in the second message queue? The second message queue contains two types of data:")]),e._v(" "),s("ol",[s("li",[e._v("Ad click counts aggregated at per-minute granularity.")])]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("ad_id")]),e._v(" "),s("th",[e._v("click_minute")]),e._v(" "),s("th",[e._v("count")])])]),e._v(" "),s("tbody")]),e._v(" "),s("p",[s("em",[e._v("Table 14 Data in the second message queue")])]),e._v(" "),s("ol",{attrs:{start:"2"}},[s("li",[e._v("Top N most clicked ads aggregated at per-minute granularity")])]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("update_time_minute")]),e._v(" "),s("th",[e._v("most_clicked_ads")])])]),e._v(" "),s("tbody")]),e._v(" "),s("p",[s("em",[e._v("Table 15 Data in the second message queue")])]),e._v(" "),s("p",[e._v("You might be wondering why we don't write the aggregated results to the database directly. The short answer is that we need the second message queue like Kafka to achieve end-to-end exactly-once semantics (atomic commit).")]),e._v(" "),s("p",[s("img",{attrs:{src:a(736),alt:"Figure 4"}}),s("br"),e._v(" "),s("em",[e._v("Figure 4: End-to-end exactly once")])]),e._v(" "),s("p",[e._v("Next, let's dig into the details of the aggregation service.")]),e._v(" "),s("h4",{attrs:{id:"aggregation-service"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aggregation-service"}},[e._v("#")]),e._v(" Aggregation service")]),e._v(" "),s("p",[e._v("The MapReduce framework is a good option to aggregate ad lick events. The directed acyclic graph (DAG) is a\ngood model for it [9]. The key to the DAG model is to break down the system into small computing units, like the\nMap/Aggregate/Reduce nodes, as shown in Figure 5.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(737),alt:"Figure 5"}}),s("br"),e._v(" "),s("em",[e._v("Figure 5 Aggregation service")])]),e._v(" "),s("p",[e._v("Each node is responsible for one single task and it sends the processing result to its downstream nodes.")]),e._v(" "),s("p",[s("strong",[e._v("Map node")]),e._v("\nA Map node reads data from a data source, and then filters and transforms the data. For example, a Map node\nsends ads with "),s("em",[e._v("ad_id")]),e._v(" % 2 = 0 to node 1, and the other ads go to node 2, as shown in Figure 6.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(738),alt:"Figure 6"}}),s("br"),e._v(" "),s("em",[e._v("Figure 6 Map operation")])]),e._v(" "),s("p",[e._v("You might be wondering why we need the Map node. An alternative option is to set up Kafka partitions or tags and\nlet the aggregate nodes subscribe to Kafka directly. This works, but the input data may need to be cleaned or\nnormalized, and these operations can be done by the Map node. Another reason is that we may not have control\nover how data is produced and therefore events with the same ad_id might land in different Kafka partitions.")]),e._v(" "),s("p",[s("strong",[e._v("Aggregate node")])]),e._v(" "),s("p",[e._v("An Aggregate node counts ad click events by ad_id in memory every minute. In the MapReduce paradigm, the\nAggregate node s part of the Reduce. So the map-aggregate-reduce process really means map-reduce-reduce.")]),e._v(" "),s("p",[s("strong",[e._v("Reduce node")])]),e._v(" "),s("p",[e._v("A Reduce node reduces aggregated results from all “Aggregate” nodes to the final result. For example, as shown in\nFigure 7, there are three aggregation nodes and each contains the top 3 most clicked ads within the node. The\nReduce node reduces the total number of most clicked ad to 3.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(739),alt:"Figure 7"}}),s("br"),e._v(" "),s("em",[e._v("Figure 7 Reduce node")])]),e._v(" "),s("p",[e._v("The DAG model represents the well-known MapReduce paradigm. It is designed to take big data and use parallel\ndistributed computing to turn big data into little- or regular-sized data.")]),e._v(" "),s("p",[e._v("In the DAG model, intermediate data can be stored in memory and different nodes communicate with each other\nthrough either TCP (nodes running in different processes) or shared memory (nodes running in different threads).")]),e._v(" "),s("h4",{attrs:{id:"main-use-cases"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#main-use-cases"}},[e._v("#")]),e._v(" Main use cases")]),e._v(" "),s("p",[e._v("Now that we understand how MapReduce works at the high level, let's take a look at how it can be utilized to\nsupport the main use cases:")]),e._v(" "),s("ul",[s("li",[e._v("Aggregate the number of clicks of adid in the last_M mins.")]),e._v(" "),s("li",[e._v("Return top N most clicked adids in the last_M minutes.")]),e._v(" "),s("li",[e._v("Data filtering")])]),e._v(" "),s("p",[s("strong",[e._v("Use case 1: aggregate the number of clicks")])]),e._v(" "),s("p",[e._v("As shown in Figure 8, input events are partitioned by ad_id (ad_id % 3) in Map nodes and are then aggregated by Aggregation nodes")]),e._v(" "),s("p",[s("img",{attrs:{src:a(740),alt:"Figure 8"}}),s("br"),e._v(" "),s("em",[e._v("Figure 8 Aggregate the number of clicks")])]),e._v(" "),s("p",[s("strong",[e._v("Use case 2: return top N most clicked ads")])]),e._v(" "),s("p",[e._v("Figure 9 shows a simplified design of getting the top 3 most clicked ads, which can be extended to top N. Input events are mapped using ad_id and each Aggregate node maintains a heap data structure to get the top 3 ads within the node efficiently. In the last step, the Reduce node reduces 9 ads (top 3 from each aggregate node) to the top 3 most clicked ads every minute.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(741),alt:"Figure 9"}}),s("br"),e._v(" "),s("em",[e._v("Figure 9 Return top N most clicked ads")])]),e._v(" "),s("p",[s("strong",[e._v("Use case 3: data filtering")])]),e._v(" "),s("p",[e._v('To support data filtering like “show me the aggregated click count for ad001 within the USA only", we can pre-define filtering criteria and aggregate based on them. For example, the aggregation results look like this for ad001 and ad002:')]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("ad_id")]),e._v(" "),s("th",[e._v("click_minute")]),e._v(" "),s("th",[e._v("country")]),e._v(" "),s("th",[e._v("count")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("ad001")]),e._v(" "),s("td",[e._v("202101010001")]),e._v(" "),s("td",[e._v("USA")]),e._v(" "),s("td",[e._v("100")])]),e._v(" "),s("tr",[s("td",[e._v("ad001")]),e._v(" "),s("td",[e._v("202101010001")]),e._v(" "),s("td",[e._v("GPB")]),e._v(" "),s("td",[e._v("200")])]),e._v(" "),s("tr",[s("td",[e._v("ad001")]),e._v(" "),s("td",[e._v("202101010001")]),e._v(" "),s("td",[e._v("others,")]),e._v(" "),s("td",[e._v("3000")])]),e._v(" "),s("tr",[s("td",[e._v("ad002")]),e._v(" "),s("td",[e._v("202101010001")]),e._v(" "),s("td",[e._v("USA")]),e._v(" "),s("td",[e._v("10")])]),e._v(" "),s("tr",[s("td",[e._v("ad002")]),e._v(" "),s("td",[e._v("202101010001")]),e._v(" "),s("td",[e._v("GPB")]),e._v(" "),s("td",[e._v("25")])]),e._v(" "),s("tr",[s("td",[e._v("ad002")]),e._v(" "),s("td",[e._v("202101010001")]),e._v(" "),s("td",[e._v("others")]),e._v(" "),s("td",[e._v("12")])])])]),e._v(" "),s("p",[s("em",[e._v("Table 16 Aggregation results (filter by country)")])]),e._v(" "),s("p",[e._v("This technique is called the star schema [11], which is widely used in data warehouses. The filtering fields are called dimensions. This approach has the following benefits:")]),e._v(" "),s("ul",[s("li",[e._v("It is simple to understand and build.")]),e._v(" "),s("li",[e._v("The current aggregation service can be reused to create more dimensions in the star schema. No additional component is needed.")]),e._v(" "),s("li",[e._v("Accessing data based on filtering criteria is fast because the result is pre-calculated.")])]),e._v(" "),s("p",[e._v("A limitation with this approach is that it creates many more buckets and records, especially when we have a lot of\nfiltering criteria.")]),e._v(" "),s("h2",{attrs:{id:"step-3-design-deep-dive"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#step-3-design-deep-dive"}},[e._v("#")]),e._v(" Step 3 - Design Deep Dive")]),e._v(" "),s("p",[e._v("In this section, we will dive deep into the following:")]),e._v(" "),s("ul",[s("li",[e._v("Streaming vs batching")]),e._v(" "),s("li",[e._v("Time and aggregation window")]),e._v(" "),s("li",[e._v("Delivery guarantees")]),e._v(" "),s("li",[e._v("Scale the system")]),e._v(" "),s("li",[e._v("Data monitoring and correctness")]),e._v(" "),s("li",[e._v("Final design diagram")]),e._v(" "),s("li",[e._v("Fault tolerance")])]),e._v(" "),s("h3",{attrs:{id:"streaming-vs-batching"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#streaming-vs-batching"}},[e._v("#")]),e._v(" Streaming vs batching")]),e._v(" "),s("p",[e._v("The high-level architecture we proposed in Figure 3 is a type of stream processing system. Table 17 shows the comparison of three types of systems [12]")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Features")]),e._v(" "),s("th",[e._v("Services "),s("br"),e._v(" (Online system)")]),e._v(" "),s("th",[e._v("Batch system "),s("br"),e._v(" (Offline system)")]),e._v(" "),s("th",[e._v("Streaming sytem  "),s("br"),e._v("  (near real-time system)")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("Responsiveness")]),e._v(" "),s("td",[e._v("Respond to the client quickly")]),e._v(" "),s("td",[e._v("No response to the client needed")]),e._v(" "),s("td",[e._v("No response to the client needed")])]),e._v(" "),s("tr",[s("td",[e._v("Input")]),e._v(" "),s("td",[e._v("User requests")]),e._v(" "),s("td",[e._v("Bounded input with finite size. A large amount of data")]),e._v(" "),s("td",[e._v("Input has no boundary (infinite streams)")])]),e._v(" "),s("tr",[s("td",[e._v("Ouput")]),e._v(" "),s("td",[e._v("Responses to clients")]),e._v(" "),s("td",[e._v("Materialized views, aggregated metrics, ect.")]),e._v(" "),s("td",[e._v("Materialized views, aggregated metrics, ect.")])]),e._v(" "),s("tr",[s("td",[e._v("Perfomance measurement")]),e._v(" "),s("td",[e._v("Availability, latency")]),e._v(" "),s("td",[e._v("Throughput")]),e._v(" "),s("td",[e._v("Throughput, latency")])]),e._v(" "),s("tr",[s("td",[e._v("Example")]),e._v(" "),s("td",[e._v("Online shopping")]),e._v(" "),s("td",[e._v("MapReduce")]),e._v(" "),s("td",[e._v("Flink")])])])]),e._v(" "),s("p",[s("em",[e._v("Table 17 Comparison of three types of systems")])]),e._v(" "),s("p",[e._v("In our design, both stream processing and batch processing are used. We utilized stream processing to process\ndata as it arrives and generates aggregated results in a near real-time fashion. We utilized batch processing for\nhistorical data backup.")]),e._v(" "),s("p",[e._v("For a system that contains two processing paths (batch and streaming) simultaneously, this architecture is called\nlambda [14]. A disadvantage of lambda architecture is that you have two processing paths, meaning there are two\ncodebases to maintain. Kappa architecture [15], which combines the batch and streaming in one processing path,\nsolves the problem. The key idea is to handle both real-time data processing and continuous data reprocessing\nusing a single stream processing engine. Figure 10 shows a comparison of lambda and kappa architecture.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(742),alt:"Figure 10"}})]),e._v(" "),s("p",[e._v("Figure 10 Lambda and Kappa architectures")]),e._v(" "),s("p",[e._v("Our high-level design uses Kappa architecture, where the reprocessing of historical data also goes through the real-time aggregation service. See the “Data recalculation” section below for details")]),e._v(" "),s("h4",{attrs:{id:"data-recalculation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#data-recalculation"}},[e._v("#")]),e._v(" Data recalculation")]),e._v(" "),s("p",[e._v("Sometimes we have to recalculate the aggregated data, also called historical data replay. For example, if we\ndiscover a major bug in the aggregation service, we would need to recalculate the aggregated data from raw data\nstarting at the point where the bug was introduced. Figure 11 shows the data recalculation flow:")]),e._v(" "),s("ol",[s("li",[e._v("The recalculation service retrieves data from raw data storage. This is a batched job.")]),e._v(" "),s("li",[e._v("Retrieved data is sent to a dedicated aggregation service so that the real-time processing is not impacted by historical data replay.")]),e._v(" "),s("li",[e._v("Aggregated results are sent to the second message queue, then updated in the aggregation database.")])]),e._v(" "),s("p",[s("img",{attrs:{src:a(743),alt:"Figure 11"}}),s("br"),e._v(" "),s("em",[e._v("Figure 11 Recalculation service")])]),e._v(" "),s("p",[e._v("The recalculation process reuses the data aggregation service but uses a different data source (the raw data)")]),e._v(" "),s("h3",{attrs:{id:"time"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#time"}},[e._v("#")]),e._v(" Time")]),e._v(" "),s("p",[e._v("We need a timestamp to perform aggregation. The timestamp can be generated in two different places:")]),e._v(" "),s("ul",[s("li",[e._v("Event time: when an ad click happens.")]),e._v(" "),s("li",[e._v("Processing time: refers to the system time of the aggregation server that processes the click event.")])]),e._v(" "),s("p",[e._v("Due to network delays and asynchronous environments (data go through a message queue), the gap between\nevent time and processing time can be large. As shown in Figure 12, event 1 arrives at the aggregation service very\nlate (5 hours later).")]),e._v(" "),s("p",[s("img",{attrs:{src:a(744),alt:"Figure 12"}}),s("br"),e._v(" "),s("em",[e._v("Figure 12 Late events")])]),e._v(" "),s("p",[e._v("If event time is used for aggregation, we have to deal with delayed events. If processing time is used for\naggregation, the aggregation result may not be accurate. There is no perfect solution, 50 we need to consider the\ntrade-offs")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v(".")]),e._v(" "),s("th",[e._v("Pros")]),e._v(" "),s("th",[e._v("Cons")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("Event time")]),e._v(" "),s("td",[e._v("Aggregation results are more accurate because the client knows exactly when an ad is clicked")]),e._v(" "),s("td",[e._v("It depends on the timestamp generated on the client-side. Clients might have the wrong time, or the timestamp might be generated by malicious users")])]),e._v(" "),s("tr",[s("td",[e._v("Processing time")]),e._v(" "),s("td",[e._v("Server timestamp is more reliable")]),e._v(" "),s("td",[e._v("The timestamp is not accurate if an event reaches the system at a much later time.")])])])]),e._v(" "),s("p",[s("em",[e._v("Table 18: Event time vs processing time")])]),e._v(" "),s("p",[e._v("Since data accuracy is very important, we recommend using event time for aggregation. How do we properly\nprocess delayed events in this case? A technique called “watermark” is commonly utilized to handle slightly delayed\nevents.")]),e._v(" "),s("p",[e._v('In Figure 13, ad click events are aggregated in the one-minute tumbling window (see the “Aggregation window" section for more details). If event time s used to decide whether the event is in the window, window 1 misses event 2, and window 3 misses event 5 because they arrive slightly later than the end of their aggregation windows.')]),e._v(" "),s("p",[s("img",{attrs:{src:a(745),alt:"Figure 13"}}),s("br"),e._v(" "),s("em",[e._v("Figure 13 Miss events in an aggregation window")])]),e._v(" "),s("p",[e._v("One way to mitigate this problem is to use “watermark” (the extended rectangles in Figure 14), which is regarded as an extension of an aggregation window. This improves the accuracy of the aggregation result. By extending an\nextra 15-second (adjustable) aggregation window, window 1 is able to include event 2, and window 3 is able to\ninclude event 5,")]),e._v(" "),s("p",[e._v("The value set for the watermark depends on the business requirement. A long watermark could catch events that\narrive very late, but it adds more latency to the system. A short watermark means data s less accurate, but it adds\nless latency to the system.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(746),alt:"Figure 14"}}),s("br"),e._v(" "),s("em",[e._v("Figure 14 Watermark")])]),e._v(" "),s("p",[e._v("Notice that the watermark technique does not handle events that have long delays. We can argue that it is not\nworth the return on investment (ROI) to have a complicated design for low probability events. We can always\ncorrect the tiny bit of inaccuracy with end-of-day reconciliation (see Reconciliation section). One trade-off to\nconsider is that using watermark improves data accuracy but increases overall latency, due to extended wait time.")]),e._v(" "),s("h3",{attrs:{id:"aggregation-window"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#aggregation-window"}},[e._v("#")]),e._v(" Aggregation window")]),e._v(" "),s("p",[e._v("According to the “Designing data-intensive applications” book by Martin Kieppmann [16], there are four types of\nwindow functions: tumbling (also called fixed) window, hopping window, sliding window, and session window. We\nwill discuss the tumbling window and sliding window as they are most relevant to our system.")]),e._v(" "),s("p",[e._v("In the tumbling window (highlighted in Figure 15), time is partitioned into same-length, non-overlapping chunks.\nThe tumbling window is a good fit for aggregating ad click events every minute (use case 1),")]),e._v(" "),s("p",[s("img",{attrs:{src:a(747),alt:"Figure 15"}}),s("br"),e._v(" "),s("em",[e._v("Figure 15 Tumbling window")])]),e._v(" "),s("p",[e._v("In the sliding window (highlighted in Figure 16), events are grouped within a window that slides across the data\nstream, according to a specified interval. A sliding window can be an overlapping one. This is a good strategy to\nsatisfy our second use case; to get the top N most clicked ads during the last "),s("em",[e._v("M")]),e._v(" minutes.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(748),alt:"Figure 16"}}),s("br"),e._v(" "),s("em",[e._v("Figure 16 Sliding window")])]),e._v(" "),s("h3",{attrs:{id:"delivery-guarantees"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#delivery-guarantees"}},[e._v("#")]),e._v(" Delivery guarantees")]),e._v(" "),s("p",[e._v("Since the aggregation result is utilized for billing, data accuracy and completeness are very important. The system needs to be able to answer questions such as:")]),e._v(" "),s("ul",[s("li",[e._v("How to avoid processing duplicate events?")]),e._v(" "),s("li",[e._v("How to ensure all events are processed?")])]),e._v(" "),s("p",[e._v("Message queues such as Kafka usually provide three delivery semantics: at-most once, at-least once, and exactly once.")]),e._v(" "),s("p",[s("strong",[e._v("Which delivery method should we choose?")])]),e._v(" "),s("p",[e._v("In most circumstances, at-least once processing is good enough if a small percentage of duplicates are acceptable. However, this is not the case for our system. Differences of a few percent in data points could result in discrepancies of millions of dollars. Therefore, we recommend exactly-once delivery for the system. If you are interested in learning more about a real-life ad aggregation system, take a look at how Yelp implements it [17].")]),e._v(" "),s("h3",{attrs:{id:"data-deduplication"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#data-deduplication"}},[e._v("#")]),e._v(" Data deduplication")]),e._v(" "),s("p",[e._v("One of the most common data quality issues is duplicated data. Duplicated data can come from a wide range of\nsources and in this section, we discuss two common sources.")]),e._v(" "),s("ul",[s("li",[e._v("Client-side. For example, a client might resend the same event multiple times. Duplicated events sent with\nmalicious intent are best handled by ad fraud/risk control components. If this is of interest, please refer to the\nreference material [18].")]),e._v(" "),s("li",[e._v("Server outage. If an aggregation service node goes down in the middle of aggregation and the upstream\nservice hasn't yet received an acknowledgment, the same events might be sent and aggregated again. Let's\ntake a closer look.")])]),e._v(" "),s("p",[e._v("Figure 17 shows how the aggregation service node (Aggregator) outage introduces duplicate data. The Aggregator manages the status of data consumption by storing the offset in upstream Kafka.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(749),alt:"Figure 17"}}),s("br"),e._v(" "),s("em",[e._v("Figure 17 Duplicate data")])]),e._v(" "),s("p",[e._v("If step 6 fails, perhaps due to Aggregator outage, events from 100 to 110 are already sent to the downstream, but the new offset 110 is not persisted in upstream Kafka. In this case, a new Aggregator would consume again from offset 100, even if those events are already processed, causing duplicate data.")]),e._v(" "),s("p",[e._v("The most straightforward solution (Figure 18) is to use exteral file storage, such as HDFS or 3, to record the offset. However, this solution has issues as well.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(750),alt:"Figure 18"}}),s("br"),e._v(" "),s("em",[e._v("Figure 18 Record the offset")])]),e._v(" "),s("p",[e._v("In step 3, the aggregator will process events from offset 100 to 110, only if the last offset stored in external storage\nis 100. If the offset stored in the storage is 110, the aggregator ignores events before offset 110.")]),e._v(" "),s("p",[e._v("But this design has a major problem: the offset is saved to HDFS / S3 (step 3.2) before the aggregation result is sent\ndownstream. If step 4 fails due to Aggregator outage, events from 100 to 110 will never be processed by a newly\nbrought up aggregator node, since the offset stored in external storage is 110.")]),e._v(" "),s("p",[e._v("To avoid data loss, we need to save the offset once we get an acknowledgment back from downstream. The\nupdated design is shown in Figure 19.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(751),alt:"Figure 19"}}),s("br"),e._v(" "),s("em",[e._v("Figure 19 Save offset after receiving ack")])]),e._v(" "),s("p",[e._v("In this design, if the Aggregator is down before step 5.1 is executed, events from 100 to 110 will be sent\ndownstream again. To achieve “exactly-once” processing, we need to put operations between step 4 to step 6 in\none distributed transaction. A distributed transaction is a transaction that works across several nodes. If any of the\noperations fails, the whole transaction is rolled back.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(752),alt:"Figure 20"}}),s("br"),e._v(" "),s("em",[e._v("Figure 20 Distributed transaction")])]),e._v(" "),s("p",[e._v("As you can see, it's not easy to dedupe data in large-scale systems. How to achieve exactly-once processing is an\nadvanced topic. If you are interested in the details, please refer to reference material [19].")]),e._v(" "),s("h3",{attrs:{id:"scale-the-system"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#scale-the-system"}},[e._v("#")]),e._v(" Scale the system")]),e._v(" "),s("p",[e._v("From the back-of-the-envelope estimation, we know the business grows 30% per year, which doubles traffic every 3\nyears. How do we handle this growth? Let's take a look.")]),e._v(" "),s("p",[e._v("Our system consists of three independent companents: message queue, aggregation service, and database. Since\nthese components are decoupled, we can scale each one independently.")]),e._v(" "),s("h4",{attrs:{id:"scale-the-message-queue"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#scale-the-message-queue"}},[e._v("#")]),e._v(" Scale the message queue")]),e._v(" "),s("p",[e._v("We have already discussed how to scale the message queue extensively in the “Distributed Message Queue” chapter, so we'll only briefly touch on a few points.")]),e._v(" "),s("p",[s("strong",[e._v("Producers")]),e._v(". We don't limit the number of producer instances, so the scalability of producers can be easily achieved."),s("br"),e._v(" "),s("strong",[e._v("Consumers")]),e._v(". Inside a consumer group, the rebalancing mechanism helps to scale the consumers by adding or\nremoving nodes. As shown in Figure 21, by adding two more consumers, each consumer only processes events\nfrom one partition.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(753),alt:"Figure 21"}}),s("br"),e._v(" "),s("em",[e._v("Figure 21 Add consumers")])]),e._v(" "),s("p",[e._v("When there are hundreds of Kafka consumers in the system, consumer rebalance can be quite slow and could take\na few minutes or even more. Therefore, if more consumers need to be added, try to do it during off-peak hours to\nminimize the impact.")]),e._v(" "),s("p",[s("strong",[e._v("Brokers")])]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Hashing key")]),s("br"),e._v("\nUsing "),s("em",[e._v("ad_id")]),e._v(" as hashing key for Kafka partition to store events from the same ad_id in the same Kafka partition. In this case, an aggregation service can subscribe to all events of the same ad_id from one single partition,")]),e._v(" "),s("li",[s("strong",[e._v("The number of partitions")]),s("br"),e._v("\nIf the number of partitions changes, events of the same ad_id might be mapped to a different partition. Therefore, it's recommended to pre-allocate enough partitions in advance, to avoid dynamically increasing the number of partitions in production")]),e._v(" "),s("li",[s("strong",[e._v("Topic physical sharding")]),s("br"),e._v("\nOne single topic is usually not enough. We can split the data by geography (topic_north_america, topic_europe,\ntopic_asia, etc.) or by business type (topic_web_ads, topic_mobile_ads, etc).\n"),s("ul",[s("li",[e._v("Pros: Slicing data to different topics can help increase the system throughput. With fewer consumers for a single topic, the time to rebalance consumer groups is reduced.")]),e._v(" "),s("li",[e._v("Cons: It introduces extra complexity and increases maintenance costs.")])])])]),e._v(" "),s("h4",{attrs:{id:"scale-the-aggregation-service"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#scale-the-aggregation-service"}},[e._v("#")]),e._v(" Scale the aggregation service")]),e._v(" "),s("p",[e._v("In the high-level design, we talked about the aggregation service being a map/reduce operation. Figure 22 shows how things are wired together.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(754),alt:"Figure 22"}}),s("br"),e._v(" "),s("em",[e._v("Figure 22 Aggregation service")])]),e._v(" "),s("p",[e._v("If you are interested in the details, please refer to reference material [20]. Aggregation service is horizontally scalable by adding or removing nodes. Here is an interesting question; how do we increase the throughput of the aggregation service? There are two options.")]),e._v(" "),s("p",[e._v("Option 1: Allocate events with different ad_ids to different threads, as shown in Figure 23")]),e._v(" "),s("p",[s("img",{attrs:{src:a(755),alt:"Figure 23"}}),s("br"),e._v(" "),s("em",[e._v("Figure 23 Multi-threading")])]),e._v(" "),s("p",[e._v("Option 2: Deploy aggregation service nodes on resource providers like Apache Hadoop YARN [21]. You can think of\nthis approach as utilizing multi-processing.")]),e._v(" "),s("p",[e._v("Option 1 is easier to implement and doesn't depend on resource providers. In reality, however, option 2 is more\nwidely used because we can scale the system by adding more computing resources.")]),e._v(" "),s("h4",{attrs:{id:"scale-the-database"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#scale-the-database"}},[e._v("#")]),e._v(" Scale the database")]),e._v(" "),s("p",[e._v("Cassandra natively supports horizontal scaling, in a way similar to consistent hashing")]),e._v(" "),s("p",[s("img",{attrs:{src:a(756),alt:"Figure 24"}}),s("br"),e._v(" "),s("em",[e._v("Figure 24 Virtual nodes [22]")])]),e._v(" "),s("p",[e._v("Data is evenly distributed to every node with a proper replication factor. Each node saves its own part of the ring\nbased on hashed value and also saves copies from other virtual nodes.")]),e._v(" "),s("p",[e._v("If we add a new node to the cluster, it automatically rebalances the virtual nodes among all nodes. No manual\nresharding is required. See Cassandra’s official documentation for more details [22].")]),e._v(" "),s("h4",{attrs:{id:"hotspot-issue"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hotspot-issue"}},[e._v("#")]),e._v(" Hotspot issue")]),e._v(" "),s("p",[e._v("A shard or service that receives much more data than the others is called a hotspot. This occurs because major\ncompanies have advertising budgets in the millions of dollars and their ads are clicked more often. Since events are\npartitioned by ad_id, some aggregation service nodes might receive many more ad click events than others,\npotentially causing server overload")]),e._v(" "),s("p",[e._v("This problem can be mitigated by allocating more aggregation nodes to process popular ads. Let's take a look at an\nexample as shown in Figure 25. Assume each aggregation node can handle only 100 events.")]),e._v(" "),s("ol",[s("li",[e._v("Since there are 300 events in the aggregation node (beyond the capacity of a node can handle) it applies for extra resources through the resource manager.")]),e._v(" "),s("li",[e._v("The resource manager allocates more resources (for example, add two more aggregation nodes) so the original aggregation node isn't overloaded.")]),e._v(" "),s("li",[e._v("The original aggregation node split events into 3 groups and each aggregation node handles 100 events.")]),e._v(" "),s("li",[e._v("The result is written back to the original aggregate node.")])]),e._v(" "),s("p",[s("img",{attrs:{src:a(757),alt:"Figure 25"}}),s("br"),e._v(" "),s("em",[e._v("Figure 25 Allocate more aggregation nodes")])]),e._v(" "),s("p",[e._v("There are more sophisticated ways to handle this problem, such as Global-Local Aggregation or Split Distinct Aggregation. For more information, please refer to [23].")]),e._v(" "),s("h3",{attrs:{id:"fault-tolerance"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fault-tolerance"}},[e._v("#")]),e._v(" Fault tolerance")]),e._v(" "),s("p",[e._v("Let's discuss the fault tolerance of the aggregation service. Since aggregation happens in memory, when an aggregation node goes down, the aggregated result is lost as well. We can rebuild the count by replaying events from upstream Kafka brokers.")]),e._v(" "),s("p",[e._v("Replaying data from the beginning of Kafka is slow. A good practice is to save the “system status” like upstream offset to a snapshot and recover from the last saved status. In our design, the “system status” is more than just the upstream offset because we need to store data like top "),s("em",[e._v("N")]),e._v(" most clicked ads in the past "),s("em",[e._v("M")]),e._v(" minutes.")]),e._v(" "),s("p",[e._v("Figure 26 shows a simple example of what the data looks like in a snapshot.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(758),alt:"Figure 26"}}),s("br"),e._v(" "),s("em",[e._v("Figure 26 Data in a snapshot")])]),e._v(" "),s("p",[e._v("With a snapshot, the failover process of the aggregation service is quite simple. If one aggregation service node\nfails, we bring up a new node and recover data from the latest snapshot (Figure 27). If there are new events that\narive after the last snapshot was taken, the new aggregation node will pull those data from the Kafka broker for\nreplay.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(759),alt:"Figure 27"}}),s("br"),e._v(" "),s("em",[e._v("Figure 27 Aggregation node failover")])]),e._v(" "),s("h3",{attrs:{id:"data-monitoring-and-correctness"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#data-monitoring-and-correctness"}},[e._v("#")]),e._v(" Data monitoring and correctness")]),e._v(" "),s("p",[e._v("As mentioned earlier, aggregation results can be used for RTB and billing purposes. It's critical to monitor the system’s health and to ensure correctness.")]),e._v(" "),s("h4",{attrs:{id:"continuous-monitoring"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#continuous-monitoring"}},[e._v("#")]),e._v(" Continuous monitoring")]),e._v(" "),s("p",[e._v("Here are some metrics we might want to monitor:")]),e._v(" "),s("ul",[s("li",[e._v("Latency. Since latency can be introduced at each stage, it's invaluable to track timestamps as events flow\nthrough different parts of the system. The differences between those timestamps can be exposed as latency\nmetrics.")]),e._v(" "),s("li",[e._v("Message queue size. If there is a sudden increase in queue size, we may need to add more aggregation nodes.\nNotice that Kafka is a message queue implemented as a distributed commit log, so we need to monitor the\nrecords-lag metrics instead.")]),e._v(" "),s("li",[e._v("System resources on aggregation nodes: CPU, disk, JVM, etc.")])]),e._v(" "),s("h4",{attrs:{id:"reconciliation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reconciliation"}},[e._v("#")]),e._v(" Reconciliation")]),e._v(" "),s("p",[e._v("Reconciliation means comparing different sets of data in order to ensure data integrity. Unlike reconciliation in the\nbanking industry, where you can compare your records with the bank’s records, the result of ad click aggregation\nhas no third-party result to reconcile with.")]),e._v(" "),s("p",[e._v("What we can do is to sort the ad click events by event time in every partition at the end of the day, by using a batch\njob and reconciling with the real-time aggregation result. If we have higher accuracy requirements, we can use a\nsmaller aggregation window; for example, one hour. Please note, no matter which aggregation window is used, the\nresult from the batch job might not match exactly with the real-time aggregation result, since some events might\narrive late (see Time section).")]),e._v(" "),s("p",[e._v("Figure 28 shows the final design diagram with reconciliation support.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(760),alt:"Figure 28"}}),s("br"),e._v(" "),s("em",[e._v("Figure 28 Final design")])]),e._v(" "),s("h3",{attrs:{id:"alternative-design"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#alternative-design"}},[e._v("#")]),e._v(" Alternative design")]),e._v(" "),s("p",[e._v("In a generalist system design interview, you are not expected to know the internals of different pieces of specialized\nsoftware used in a big data pipeline. Explaining your thought process and discussing trade-offs is very important,\nwhich is why we propose a generic solution. Another option is to store ad click data in Hive, with an ElasticSearch\nlayer built for faster queries. Aggregation is usually done in OLAP databases such as ClickHouse [24] or Druid [25].\nFigure 29 shows the architecture.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(761),alt:"Figure 29"}}),s("br"),e._v(" "),s("em",[e._v("Figure 29 Alterative design")])]),e._v(" "),s("p",[e._v("For more detail on this, please refer to reference material [26]")]),e._v(" "),s("h2",{attrs:{id:"step-4-wrap-up"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#step-4-wrap-up"}},[e._v("#")]),e._v(" Step 4 - Wrap Up")]),e._v(" "),s("p",[e._v("In this chapter, we went through the process of designing an ad click event aggregation system at the scale of\nFacebook or Google. We covered:")]),e._v(" "),s("ul",[s("li",[e._v("Data model and API design.")]),e._v(" "),s("li",[e._v("Use MapReduce paradigm to aggregate ad click events.")]),e._v(" "),s("li",[e._v("Scale the message queue, aggregation service, and database.")]),e._v(" "),s("li",[e._v("Mitigate hotspot issue.")]),e._v(" "),s("li",[e._v("Monitor the system continuously.")]),e._v(" "),s("li",[e._v("Use reconciliation to ensure correctness.")]),e._v(" "),s("li",[e._v("Fault tolerance.")])]),e._v(" "),s("p",[e._v("The ad click event aggregation system is a typical big data processing system. It will be easier to understand and design if you have prior knowledge or experience with industry-standard solutions such as Apache Kafka, Apache Flink, or Apache Spark.")])])}),[],!1,null,null,null);t.default=i.exports},733:function(e,t,a){e.exports=a.p+"assets/img/f1.9cfeef3a.png"},734:function(e,t,a){e.exports=a.p+"assets/img/f2.0fd07046.png"},735:function(e,t,a){e.exports=a.p+"assets/img/f3.8c6ff044.png"},736:function(e,t,a){e.exports=a.p+"assets/img/f4.64371bd3.png"},737:function(e,t,a){e.exports=a.p+"assets/img/f5.1d8c086a.png"},738:function(e,t,a){e.exports=a.p+"assets/img/f6.f2bc84f9.png"},739:function(e,t,a){e.exports=a.p+"assets/img/f7.93249565.png"},740:function(e,t,a){e.exports=a.p+"assets/img/f8.71e0689e.png"},741:function(e,t,a){e.exports=a.p+"assets/img/f9.e9e885b8.png"},742:function(e,t,a){e.exports=a.p+"assets/img/f10.361cf6ad.png"},743:function(e,t,a){e.exports=a.p+"assets/img/f11.2b0622a4.png"},744:function(e,t,a){e.exports=a.p+"assets/img/f12.eb2a7d65.png"},745:function(e,t,a){e.exports=a.p+"assets/img/f13.48be5615.png"},746:function(e,t,a){e.exports=a.p+"assets/img/f14.47f35395.png"},747:function(e,t,a){e.exports=a.p+"assets/img/f15.2e876e30.png"},748:function(e,t,a){e.exports=a.p+"assets/img/f16.459d217d.png"},749:function(e,t,a){e.exports=a.p+"assets/img/f17.239acc2e.png"},750:function(e,t,a){e.exports=a.p+"assets/img/f18.059777cf.png"},751:function(e,t,a){e.exports=a.p+"assets/img/f19.16bbc0c9.png"},752:function(e,t,a){e.exports=a.p+"assets/img/f20.98c38478.png"},753:function(e,t,a){e.exports=a.p+"assets/img/f21.b726e330.png"},754:function(e,t,a){e.exports=a.p+"assets/img/f22.d0eafcd8.png"},755:function(e,t,a){e.exports=a.p+"assets/img/f23.871c684f.png"},756:function(e,t,a){e.exports=a.p+"assets/img/f24.a578a785.png"},757:function(e,t,a){e.exports=a.p+"assets/img/f25.b5c26ffd.png"},758:function(e,t,a){e.exports=a.p+"assets/img/f26.c0d48833.png"},759:function(e,t,a){e.exports=a.p+"assets/img/f27.d1ef470e.png"},760:function(e,t,a){e.exports=a.p+"assets/img/f28.90db5d78.png"},761:function(e,t,a){e.exports=a.p+"assets/img/f29.8327ce2a.png"}}]);