(window.webpackJsonp=window.webpackJsonp||[]).push([[441],{1670:function(e,t,a){"use strict";a.r(t);var o=a(7),n=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"chapter-15-choosing-your-database"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#chapter-15-choosing-your-database"}},[e._v("#")]),e._v(" Chapter 15. Choosing Your Database")]),e._v(" "),a("p",[e._v("At this point in the book, we’ve covered a lot of the general issues you need to be aware of to make\ndecisions in the new world of polyglot persistence. It’s now time to talk about choosing your\ndatabases for future development work. Naturally, we don’t know your particular circumstances, so\nwe can’t give you your answer, nor can we reduce it to a simple set of rules to follow. Furthermore,\nit’s still early days in the production use of NoSQL systems, so even what we do know is immature—\nin a couple of years we may well think differently.")]),e._v(" "),a("p",[e._v("We see two broad reasons to consider a NoSQL database: programmer productivity and data\naccess performance. In different cases these forces may complement or contradict each other. Both of\nthem are difficult to assess early on in a project, which is awkward since your choice of a data\nstorage model is difficult to abstract so as to allow you to change your mind later on.")]),e._v(" "),a("h2",{attrs:{id:"_15-1-programmer-productivity"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-1-programmer-productivity"}},[e._v("#")]),e._v(" 15.1. Programmer Productivity")]),e._v(" "),a("p",[e._v("Talk to any developer of an enterprise application, and you’ll sense frustration from working with\nrelational databases. Information is usually collected and displayed in terms of aggregates, but it has\nto be transformed into relations in order to persist it. This chore is easier than it used to be; during the\n1990s many projects groaned under the effort of building object-relational mapping layers. By the\n2000s, we’ve seen popular ORM frameworks such as Hibernate, iBATIS, and Rails Active Record\nthat reduce much of that burden. But this has not made the problem go away. ORMs are a leaky\nabstraction, there are always some cases that need more attention—particularly in order to get decent\nperformance.")]),e._v(" "),a("p",[e._v("In this situation aggregate-oriented databases can offer a tempting deal. We can remove the ORM\nand persist aggregates naturally as we use them. We’ve come across several projects that claim\npalpable benefits from moving to an aggregate-oriented solution.")]),e._v(" "),a("p",[e._v("Graph databases offer a different simplification. Relational databases do not do a good job with\ndata that has a lot of relationships. A graph database offers both a more natural storage API for this\nkind of data and query capabilities designed around these kinds of structures.")]),e._v(" "),a("p",[e._v("All kinds of NoSQL systems are better suited to nonuniform data. If you find yourself struggling\nwith a strong schema in order to support ad-hoc fields, then the schemaless NoSQL databases can\noffer considerable relief.")]),e._v(" "),a("p",[e._v("These are the major reasons why the programming model of NoSQL databases may improve the\nproductivity of your development team. The first step of assessing this for your circumstances is to\nlook at what your software will need to do. Run through the current features and see if and how the\ndata usage fits. As you do this, you may begin to see that a particular data model seems like a good fit.\nThat closeness of fit suggests that using that model will lead to easier programming.")]),e._v(" "),a("p",[e._v("As you do this, remember that polyglot persistence is about using multiple data storage solutions. It\nmay be that you’ll see different data storage models fit different parts of your data. This would\nsuggest using different databases for different aspects of your data. Using multiple databases is\ninherently more complex than using a single store, but the advantages of a good fit in each case may\nbe better overall.")]),e._v(" "),a("p",[e._v("As you look at the data model fit, pay particular attention to cases where there is a problem. You may see most of your features will work well with an aggregate, but a few will not. Having a few features that don’t fit the model well isn’t a reason to avoid the model—the difficulties of the bad fit\nmay not overwhelm the advantages of the good fit—but it’s useful to spot and highlight these bad fit\ncases.")]),e._v(" "),a("p",[e._v("Going through your features and assessing your data needs should lead you to one or more\nalternatives for how to handle your database needs. This will give you a starting point, but the next\nstep is to try things out by actually building software. Take some initial features and build them, while\npaying close attention to how straightforward it is to use the technology you’re considering. In this\nsituation, it may be worthwhile to build the same features with a couple of different databases in\norder to see which works best. People are often reluctant to do this—no one likes to build software\nthat will be discarded. Yet this is an essential way to judge how effective a particular framework is.")]),e._v(" "),a("p",[e._v("Sadly, there is no way to properly measure how productive different designs are. We have no way\nof properly measuring output. Even if you build exactly the same feature, you can’t truly compare the\nproductivity because knowledge of building it once makes it easier a second time, and you can’t build\nthem simultaneously with identical teams. What you can do is ensure the people who did the work can\ngive an opinion. Most developers can sense when they are more productive in one environment than\nanother. Although this is a subjective judgment, and you may well get disagreements between team\nmembers, this is the best judgment you will get. In the end we believe the team doing the work should\ndecide.")]),e._v(" "),a("p",[e._v("When trying out a database to judge productivity, it’s important to also try out some of the bad fit\ncases we mentioned earlier. That way the team can get a feeling of both the happy path and the\ndifficult one, to gain an overall impression.")]),e._v(" "),a("p",[e._v("This approach has its flaws. Often you can’t get a full appreciation of a technology without\nspending many months using it—and running an assessment for that long is rarely cost-effective. But\nlike many things in life, we need to make the best assessment we can, knowing its flaws, and go with\nthat. The essential thing here is to base the decision on as much real programming as you can. Even a\nmere week working with a technology can tell you things you’d never learn from a hundred vendor\npresentations.")]),e._v(" "),a("h2",{attrs:{id:"_15-2-data-access-performance"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-2-data-access-performance"}},[e._v("#")]),e._v(" 15.2. Data-Access Performance")]),e._v(" "),a("p",[e._v("The concern that led to the growth of NoSQL databases was rapid access to lots of data. As large\nwebsites emerged, they wanted to grow horizontally and run on large clusters. They developed the\nearly NoSQL databases to help them run efficiently on such architectures. As other data users follow\ntheir lead, again the focus is on accessing data rapidly, often with large volumes involved.")]),e._v(" "),a("p",[e._v("There are many factors that can determine a database’s better performance than the relational\ndefault in various circumstances. A aggregate-oriented database may be very fast for reading or\nretrieving aggregates compared to a relational database where data is spread over many tables.\nEasier sharding and replication over clusters allows horizontal scaling. A graph database can\nretrieve highly connected data more quickly than using relational joins.")]),e._v(" "),a("p",[e._v("If you’re investigating NoSQL databases based on performance, the most important thing you must\ndo is to test their performance in the scenarios that matter to you. Reasoning about how a database\nmay perform can help you build a short list, but the only way you can assess performance properly is\nto build something, run it, and measure it.")]),e._v(" "),a("p",[e._v("When building a performance assessment, the hardest thing is often getting a realistic set of\nperformance tests. You can’t build your actual system, so you need to build a representative subset.\nIt’s important, however, for this subset to be as faithful a representative as possible. It’s no good\ntaking a database that’s intended to serve hundreds of concurrent users and assessing its performance\nwith a single user. You are going to need to build representative loads and data volumes.")]),e._v(" "),a("p",[e._v("Particularly if you are building a public website, it can be difficult to build a high-load testbed.\nHere, a good argument can be made for using cloud computing resources both to generate load and to\nbuild a test cluster. The elastic nature of cloud provisioning is very helpful for short-lived\nperformance assessment work.")]),e._v(" "),a("p",[e._v("You’re not going to be able to test every way in which your application will be used, so you need\nto build a representative subset. Choose scenarios that are the most common, the most performance-\ndependent, and those that don’t seem to fit your database model well. The latter may alert you to any\nrisks outside of your main use cases.")]),e._v(" "),a("p",[e._v("Coming up with volumes to test for can be tricky, especially early on in a project when it’s not\nclear what your production volumes are likely to be. You will have to come up with something to\nbase your thinking on, so be sure to make it explicit and to communicate it with all the stakeholders.\nMaking it explicit reduces the chance that different people have varying ideas on what a “heavy read\nload” is. It also allows you to spot problems more easily should your later discoveries wander off\nyour original assumptions. Without making your assumptions explicit, it’s easier to drift away from\nthem without realizing you need to redo your testbed as you learn new information.")]),e._v(" "),a("h2",{attrs:{id:"_15-3-sticking-with-the-default"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-3-sticking-with-the-default"}},[e._v("#")]),e._v(" 15.3. Sticking with the Default")]),e._v(" "),a("p",[e._v("Naturally we think that NoSQL is a viable option in many circumstances—otherwise we wouldn’t\nhave spent several months writing this book. But we also realize that there are many cases, indeed the\nmajority of cases, where you’re better off sticking with the default option of a relational database.")]),e._v(" "),a("p",[e._v("Relational databases are well known; you can easily find people with the experience of using them.\nThey are mature, so you are less likely to run into the rough edges of new technology. There are lots\nof tools that are built on relational technology that you can take advantage of. You also don’t have to\ndeal with the political issues of making an unusual choice—picking a new technology will always\nintroduce a risk of problems should things run into difficulties.")]),e._v(" "),a("p",[e._v("So, on the whole, we tend to take a view that to choose a NoSQL database you need to show a real\nadvantage over relational databases for your situation. There’s no shame in doing the assessments for\nprogrammability and performance, finding no clear advantage, and staying with the relational option.\nWe think there are many cases where it is advantageous to use NoSQL databases, but “many” does\nnot mean “all” or even “most.”")]),e._v(" "),a("h2",{attrs:{id:"_15-4-hedging-your-bets"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-4-hedging-your-bets"}},[e._v("#")]),e._v(" 15.4. Hedging Your Bets")]),e._v(" "),a("p",[e._v("One of the greatest difficulties we have in giving advice on choosing a data-storage option is that we\ndon’t have that much data to go on. As we write this, we are only seeing very early adopters\ndiscussing their experiences with these technologies, so we don’t have a clear picture of the actual\npros and cons.")]),e._v(" "),a("p",[e._v("With the situation this uncertain, there’s more of an argument for encapsulating your database\nchoice—keeping all your database code in a section of your codebase that is relatively easy to")]),e._v(" "),a("p",[e._v("replace should you decide to change your database choice later. The classic way to do this is through\nan explicit data store layer in your application—using patterns such as Data Mapper and Repository\n[Fowler PoEAA]. Such an encapsulation layer does carry a cost, particularly when you are unsure\nabout using quite different models, such as key-value versus graph data models. Worse still, we don’t\nhave experience yet with encapsulating data layers between these very different kinds of data stores.")]),e._v(" "),a("p",[e._v("On the whole, our advice is to encapsulate as a default strategy, but pay attention to the cost of\ninsulating layer. If it’s getting too much of a burden, for example by making it harder to use some\nhelpful database features, then it’s a good argument for using the database that has those features. This\ninformation may be just what you need to make a database choice and thus eliminate the\nencapsulation.")]),e._v(" "),a("p",[e._v("This is another argument for decomposing the database layer into services that encapsulate data\nstorage (“Service Usage over Direct Data Store Usage,” p. 136 ). As well as reducing coupling\nbetween various services, this has the additional advantage of making it easier to replace a database\nshould things not work out in the future. This is a plausible approach even if you end up using the\nsame database everywhere—should things go badly, you can gradually swap it out, focusing on the\nmost problematic services first.")]),e._v(" "),a("p",[e._v("This design advice applies just as much if you prefer to stick with a relational option. By\nencapsulating segments of your database into services, you can replace parts of your data store with a\nNoSQL technology as it matures and the advantages become clearer.")]),e._v(" "),a("h2",{attrs:{id:"_15-5-key-points"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-5-key-points"}},[e._v("#")]),e._v(" 15.5. Key Points")]),e._v(" "),a("ul",[a("li",[e._v("The two main reasons to use NoSQL technology are:\n"),a("ul",[a("li",[e._v("To improve programmer productivity by using a database that better matches an application’s\nneeds.")]),e._v(" "),a("li",[e._v("To improve data access performance via some combination of handling larger data volumes,\nreducing latency, and improving throughput.")])])]),e._v(" "),a("li",[e._v("It’s essential to test your expectations about programmer productivity and/or performance\nbefore committing to using a NoSQL technology.")]),e._v(" "),a("li",[e._v("Service encapsulation supports changing data storage technologies as needs and technology\nevolve. Separating parts of applications into services also allows you to introduce NoSQL into\nan existing application.")]),e._v(" "),a("li",[e._v("Most applications, particularly nonstrategic ones, should stick with relational technology—at\nleast until the NoSQL ecosystem becomes more mature.")])]),e._v(" "),a("h2",{attrs:{id:"_15-6-final-thoughts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-6-final-thoughts"}},[e._v("#")]),e._v(" 15.6. Final Thoughts")]),e._v(" "),a("p",[e._v("We hope you’ve found this book enlightening. When we started writing it, we were frustrated by the\nlack of anything that would give us a broad survey of the NoSQL world. In writing this book we had\nto make that survey ourselves, and we’ve found it an enjoyable journey. We hope your journey\nthrough this material is considerably quicker but no less enjoyable.")]),e._v(" "),a("p",[e._v("At this point you may be considering making use of a NoSQL technology. If so this book is only an\nearly step in building your understanding. We urge you to download some databases and work with\nthem, for we’re of the firm conviction that you can only understand a technology properly by working\nwith it—finding its strengths and the inevitable gotchas that never make it into the documentation.")]),e._v(" "),a("p",[e._v("We expect that most people, including most readers of this book, will not be using NoSQL for a\nwhile. It is a new technology and we are still early in the process of understanding when to use it and\nhow to use it well. But as with anything in the software world, things are changing more rapidly than\nwe dare predict, so do keep an eye on what’s happening in this field.")]),e._v(" "),a("p",[e._v("We hope you’ll also find other books and articles to help you. We think the best material on\nNoSQL will be written after this book is done, so we can’t point you to anywhere in particular as we\nwrite this. We do have an active presence on the Web, so for our more up-to-date thoughts on the\nNoSQL world take a look at "),a("a",{attrs:{href:"http://www.sadalage.com",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://www.sadalage.com"),a("OutboundLink")],1),e._v(" and "),a("a",{attrs:{href:"http://martinfowler.com/nosql.html.",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://martinfowler.com/nosql.html."),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);