(window.webpackJsonp=window.webpackJsonp||[]).push([[251],{818:function(e,t,n){"use strict";n.r(t);var a=n(7),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_7-error-handling"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_7-error-handling"}},[e._v("#")]),e._v(" 7. Error Handling")]),e._v(" "),n("p",[e._v("It might seem odd to have a section about error handling in a book about clean code. Error\nhandling is just one of those things that we all have to do when we program. Input can be\nabnormal and devices can fail. In short, things can go wrong, and when they do, we as pro-\ngrammers are responsible for making sure that our code does what it needs to do.")]),e._v(" "),n("p",[e._v("The connection to clean code, however, should be clear. Many code bases are com-\npletely dominated by error handling. When I say dominated, I don’t mean that error han-\ndling is all that they do. I mean that it is nearly impossible to see what the code does\nbecause of all of the scattered error handling. Error handling is important, "),n("em",[e._v("but if it\nobscures logic, it’s wrong")]),e._v(".")]),e._v(" "),n("p",[e._v("In this chapter I’ll outline a number of techniques and considerations that you can use\nto write code that is both clean and robust—code that handles errors with grace and style.")]),e._v(" "),n("p",[e._v("104 "),n("strong",[e._v("Chapter 7: Error Handling")])]),e._v(" "),n("h2",{attrs:{id:"use-exceptions-rather-than-return-codes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#use-exceptions-rather-than-return-codes"}},[e._v("#")]),e._v(" Use Exceptions Rather Than Return Codes ...")]),e._v(" "),n("p",[e._v("Back in the distant past there were many languages that didn’t have exceptions. In those\nlanguages the techniques for handling and reporting errors were limited. You either set an\nerror flag or returned an error code that the caller could check. The code in Listing 7-1\nillustrates these approaches.")]),e._v(" "),n("p",[e._v("The problem with these approaches is that they clutter the caller. The caller must\ncheck for errors immediately after the call. Unfortunately, it’s easy to forget. For this rea-\nson it is better to throw an exception when you encounter an error. The calling code is\ncleaner. Its logic is not obscured by error handling.")]),e._v(" "),n("p",[e._v("Listing 7-2 shows the code after we’ve chosen to throw exceptions in methods that\ncan detect errors.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('Listing 7-1\nDeviceController.java\npublic class DeviceController {\n...\npublic void sendShutDown() {\nDeviceHandle handle = getHandle(DEV1);\n// Check the state of the device\nif (handle != DeviceHandle.INVALID) {\n// Save the device status to the record field\nretrieveDeviceRecord(handle);\n// If not suspended, shut down\nif (record.getStatus() != DEVICE_SUSPENDED) {\npauseDevice(handle);\nclearDeviceWorkQueue(handle);\ncloseDevice(handle);\n} else {\nlogger.log("Device suspended. Unable to shut down");\n}\n} else {\nlogger.log("Invalid handle for: " + DEV1.toString());\n}\n}\n...\n}\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Listing 7-2\nDeviceController.java (with exceptions)\npublic class DeviceController {\n...\npublic void sendShutDown() {\ntry {\ntryToShutDown();\n} catch (DeviceShutDownError e) {\nlogger.log(e);\n}\n}\n")])])]),n("p",[n("strong",[e._v("Write Your Try-Catch-Finally Statement First")]),e._v(" 105")]),e._v(" "),n("p",[e._v("Notice how much cleaner it is. This isn’t just a matter of aesthetics. The code is better\nbecause two concerns that were tangled, the algorithm for device shutdown and error han-\ndling, are now separated. You can look at each of those concerns and understand them\nindependently.")]),e._v(" "),n("h2",{attrs:{id:"write-your-try-catch-finally-statement-first"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#write-your-try-catch-finally-statement-first"}},[e._v("#")]),e._v(" Write Your Try-Catch-Finally Statement First ...")]),e._v(" "),n("p",[e._v("One of the most interesting things about exceptions is that they "),n("em",[e._v("define a scope")]),e._v(" within your\nprogram. When you execute code in the tryportion of a try-catch-finallystatement, you\nare stating that execution can abort at any point and then resume at the catch.")]),e._v(" "),n("p",[e._v("In a way, tryblocks are like transactions. Your catchhas to leave your program in a\nconsistent state, no matter what happens in the try. For this reason it is good practice to\nstart with a try-catch-finallystatement when you are writing code that could throw\nexceptions. This helps you define what the user of that code should expect, no matter what\ngoes wrong with the code that is executed in the try.")]),e._v(" "),n("p",[e._v("Let’s look at an example. We need to write some code that accesses a file and reads\nsome serialized objects.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('We start with a unit test that shows that we’ll get an exception when the file doesn’t exist:\n@Test(expected = StorageException.class)\npublic void retrieveSectionShouldThrowOnInvalidFileName() {\nsectionStore.retrieveSection("invalid - file");\n}\nThe test drives us to create this stub:\npublic List<RecordedGrip> retrieveSection(String sectionName) {\n// dummy return until we have a real implementation\nreturn new ArrayList<RecordedGrip>();\n}\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('private void tryToShutDown() throws DeviceShutDownError {\nDeviceHandle handle = getHandle(DEV1);\nDeviceRecord record = retrieveDeviceRecord(handle);\npauseDevice(handle);\nclearDeviceWorkQueue(handle);\ncloseDevice(handle);\n}\nprivate DeviceHandle getHandle(DeviceID id) {\n...\nthrow new DeviceShutDownError("Invalid handle for: " + id.toString());\n...\n}\n...\n}\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Listing 7-2 (continued)\nDeviceController.java (with exceptions)\n")])])]),n("p",[e._v("106 "),n("strong",[e._v("Chapter 7: Error Handling")])]),e._v(" "),n("p",[e._v("Our test fails because it doesn’t throw an exception. Next, we change our implementa-\ntion so that it attempts to access an invalid file. This operation throws an exception:")]),e._v(" "),n("p",[e._v("public List"),n("RecordedGrip",[e._v(' retrieveSection(String sectionName) {\ntry {\nFileInputStream stream = new FileInputStream(sectionName)\n} catch (Exception e) {\nthrow new StorageException("retrieval error", e);\n}\nreturn new ArrayList'),n("RecordedGrip",[e._v("();\n}\nOur test passes now because we’ve caught the exception. At this point, we can refac-\ntor. We can narrow the type of the exception we catch to match the type that is actually\nthrown from the FileInputStream constructor: FileNotFoundException:")])],1)],1),e._v(" "),n("p",[e._v("public List"),n("RecordedGrip",[e._v(' retrieveSection(String sectionName) {\ntry {\nFileInputStream stream = new FileInputStream(sectionName);\nstream.close();\n} catch (FileNotFoundException e) {\nthrow new StorageException("retrieval error”, e);\n}\nreturn new ArrayList'),n("RecordedGrip",[e._v("();\n}\nNow that we’ve defined the scope with a try-catchstructure, we can use TDD to build\nup the rest of the logic that we need. That logic will be added between the creation of the\nFileInputStream and the close, and can pretend that nothing goes wrong.")])],1)],1),e._v(" "),n("p",[e._v("Try to write tests that force exceptions, and then add behavior to your handler to sat-\nisfy your tests. This will cause you to build the transaction scope of the tryblock first and\nwill help you maintain the transaction nature of that scope.")]),e._v(" "),n("h2",{attrs:{id:"use-unchecked-exceptions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#use-unchecked-exceptions"}},[e._v("#")]),e._v(" Use Unchecked Exceptions ...")]),e._v(" "),n("p",[e._v("The debate is over. For years Java programmers have debated over the benefits and liabili-\nties of checked exceptions. When checked exceptions were introduced in the first version\nof Java, they seemed like a great idea. The signature of every method would list all of the\nexceptions that it could pass to its caller. Moreover, these exceptions were part of the type\nof the method. Your code literally wouldn’t compile if the signature didn’t match what your\ncode could do.")]),e._v(" "),n("p",[e._v("At the time, we thought that checked exceptions were a great idea; and yes, they can\nyield "),n("em",[e._v("some")]),e._v(" benefit. However, it is clear now that they aren’t necessary for the production of\nrobust software. C# doesn’t have checked exceptions, and despite valiant attempts, C++\ndoesn’t either. Neither do Python or Ruby. Yet it is possible to write robust software in all\nof these languages. Because that is the case, we have to decide—really—whether checked\nexceptions are worth their price.")]),e._v(" "),n("p",[n("strong",[e._v("Define Exception Classes in Terms of a Caller’s Needs")]),e._v(" 107")]),e._v(" "),n("p",[e._v("What price? The price of checked exceptions is an Open/Closed Principle^1 violation.\nIf you throw a checked exception from a method in your code and the catch is three levels\nabove, "),n("em",[e._v("you must declare that exception in the signature of each method between you and\nthecatch")]),e._v(". This means that a change at a low level of the software can force signature\nchanges on many higher levels. The changed modules must be rebuilt and redeployed,\neven though nothing they care about changed.")]),e._v(" "),n("p",[e._v("Consider the calling hierarchy of a large system. Functions at the top call functions\nbelow them, which call more functions below them, ad infinitum. Now let’s say one of the\nlowest level functions is modified in such a way that it must throw an exception. If that\nexception is checked, then the function signature must add a throwsclause. But this\nmeans that every function that calls our modified function must also be modified either to\ncatch the new exception or to append the appropriate throwsclause to its signature. Ad\ninfinitum. The net result is a cascade of changes that work their way from the lowest levels\nof the software to the highest! Encapsulation is broken because all functions in the path\nof a throw must know about details of that low-level exception. Given that the purpose of\nexceptions is to allow you to handle errors at a distance, it is a shame that checked excep-\ntions break encapsulation in this way.")]),e._v(" "),n("p",[e._v("Checked exceptions can sometimes be useful if you are writing a critical library: You\nmust catch them. But in general application development the dependency costs outweigh\nthe benefits.")]),e._v(" "),n("h2",{attrs:{id:"provide-context-with-exceptions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#provide-context-with-exceptions"}},[e._v("#")]),e._v(" Provide Context with Exceptions .")]),e._v(" "),n("p",[e._v("Each exception that you throw should provide enough context to determine the source and\nlocation of an error. In Java, you can get a stack trace from any exception; however, a stack\ntrace can’t tell you the intent of the operation that failed.")]),e._v(" "),n("p",[e._v("Create informative error messages and pass them along with your exceptions. Men-\ntion the operation that failed and the type of failure. If you are logging in your application,\npass along enough information to be able to log the error in your catch.")]),e._v(" "),n("h2",{attrs:{id:"define-exception-classes-in-terms-of-a-caller-s-needs"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#define-exception-classes-in-terms-of-a-caller-s-needs"}},[e._v("#")]),e._v(" Define Exception Classes in Terms of a Caller’s Needs ..")]),e._v(" "),n("p",[e._v("There are many ways to classify errors. We can classify them by their source: Did they\ncome from one component or another? Or their type: Are they device failures, network\nfailures, or programming errors? However, when we define exception classes in an appli-\ncation, our most important concern should be "),n("em",[e._v("how they are caught")]),e._v(".")]),e._v(" "),n("ol",[n("li",[e._v("[Martin].")])]),e._v(" "),n("p",[e._v("108 "),n("strong",[e._v("Chapter 7: Error Handling")])]),e._v(" "),n("p",[e._v("Let’s look at an example of poor exception classification. Here is a try-catch-finally\nstatement for a third-party library call. It covers all of the exceptions that the calls can\nthrow:")]),e._v(" "),n("p",[e._v('ACMEPort port = new ACMEPort(12);\ntry {\nport.open();\n} catch (DeviceResponseException e) {\nreportPortError(e);\nlogger.log("Device response exception", e);\n} catch (ATM1212UnlockedException e) {\nreportPortError(e);\nlogger.log("Unlock exception", e);\n} catch (GMXError e) {\nreportPortError(e);\nlogger.log("Device response exception");\n} finally {\n...\n}\nThat statement contains a lot of duplication, and we shouldn’t be surprised. In most\nexception handling situations, the work that we do is relatively standard regardless of the\nactual cause. We have to record an error and make sure that we can proceed.')]),e._v(" "),n("p",[e._v("In this case, because we know that the work that we are doing is roughly the same\nregardless of the exception, we can simplify our code considerably by wrapping the API\nthat we are calling and making sure that it returns a common exception type:")]),e._v(" "),n("p",[e._v("LocalPort port = new LocalPort(12);\ntry {\nport.open();\n} catch (PortDeviceFailure e) {\nreportError(e);\nlogger.log(e.getMessage(), e);\n} finally {\n...\n}\nOurLocalPortclass is just a simple wrapper that catches and translates exceptions\nthrown by the ACMEPort class:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public class LocalPort {\nprivate ACMEPort innerPort;\npublic LocalPort(int portNumber) {\ninnerPort = new ACMEPort(portNumber);\n}\npublic void open() {\ntry {\ninnerPort.open();\n} catch (DeviceResponseException e) {\nthrow new PortDeviceFailure(e);\n} catch (ATM1212UnlockedException e) {\nthrow new PortDeviceFailure(e);\n} catch (GMXError e) {\n")])])]),n("p",[n("strong",[e._v("Define the Normal Flow")]),e._v(" 109")]),e._v(" "),n("p",[e._v("throw new PortDeviceFailure(e);\n}\n}\n}\nWrappers like the one we defined for ACMEPortcan be very useful. In fact, wrapping\nthird-party APIs is a best practice. When you wrap a third-party API, you minimize your\ndependencies upon it: You can choose to move to a different library in the future without\nmuch penalty. Wrapping also makes it easier to mock out third-party calls when you are\ntesting your own code.")]),e._v(" "),n("p",[e._v("One final advantage of wrapping is that you aren’t tied to a particular vendor’s API\ndesign choices. You can define an API that you feel comfortable with. In the preceding\nexample, we defined a single exception type for portdevice failure and found that we\ncould write much cleaner code.")]),e._v(" "),n("p",[e._v("Often a single exception class is fine for a particular area of code. The information\nsent with the exception can distinguish the errors. Use different classes only if there are\ntimes when you want to catch one exception and allow the other one to pass through.")]),e._v(" "),n("h2",{attrs:{id:"define-the-normal-flow"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#define-the-normal-flow"}},[e._v("#")]),e._v(" Define the Normal Flow")]),e._v(" "),n("p",[e._v("If you follow the advice in the preceding\nsections, you’ll end up with a good amount\nof separation between your business logic\nand your error handling. The bulk of your\ncode will start to look like a clean\nunadorned algorithm. However, the pro-\ncess of doing this pushes error detection\nto the edges of your program. You wrap\nexternal APIs so that you can throw your\nown exceptions, and you define a handler above your code so that you can deal with any\naborted computation. Most of the time this is a great approach, but there are some times\nwhen you may not want to abort.")]),e._v(" "),n("p",[e._v("Let’s take a look at an example. Here is some awkward code that sums expenses in a\nbilling application:")]),e._v(" "),n("p",[e._v("try {\nMealExpenses expenses = expenseReportDAO.getMeals(employee.getID());\nm_total += expenses.getTotal();\n} catch(MealExpensesNotFound e) {\nm_total += getMealPerDiem();\n}\nIn this business, if meals are expensed, they become part of the total. If they aren’t, the\nemployee gets a meal "),n("em",[e._v("per diem")]),e._v(" amount for that day. The exception clutters the logic.\nWouldn’t it be better if we didn’t have to deal with the special case? If we didn’t, our code\nwould look much simpler. It would look like this:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("MealExpenses expenses = expenseReportDAO.getMeals(employee.getID());\nm_total += expenses.getTotal();\n")])])]),n("p",[e._v("110 "),n("strong",[e._v("Chapter 7: Error Handling")])]),e._v(" "),n("p",[e._v("Can we make the code that simple? It turns out that we can. We can change the\nExpenseReportDAOso that it always returns a MealExpenseobject. If there are no meal\nexpenses, it returns a MealExpense object that returns the "),n("em",[e._v("per diem")]),e._v(" as its total:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public class PerDiemMealExpenses implements MealExpenses {\npublic int getTotal() {\n// return the per diem default\n}\n}\n")])])]),n("p",[e._v("This is called the SPECIAL CASE PATTERN[Fowler]. You create a class or configure an\nobject so that it handles a special case for you. When you do, the client code doesn’t have\nto deal with exceptional behavior. That behavior is encapsulated in the special case object.")]),e._v(" "),n("h2",{attrs:{id:"don-t-return-null"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#don-t-return-null"}},[e._v("#")]),e._v(" Don’t Return Null ..")]),e._v(" "),n("p",[e._v("I think that any discussion about error handling should include mention of the things we\ndo that invite errors. The first on the list is returning null. I can’t begin to count the number\nof applications I’ve seen in which nearly every other line was a check for null. Here is\nsome example code:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public void registerItem(Item item) {\nif (item != null) {\nItemRegistry registry = peristentStore.getItemRegistry();\nif (registry != null) {\nItem existing = registry.getItem(item.getID());\nif (existing.getBillingPeriod().hasRetailOwner()) {\nexisting.register(item);\n}\n}\n}\n}\n")])])]),n("p",[e._v("If you work in a code base with code like this, it might not look all that bad to you, but it is\nbad! When we return null, we are essentially creating work for ourselves and foisting\nproblems upon our callers. All it takes is one missing nullcheck to send an application\nspinning out of control.")]),e._v(" "),n("p",[e._v("Did you notice the fact that there wasn’t a null check in the second line of that nested\nifstatement? What would have happened at runtime if persistentStorewerenull? We\nwould have had a NullPointerExceptionat runtime, and either someone is catching\nNullPointerExceptionat the top level or they are not. Either way it’s "),n("em",[e._v("bad")]),e._v(". What exactly\nshould you do in response to a NullPointerExceptionthrown from the depths of your appli-\ncation?")]),e._v(" "),n("p",[e._v("It’s easy to say that the problem with the code above is that it is missing a nullcheck,\nbut in actuality, the problem is that it has "),n("em",[e._v("too many")]),e._v(". If you are tempted to return nullfrom\na method, consider throwing an exception or returning a SPECIAL CASEobject instead. If\nyou are calling a null-returning method from a third-party API, consider wrapping that\nmethod with a method that either throws an exception or returns a special case object.")]),e._v(" "),n("p",[n("strong",[e._v("Don’t Pass Null")]),e._v(" 111")]),e._v(" "),n("p",[e._v("In many cases, special case objects are an easy remedy. Imagine that you have code\nlike this:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("List<Employee> employees = getEmployees();\nif (employees != null) {\nfor(Employee e : employees) {\ntotalPay += e.getPay();\n}\n}\n")])])]),n("p",[e._v("Right now, getEmployeescan return null, but does it have to? If we change getEmployeeso\nthat it returns an empty list, we can clean up the code:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("List<Employee> employees = getEmployees();\nfor(Employee e : employees) {\ntotalPay += e.getPay();\n}\n")])])]),n("p",[e._v("Fortunately, Java has Collections.emptyList(), and it returns a predefined immutable list\nthat we can use for this purpose:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public List<Employee> getEmployees() {\nif( .. there are no employees .. )\nreturn Collections.emptyList();\n}\n")])])]),n("p",[e._v("If you code this way, you will minimize the chance of NullPointerExceptionsand your\ncode will be cleaner.")]),e._v(" "),n("h2",{attrs:{id:"don-t-pass-null"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#don-t-pass-null"}},[e._v("#")]),e._v(" Don’t Pass Null ..")]),e._v(" "),n("p",[e._v("Returning nullfrom methods is bad, but passing nullinto methods is worse. Unless you\nare working with an API which expects you to pass null, you should avoid passing null in\nyour code whenever possible.")]),e._v(" "),n("p",[e._v("Let’s look at an example to see why. Here is a simple method which calculates a met-\nric for two points:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public class MetricsCalculator\n{\npublic double xProjection(Point p1, Point p2) {\nreturn (p2.x – p1.x) * 1.5;\n}\n...\n}\nWhat happens when someone passes null as an argument?\ncalculator.xProjection(null, new Point(12, 13));\nWe’ll get a NullPointerException, of course.\nHow can we fix it? We could create a new exception type and throw it:\npublic class MetricsCalculator\n{\n")])])]),n("p",[e._v("112 "),n("strong",[e._v("Chapter 7: Error Handling")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public double xProjection(Point p1, Point p2) {\nif (p1 == null || p2 == null) {\nthrow InvalidArgumentException(\n"Invalid argument for MetricsCalculator.xProjection");\n}\nreturn (p2.x – p1.x) * 1.5;\n}\n}\n')])])]),n("p",[e._v("Is this better? It might be a little better than a nullpointer exception, but remember, we\nhave to define a handler for InvalidArgumentException. What should the handler do? Is\nthere any good course of action?")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('There is another alternative. We could use a set of assertions:\npublic class MetricsCalculator\n{\npublic double xProjection(Point p1, Point p2) {\nassert p1 != null : "p1 should not be null";\nassert p2 != null : "p2 should not be null";\nreturn (p2.x – p1.x) * 1.5;\n}\n}\n')])])]),n("p",[e._v("It’s good documentation, but it doesn’t solve the problem. If someone passes null, we’ll\nstill have a runtime error.")]),e._v(" "),n("p",[e._v("In most programming languages there is no good way to deal with a nullthat is\npassed by a caller accidentally. Because this is the case, the rational approach is to forbid\npassingnullby default. When you do, you can code with the knowledge that a nullin an\nargument list is an indication of a problem, and end up with far fewer careless mistakes.")]),e._v(" "),n("h2",{attrs:{id:"conclusion"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[e._v("#")]),e._v(" Conclusion ..")]),e._v(" "),n("p",[e._v("Clean code is readable, but it must also be robust. These are not conflicting goals. We can\nwrite robust clean code if we see error handling as a separate concern, something that is\nviewable independently of our main logic. To the degree that we are able to do that, we can\nreason about it independently, and we can make great strides in the maintainability of our\ncode.")]),e._v(" "),n("h2",{attrs:{id:"bibliography"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#bibliography"}},[e._v("#")]),e._v(" Bibliography ...")]),e._v(" "),n("p",[n("strong",[e._v("[Martin]:")]),e._v(" "),n("em",[e._v("Agile Software Development: Principles, Patterns, and Practices,")]),e._v(" Robert C.\nMartin, Prentice Hall, 2002.")])])}),[],!1,null,null,null);t.default=o.exports}}]);