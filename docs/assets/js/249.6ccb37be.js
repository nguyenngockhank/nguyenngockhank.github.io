(window.webpackJsonp=window.webpackJsonp||[]).push([[249],{1404:function(e,t,s){"use strict";s.r(t);var a=s(7),r=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"reusability"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reusability"}},[e._v("#")]),e._v(" Reusability")]),e._v(" "),s("h2",{attrs:{id:"overview"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#overview"}},[e._v("#")]),e._v(" Overview")]),e._v(" "),s("p",[e._v("Code reusability is the cornerstone of efficient and maintainable software development. It involves writing code in a way that can be used repeatedly in different parts of a project or even in entirely separate projects. This practice significantly boosts productivity, reduces development time, and improves code quality.")]),e._v(" "),s("h3",{attrs:{id:"why-is-reusability-important"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#why-is-reusability-important"}},[e._v("#")]),e._v(" Why is Reusability Important?")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Saves Time")]),e._v(": Reusing existing code eliminates the need to rewrite the same logic multiple times.")]),e._v(" "),s("li",[s("strong",[e._v("Reduces Errors")]),e._v(": Well-tested code is less likely to introduce bugs when reused.")]),e._v(" "),s("li",[s("strong",[e._v("Improves Maintainability")]),e._v(": A smaller codebase with reusable components is easier to understand and modify.")]),e._v(" "),s("li",[s("strong",[e._v("Enhances Consistency")]),e._v(": Shared code promotes consistent behavior and style across different parts of a project.")]),e._v(" "),s("li",[s("strong",[e._v("Accelerates Development")]),e._v(": By focusing on new features, developers can build applications faster.")])]),e._v(" "),s("h3",{attrs:{id:"techniques"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#techniques"}},[e._v("#")]),e._v(" Techniques")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Functions and Methods")]),e._v(": Encapsulate specific tasks into reusable functions or methods.")]),e._v(" "),s("li",[s("strong",[e._v("Modules and Libraries")]),e._v(": Create self-contained units of code for specific functionalities.")]),e._v(" "),s("li",[s("strong",[e._v("Classes and Objects")]),e._v(": Define reusable blueprints for creating objects with specific attributes and behaviors.")]),e._v(" "),s("li",[s("strong",[e._v("Design Patterns")]),e._v(": Apply proven design patterns to structure code for reusability.")]),e._v(" "),s("li",[s("strong",[e._v("Code Refactoring")]),e._v(": Continuously improve code structure and readability to enhance reusability.")])]),e._v(" "),s("h3",{attrs:{id:"examples"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#examples"}},[e._v("#")]),e._v(" Examples")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Mathematical functions")]),e._v(": sqrt, pow, sin, cos are reusable across various applications.")]),e._v(" "),s("li",[s("strong",[e._v("Data structures")]),e._v(": Lists, arrays, dictionaries, and sets are fundamental building blocks.")]),e._v(" "),s("li",[s("strong",[e._v("UI components")]),e._v(": Buttons, input fields, and menus can be reused in different parts of an interface.")]),e._v(" "),s("li",[s("strong",[e._v("API clients")]),e._v(": Libraries for interacting with external APIs can be shared among projects.")])]),e._v(" "),s("h3",{attrs:{id:"challenges"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#challenges"}},[e._v("#")]),e._v(" Challenges")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Code Coupling")]),e._v(": Tightly coupled code can hinder reusability.")]),e._v(" "),s("li",[s("strong",[e._v("Performance Overhead")]),e._v(": Excessive function calls or method invocations might impact performance.")]),e._v(" "),s("li",[s("strong",[e._v("Maintainability")]),e._v(": Reusable code should be well-documented and easy to understand.")]),e._v(" "),s("li",[s("strong",[e._v("Licensing")]),e._v(": Be aware of licensing restrictions when reusing external code.")])]),e._v(" "),s("h3",{attrs:{id:"best-practices"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#best-practices"}},[e._v("#")]),e._v(" Best Practices")]),e._v(" "),s("ul",[s("li",[e._v("Write clean and modular code.")]),e._v(" "),s("li",[e._v("Use meaningful names for functions and variables.")]),e._v(" "),s("li",[e._v("Test your reusable code thoroughly.")]),e._v(" "),s("li",[e._v("Consider performance implications.")]),e._v(" "),s("li",[e._v("Document your code effectively.")]),e._v(" "),s("li",[e._v("Leverage version control to manage code changes.")])]),e._v(" "),s("h2",{attrs:{id:"helpers-vs-utils"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#helpers-vs-utils"}},[e._v("#")]),e._v(" Helpers vs Utils")]),e._v(" "),s("p",[e._v("Reference: https://dev.to/victor1890/exploring-the-contrast-helpers-and-utils-demystified-47bo")]),e._v(" "),s("h3",{attrs:{id:"utils-utilities"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#utils-utilities"}},[e._v("#")]),e._v(" Utils (Utilities)**:")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("General purpose")]),e._v(": Utility functions or classes are designed to be used across different parts of your project. They handle common tasks that are not specific to any particular domain or feature.")]),e._v(" "),s("li",[s("strong",[e._v("Independent")]),e._v(": Ideally, utils are stateless and don't rely on any external dependencies. This makes them reusable and easier to test.")])]),e._v(" "),s("h3",{attrs:{id:"helpers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#helpers"}},[e._v("#")]),e._v(" Helpers**:")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("More specific")]),e._v(": Helper functions or classes can be more specific to a particular module, component, or feature. They might encapsulate logic related to a specific use case.")]),e._v(" "),s("li",[s("strong",[e._v("Can be stateful")]),e._v(": Helpers can sometimes have an internal state or rely on external dependencies specific to their context.")])]),e._v(" "),s("h3",{attrs:{id:"key-differences"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#key-differences"}},[e._v("#")]),e._v(" Key Differences")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Feature")]),e._v(" "),s("th",[e._v("Helpers")]),e._v(" "),s("th",[e._v("Utils")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("Scope")]),e._v(" "),s("td",[e._v("Often more specific to a component or feature")]),e._v(" "),s("td",[e._v("Typically more general-purpose")])]),e._v(" "),s("tr",[s("td",[e._v("Coupling")]),e._v(" "),s("td",[e._v("Might be more tightly coupled to other code")]),e._v(" "),s("td",[e._v("Often loosely coupled, standalone functions")])]),e._v(" "),s("tr",[s("td",[e._v("Complexity")]),e._v(" "),s("td",[e._v("Can range from simple to complex, depending on the task")]),e._v(" "),s("td",[e._v("Generally simpler, focused on core utilities")])])])]),e._v(" "),s("h2",{attrs:{id:"clean-architecture"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#clean-architecture"}},[e._v("#")]),e._v(" Clean Architecture")]),e._v(" "),s("p",[e._v("Clean architecture is a software architectural pattern that emphasizes separation of concerns, testability, and independence from external frameworks. One of its key benefits is its strong support for code reusability.")]),e._v(" "),s("h2",{attrs:{id:"how-clean-architecture-promotes-reusability"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#how-clean-architecture-promotes-reusability"}},[e._v("#")]),e._v(" How Clean Architecture Promotes Reusability")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Independent Core")]),e._v(": The core of your application, containing business logic and domain entities, is completely isolated from external frameworks and databases. This makes it highly reusable across different platforms and technologies.")]),e._v(" "),s("li",[s("strong",[e._v("Dependency Rule")]),e._v(": The dependency rule ensures that code in outer layers can depend on code in inner layers, but not vice versa. This promotes loose coupling, making components more easily replaceable and reusable.")]),e._v(" "),s("li",[s("strong",[e._v("Entities")]),e._v(": These are the heart of your domain model and represent the core business concepts. Entities are inherently reusable across different use cases and applications.")]),e._v(" "),s("li",[s("strong",[e._v("Use Cases")]),e._v(": While less reusable than entities, use cases can still be adapted for different scenarios. They often encapsulate specific business workflows and can be reused within a similar domain.")]),e._v(" "),s("li",[s("strong",[e._v("Data Access Layer")]),e._v(": This layer is responsible for interacting with data sources. While specific implementations might vary, the abstractions defined in the interface can often be reused.")])]),e._v(" "),s("h2",{attrs:{id:"shared-kernel-module"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#shared-kernel-module"}},[e._v("#")]),e._v(" Shared Kernel Module")]),e._v(" "),s("p",[e._v("A shared kernel module is a component that is shared between multiple bounded contexts in a domain-driven design (DDD) architecture. It's a strategic design pattern aimed at maximizing code reuse and consistency across different parts of the system.")]),e._v(" "),s("h3",{attrs:{id:"how-shared-kernel-promotes-reusability"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#how-shared-kernel-promotes-reusability"}},[e._v("#")]),e._v(" How Shared Kernel Promotes Reusability")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Common Language")]),e._v(": By sharing a kernel, different bounded contexts can use a common language, ensuring consistent terminology and understanding.")]),e._v(" "),s("li",[s("strong",[e._v("Code Reuse")]),e._v(": The shared kernel contains core business rules and logic that can be directly used by multiple bounded contexts, avoiding code duplication.")]),e._v(" "),s("li",[s("strong",[e._v("Consistency")]),e._v(": Shared models and invariants guarantee consistency across the system, reducing the risk of discrepancies.")])]),e._v(" "),s("h3",{attrs:{id:"key-considerations"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#key-considerations"}},[e._v("#")]),e._v(" Key Considerations")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Tight Coupling")]),e._v(": Overusing a shared kernel can lead to tight coupling between bounded contexts, reducing autonomy and increasing maintenance costs.")]),e._v(" "),s("li",[s("strong",[e._v("Change Impact")]),e._v(": Modifications to the shared kernel can affect multiple bounded contexts, requiring careful consideration and impact analysis.")]),e._v(" "),s("li",[s("strong",[e._v("Domain Complexity")]),e._v(": The shared kernel should be limited to truly core business concepts. Introducing too many details can hinder reusability and increase complexity.")])]),e._v(" "),s("h3",{attrs:{id:"best-practices-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#best-practices-2"}},[e._v("#")]),e._v(" Best Practices")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Identify Core Business Concepts")]),e._v(": Carefully select the elements to include in the shared kernel, ensuring they are essential to multiple bounded contexts.")]),e._v(" "),s("li",[s("strong",[e._v("Define Clear Boundaries")]),e._v(": Establish clear boundaries between the shared kernel and other bounded contexts to prevent excessive coupling.")]),e._v(" "),s("li",[s("strong",[e._v("Version Control")]),e._v(": Implement a versioning mechanism for the shared kernel to manage changes and their impact on dependent contexts.")]),e._v(" "),s("li",[s("strong",[e._v("Anti-Corruption Layer")]),e._v(": Consider using anti-corruption layers to isolate bounded contexts from changes in the shared kernel.\nContinuous Evaluation**: Regularly review the shared kernel to ensure it remains valuable and doesn't become a bottleneck.")])]),e._v(" "),s("h2",{attrs:{id:"event-driven-architecture"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#event-driven-architecture"}},[e._v("#")]),e._v(" Event-Driven Architecture")]),e._v(" "),s("h3",{attrs:{id:"reusability-within-the-event-store"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reusability-within-the-event-store"}},[e._v("#")]),e._v(" Reusability within the Event Store")]),e._v(" "),s("p",[e._v("Event stores are a cornerstone of event-driven architecture, providing a persistent record of system state changes. While the concept might seem inherently tied to specific domains, there's a significant potential for reusability within the event store itself and the surrounding infrastructure.")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Event Schema")]),e._v(":\n"),s("ul",[s("li",[e._v("Generic event structure: Define a base event structure with common properties (e.g., timestamp, event ID, aggregate ID) that can be reused across different event types.")]),e._v(" "),s("li",[e._v("Event metadata: Standardize metadata fields (e.g., correlation ID, causation ID) to facilitate event tracing and correlation.")])])]),e._v(" "),s("li",[s("strong",[e._v("Event Store API")]),e._v(":\n"),s("ul",[s("li",[e._v("Abstraction layer: Create a generic event store API that can interact with different underlying storage technologies (e.g., relational databases, NoSQL, message queues).")]),e._v(" "),s("li",[e._v("Common operations: Implement core operations like append, read, and query in a reusable manner.")])])]),e._v(" "),s("li",[s("strong",[e._v("Event Serialization")]),e._v(":\n"),s("ul",[s("li",[e._v("Flexible serialization formats: Support multiple serialization formats (e.g., JSON, Protobuf) to accommodate different systems and performance requirements.")]),e._v(" "),s("li",[e._v("Schema evolution: Implement strategies for handling schema changes without breaking existing consumers.")])])])]),e._v(" "),s("h3",{attrs:{id:"reusability-in-eda"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reusability-in-eda"}},[e._v("#")]),e._v(" Reusability in EDA")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Event Producers and Consumers")]),e._v(":\n"),s("ul",[s("li",[e._v("Event bus: Create a reusable event bus component to decouple event producers and consumers.")]),e._v(" "),s("li",[e._v("Event publishers and subscribers: Develop generic frameworks for publishing and subscribing to events.")])])]),e._v(" "),s("li",[s("strong",[e._v("Event Processing")]),e._v(":\n"),s("ul",[s("li",[e._v("Event handlers: Design reusable event handlers for common event patterns (e.g., command handlers, projections).")]),e._v(" "),s("li",[e._v("Event sourcing: Implement a generic event sourcing framework that can be applied to different aggregates.")])])]),e._v(" "),s("li",[s("strong",[e._v("Event Projection")]),e._v(":\n"),s("ul",[s("li",[e._v("Projection frameworks: Develop reusable tools for creating read models from event streams.")]),e._v(" "),s("li",[e._v("Materialized views: Provide mechanisms for creating materialized views for performance optimization.")])])])]),e._v(" "),s("h2",{attrs:{id:"frameworks-vs-libraries"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#frameworks-vs-libraries"}},[e._v("#")]),e._v(" Frameworks vs. Libraries")]),e._v(" "),s("p",[e._v("Frameworks and libraries are both essential tools for software development, offering pre-written code to streamline processes. However, they differ significantly in terms of control, structure, and reusability.")]),e._v(" "),s("h3",{attrs:{id:"libraries"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#libraries"}},[e._v("#")]),e._v(" Libraries")]),e._v(" "),s("ul",[s("li",[e._v("Purpose: Provide reusable code for specific tasks.")]),e._v(" "),s("li",[e._v("Control: Developers have full control over how and when to use library functions.")]),e._v(" "),s("li",[e._v("Structure: Typically don't impose a specific project structure.")]),e._v(" "),s("li",[e._v("Reusability: Highly reusable, often across different projects and languages.")]),e._v(" "),s("li",[e._v("Examples: Lodash, jQuery, React Router.")])]),e._v(" "),s("h4",{attrs:{id:"reusability-in-libraries"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reusability-in-libraries"}},[e._v("#")]),e._v(" Reusability in Libraries")]),e._v(" "),s("ul",[s("li",[e._v("Function-level reuse: Individual functions can be imported and used independently.")]),e._v(" "),s("li",[e._v("Code sharing: Libraries often promote code sharing within a project or across projects.")]),e._v(" "),s("li",[e._v("Language independence: Many libraries are language-agnostic, enhancing cross-platform development.")])]),e._v(" "),s("h3",{attrs:{id:"frameworks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#frameworks"}},[e._v("#")]),e._v(" Frameworks")]),e._v(" "),s("ul",[s("li",[e._v("Purpose: Provide a structured foundation for building applications.")]),e._v(" "),s("li",[e._v("Control: Developers adapt their code to fit the framework's structure.")]),e._v(" "),s("li",[e._v("Structure: Impose a specific project structure and workflow.")]),e._v(" "),s("li",[e._v("Reusability: Reusable components and patterns within the framework, but often tied to the framework's ecosystem.")]),e._v(" "),s("li",[e._v("Examples: Angular, React, Django.")])]),e._v(" "),s("h4",{attrs:{id:"reusability-in-frameworks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reusability-in-frameworks"}},[e._v("#")]),e._v(" Reusability in Frameworks")]),e._v(" "),s("ul",[s("li",[e._v("Component-based reusability: Frameworks often encourage component-based architecture, promoting code reuse within the application.")]),e._v(" "),s("li",[e._v("Pattern-based reusability: Frameworks often follow design patterns, providing reusable solutions to common problems.")]),e._v(" "),s("li",[e._v("Ecosystem reusability: Frameworks often have rich ecosystems of third-party libraries and components, expanding reusability options.")])]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Feature")]),e._v(" "),s("th",[e._v("Libraries")]),e._v(" "),s("th",[e._v("Frameworks")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("Scope of Reuse")]),e._v(" "),s("td",[e._v("Wider, often across projects and languages")]),e._v(" "),s("td",[e._v("Primarily within the framework's ecosystem")])]),e._v(" "),s("tr",[s("td",[e._v("Level of Control")]),e._v(" "),s("td",[e._v("Higher, developers choose when and how to use")]),e._v(" "),s("td",[e._v("Lower, developers adapt to the framework's structure")])]),e._v(" "),s("tr",[s("td",[e._v("Dependency")]),e._v(" "),s("td",[e._v("Loose coupling")]),e._v(" "),s("td",[e._v("Tighter coupling to the framework")])])])]),e._v(" "),s("h2",{attrs:{id:"reusability-within-layers"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reusability-within-layers"}},[e._v("#")]),e._v(" Reusability within Layers")]),e._v(" "),s("p",[e._v("A typical application is often structured into layers:")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Presentation Layer")]),e._v(": Handles user interface and interaction.")]),e._v(" "),s("li",[s("strong",[e._v("Business Logic Layer")]),e._v(": Encapsulates core business rules and processes.")]),e._v(" "),s("li",[s("strong",[e._v("Data Access Layer")]),e._v(": Manages interactions with data storage.")])]),e._v(" "),s("h3",{attrs:{id:"presentation-layer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#presentation-layer"}},[e._v("#")]),e._v(" Presentation Layer:")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("UI Components")]),e._v(": Creating reusable UI components like buttons, input fields, and navigation elements can significantly speed up development.")]),e._v(" "),s("li",[s("strong",[e._v("Templates and Layouts")]),e._v(": Reusable templates and layouts can streamline the creation of different pages and screens.")]),e._v(" "),s("li",[s("strong",[e._v("Style Libraries")]),e._v(": Defining a consistent style guide can ensure visual consistency and promote reusability.")])]),e._v(" "),s("h3",{attrs:{id:"business-logic-layer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#business-logic-layer"}},[e._v("#")]),e._v(" Business Logic Layer:")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Domain Models")]),e._v(": Well-defined domain models can be reused across different use cases.")]),e._v(" "),s("li",[s("strong",[e._v("Business Services")]),e._v(": Creating reusable business services that encapsulate specific functionalities can improve code modularity.")]),e._v(" "),s("li",[s("strong",[e._v("Utility Functions")]),e._v(": Developing general-purpose utility functions for tasks like data validation, formatting, or calculations can enhance reusability.")])]),e._v(" "),s("h3",{attrs:{id:"data-access-layer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#data-access-layer"}},[e._v("#")]),e._v(" Data Access Layer:")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Data Access Objects")]),e._v(" (DAOs): Implementing DAOs to abstract database interactions can facilitate swapping data sources.")]),e._v(" "),s("li",[s("strong",[e._v("ORM Frameworks")]),e._v(": Using ORMs can often provide built-in mechanisms for data mapping and query generation.")]),e._v(" "),s("li",[s("strong",[e._v("Caching Strategies")]),e._v(": Implementing caching layers can improve performance and reduce database load.")])])])}),[],!1,null,null,null);t.default=r.exports}}]);