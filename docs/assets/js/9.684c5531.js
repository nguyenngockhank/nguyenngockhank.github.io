(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{564:function(e,t,a){e.exports=a.p+"assets/img/image--052.47116516.jpg"},565:function(e,t,a){e.exports=a.p+"assets/img/image--053.d8ec5d25.jpg"},566:function(e,t,a){e.exports=a.p+"assets/img/image--054.8d7de5ee.jpg"},567:function(e,t,a){e.exports=a.p+"assets/img/image--055.e94b46b1.jpg"},568:function(e,t,a){e.exports=a.p+"assets/img/image--056.a4bb5907.jpg"},569:function(e,t,a){e.exports=a.p+"assets/img/image--057.ed72462c.jpg"},917:function(e,t,a){"use strict";a.r(t);var s=a(7),o=Object(s.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"chapter-13-polyglot-persistence"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#chapter-13-polyglot-persistence"}},[e._v("#")]),e._v(" Chapter 13. Polyglot Persistence")]),e._v(" "),s("p",[e._v("Different databases are designed to solve different problems. Using a single database engine for all of\nthe requirements usually leads to non- performant solutions; storing transactional data, caching\nsession information, traversing graph of customers and the products their friends bought are\nessentially different problems. Even in the RDBMS space, the requirements of an OLAP and OLTP\nsystem are very different—nonetheless, they are often forced into the same schema.")]),e._v(" "),s("p",[e._v("Let’s think of data relationships. RDBMS solutions are good at enforcing that relationships exist. If\nwe want to discover relationships, or have to find data from different tables that belong to the same\nobject, then the use of RDBMS starts being difficult.")]),e._v(" "),s("p",[e._v("Database engines are designed to perform certain operations on certain data structures and data\namounts very well—such as operating on sets of data or a store and retrieving keys and their values\nreally fast, or storing rich documents or complex graphs of information.")]),e._v(" "),s("h2",{attrs:{id:"_13-1-disparate-data-storage-needs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-1-disparate-data-storage-needs"}},[e._v("#")]),e._v(" 13.1. Disparate Data Storage Needs")]),e._v(" "),s("p",[e._v("Many enterprises tend to use the same database engine to store business transactions, session\nmanagement data, and for other storage needs such as reporting, BI, data warehousing, or logging\ninformation (Figure 13.1).")]),e._v(" "),s("p",[s("img",{attrs:{src:a(564),alt:"img"}})]),e._v(" "),s("p",[s("strong",[e._v("Figure 13.1. Use of RDBMS for every aspect of storage for the application")])]),e._v(" "),s("p",[e._v("The session, shopping cart, or order data do not need the same properties of availability,\nconsistency, or backup requirements. Does session management storage need the same rigorous\nbackup/recovery strategy as the e-commerce orders data? Does the session management storage need\nmore availability of an instance of database engine to write/read session data?")]),e._v(" "),s("p",[e._v("In 2006, Neal Ford coined the term "),s("strong",[e._v("polyglot programming")]),e._v(" , to express the idea that applications\nshould be written in a mix of languages to take advantage of the fact that different languages are\nsuitable for tackling different problems. Complex applications combine different types of problems,\nso picking the right language for each job may be more productive than trying to fit all aspects into a single language.")]),e._v(" "),s("p",[e._v("Similarly, when working on an e-commerce business problem, using a data store for the shopping\ncart which is highly available and can scale is important, but the same data store cannot help you find\nproducts bought by the customers’ friends—which is a totally different question. We use the term\n"),s("strong",[e._v("polyglot persistence")]),e._v(" to define this hybrid approach to persistence.")]),e._v(" "),s("h2",{attrs:{id:"_13-2-polyglot-data-store-usage"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-2-polyglot-data-store-usage"}},[e._v("#")]),e._v(" 13.2. Polyglot Data Store Usage")]),e._v(" "),s("p",[e._v("Let’s take our e-commerce example and use the polyglot persistence approach to see how some of\nthese data stores can be applied (Figure 13.2). A key-value data store could be used to store the\nshopping cart data before the order is confirmed by the customer and also store the session data so\nthat the RDBMS is not used for this transient data. Key-value stores make sense here since the\nshopping cart is usually accessed by user ID and, once confirmed and paid by the customer, can be\nsaved in the RDBMS. Similarly, session data is keyed by the session ID.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(565),alt:"img"}})]),e._v(" "),s("p",[s("strong",[e._v("Figure 13.2. Use of key-value stores to offload session and shopping cart data storage")])]),e._v(" "),s("p",[e._v("If we need to recommend products to customers when they place products into their shopping carts\n—for example, “your friends also bought these products” or “your friends bought these accessories\nfor this product”—then introducing a graph data store in the mix becomes relevant (Figure 13.3).")]),e._v(" "),s("p",[s("img",{attrs:{src:a(566),alt:"img"}})]),e._v(" "),s("p",[s("strong",[e._v("Figure 13.3. Example implementation of polyglot persistence")])]),e._v(" "),s("p",[e._v("It is not necessary for the application to use a single data store for all of its needs, since different\ndatabases are built for different purposes and not all problems can be elegantly solved by a singe\ndatabase.")]),e._v(" "),s("p",[e._v("Even using specialized relational databases for different purposes, such as data warehousing\nappliances or analytics appliances within the same application, can be viewed as polyglot\npersistence.")]),e._v(" "),s("h2",{attrs:{id:"_13-3-service-usage-over-direct-data-store-usage"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-3-service-usage-over-direct-data-store-usage"}},[e._v("#")]),e._v(" 13.3. Service Usage over Direct Data Store Usage")]),e._v(" "),s("p",[e._v("As we move towards multiple data stores in the application, there may be other applications in the\nenterprise that could benefit from the use of our data stores or the data stored in them. Using our\nexample, the graph data store can serve data to other applications that need to understand, for\nexample, which products are being bought by a certain segment of the customer base.")]),e._v(" "),s("p",[e._v("Instead of each application talking independently to the graph database, we can wrap the graph\ndatabase into a service so that all relationships between the nodes can be saved in one place and\nqueried by all the applications (Figure 13.4). The data ownership and the APIs provided by the\nservice are more useful than a single application talking to multiple databases.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(567),alt:"img"}})]),e._v(" "),s("p",[s("strong",[e._v("Figure 13.4. Example implementation of wrapping data stores into services")])]),e._v(" "),s("p",[e._v("The philosophy of service wrapping can be taken further: You could wrap all databases into\nservices, letting the application to only talk to a bunch of services (Figure 13.5). This allows for the\ndatabases inside the services to evolve without you having to change the dependent applications.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(568),alt:"img"}})]),e._v(" "),s("p",[s("strong",[e._v("Figure 13.5. Using services instead of talking to databases")])]),e._v(" "),s("p",[e._v("Many NoSQL data store products, such as Riak [Riak] and Neo4J [Neo4J], actually provide out-\nof-the-box REST API’s.")]),e._v(" "),s("h2",{attrs:{id:"_13-4-expanding-for-better-functionality"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-4-expanding-for-better-functionality"}},[e._v("#")]),e._v(" 13.4. Expanding for Better Functionality")]),e._v(" "),s("p",[e._v("Often, we cannot really change the data storage for a specific usage to something different, because of\nthe existing legacy applications and their dependency on existing data storage. We can, however, add\nfunctionality such as caching for better performance, or use indexing engines such as Solr [Solr] so\nthat search can be more efficient (Figure 13.6). When technologies like this are introduced, we have\nto make sure data is synchronized between the data storage for the application and the cache or\nindexing engine.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(569),alt:"img"}})]),e._v(" "),s("p",[s("strong",[e._v("Figure 13.6. Using supplemental storage to enhance legacy storage")])]),e._v(" "),s("p",[e._v("While doing this, we need to update the indexed data as the data in the application database\nchanges. The process of updating the data can be real-time or batch, as long as we ensure that the\napplication can deal with stale data in the index/search engine. The event sourcing (“Event Sourcing,”\np. 142 ) pattern can be used to update the index.")]),e._v(" "),s("h2",{attrs:{id:"_13-5-choosing-the-right-technology"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-5-choosing-the-right-technology"}},[e._v("#")]),e._v(" 13.5. Choosing the Right Technology")]),e._v(" "),s("p",[e._v("There is a rich choice of data storage solutions. Initially, the pendulum had shifted from speciality\ndatabases to a single RDBMS database which allows all types of data models to be stored, although\nwith some abstraction. The trend is now shifting back to using the data storage that supports the\nimplementation of solutions natively.")]),e._v(" "),s("p",[e._v("If we want to recommend products to customers based on what’s in their shopping carts and which\nother products were bought by customers who bought those products, it can be implemented in any of\nthe data stores by persisting the data with the correct attributes to answer our questions. The trick is\nto use the right technology, so that when the questions change, they can still be asked with the same\ndata store without losing existing data or changing it into new formats.")]),e._v(" "),s("p",[e._v("Let’s go back to our new feature need. We can use RDBMS to solve this using a hierarchal query\nand modeling the tables accordingly. When we need to change the traversal, we will have to refactor\nthe database, migrate the data, and start persisting new data. Instead, if we had used a data store that\ntracks relations between nodes, we could have just programmed the new relations and keep using the\nsame data store with minimal changes.")]),e._v(" "),s("h2",{attrs:{id:"_13-6-enterprise-concerns-with-polyglot-persistence"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-6-enterprise-concerns-with-polyglot-persistence"}},[e._v("#")]),e._v(" 13.6. Enterprise Concerns with Polyglot Persistence")]),e._v(" "),s("p",[e._v("Introduction of NoSQL data storage technologies will force the enterprise DBAs to think about how\nto use the new storage. The enterprise is used to having uniform RDBMS environments; whatever is\nthe database an enterprise starts using first, chances are that over the years all its applications will be\nbuilt around the same database. In this new world of polyglot persistence, the DBA groups will have")]),e._v(" "),s("p",[e._v("to become more poly-skilled—to learn how some of these NoSQL technologies work, how to monitor\nthese systems, back them up, and take data out of and put into these systems.")]),e._v(" "),s("p",[e._v("Once the enterprise decides to use any NoSQL technology, issues such as licensing, support, tools,\nupgrades, drivers, auditing, and security come up. Many NoSQL technologies are open-source and\nhave an active community of supporters; also, there are companies that provide commercial support.\nThere is not a rich ecosystem of tools, but the tool vendors and the open-source community are\ncatching up, releasing tools such as MongoDB Monitoring Service [Monitoring], Datastax Ops Center\n[OpsCenter], or Rekon browser for Riak [Rekon].")]),e._v(" "),s("p",[e._v("One other area that enterprises are concerned about is security of the data—the ability to create\nusers and assign privileges to see or not see data at the database level. Most of the NoSQL databases\ndo not have very robust security features, but that’s because they are designed to operate differently.\nIn traditional RDBMS, data was served by the database and we could get to the database using any\nquery tools. With the NoSQL databases, there are query tools as well but the idea is for the\napplication to own the data and serve it using services. With this approach, the responsibility for the\nsecurity lies with the application. Having said that, there are NoSQL technologies that introduce\nsecurity features.")]),e._v(" "),s("p",[e._v("Enterprises often have data warehouse systems, BI, and analytics systems that may need data from\nthe polyglot data sources. Enterprises will have to ensure that the ETL tools or any other mechanism\nthey are using to move data from source systems to the data warehouse can read data from the NoSQL\ndata store. The ETL tool vendors are coming out with have the ability to talk to NoSQL databases; for\nexample, Pentaho [Pentaho] can talk to MongoDB and Cassandra.")]),e._v(" "),s("p",[e._v("Every enterprise runs analytics of some sort. As the sheer volume of data that needs to be captured\nincreases, enterprises are struggling to scale their RDBMS systems to write all this data to the\ndatabases. A huge number of writes and the need to scale for writes are a great use case for NoSQL\ndatabases that allow you to write large volumes of data.")]),e._v(" "),s("h2",{attrs:{id:"_13-7-deployment-complexity"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-7-deployment-complexity"}},[e._v("#")]),e._v(" 13.7. Deployment Complexity")]),e._v(" "),s("p",[e._v("Once we start down the path of using polyglot persistence in the application, "),s("strong",[e._v("deployment complexity")]),e._v("\nneeds careful consideration. The application now needs all databases in production at the same time.\nYou will need to have these databases in your UAT, QA, and Dev environments. As most of the\nNoSQL products are open-source, there are few license cost ramifications. They also support\nautomation of installation and configuration. For example, to install a database, all that needs to be\ndone is download and unzip the archive, which can be automated using curl and unzip commands.\nThese products also have sensible defaults and can be started with minimum configuration.")]),e._v(" "),s("h2",{attrs:{id:"_13-8-key-points"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_13-8-key-points"}},[e._v("#")]),e._v(" 13.8. Key Points")]),e._v(" "),s("ul",[s("li",[e._v("Polyglot persistence is about using different data storage technologies to handle varying data storage needs.")]),e._v(" "),s("li",[e._v("Polyglot persistence can apply across an enterprise or within a single application.")]),e._v(" "),s("li",[e._v("Encapsulating data access into services reduces the impact of data storage choices on other parts of a system.")]),e._v(" "),s("li",[e._v("Adding more data storage technologies increases complexity in programming and operations, so the advantages of a good data storage fit need to be weighed against this complexity.")])])])}),[],!1,null,null,null);t.default=o.exports}}]);