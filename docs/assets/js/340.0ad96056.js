(window.webpackJsonp=window.webpackJsonp||[]).push([[340],{974:function(e,t,a){"use strict";a.r(t);var o=a(7),n=Object(o.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"_8-pull-complexity-downwards"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-pull-complexity-downwards"}},[e._v("#")]),e._v(" 8.  Pull Complexity Downwards")]),e._v(" "),a("p",[e._v("This chapter introduces another way of thinking about how to create\ndeeper classes. Suppose that you are developing a new module, and you\ndiscover a piece of unavoidable complexity. Which is better: should you\nlet users of the module deal with the complexity, or should you handle the\ncomplexity internally within the module? If the complexity is related to\nthe functionality provided by the module, then the second answer is\nusually the right one. Most modules have more users than developers, so it\nis better for the developers to suffer than the users. As a module developer,\nyou should strive to make life as easy as possible for the users of your\nmodule, even if that means extra work for you. Another way of expressing\nthis idea is that it is more important for a module to have a simple\ninterface than a simple implementation.")]),e._v(" "),a("p",[e._v("As a developer, it’s tempting to behave in the opposite fashion: solve\nthe easy problems and punt the hard ones to someone else. If a condition\narises that you’re not certain how to deal with, the easiest thing is to throw\nan exception and let the caller handle it. If you are not certain what policy\nto implement, you can define a few configuration parameters to control the\npolicy and leave it up to the system administrator to figure out the best\nvalues for them.")]),e._v(" "),a("p",[e._v("Approaches like these will make your life easier in the short term, but\nthey amplify complexity, so that many people must deal with a problem,\nrather than just one person. For example, if a class throws an exception,\nevery caller of the class will have to deal with it. If a class exports\nconfiguration parameters, every system administrator in every installation\nwill have to learn how to set them.")]),e._v(" "),a("h2",{attrs:{id:"_8-1-example-editor-text-class"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-example-editor-text-class"}},[e._v("#")]),e._v(" 8.1    Example: editor text class")]),e._v(" "),a("p",[e._v("Consider the class that manages the text of a file for a GUI text editor,\nwhich was discussed in Chapters 6 and 7. The class provides methods to\nread a file from disk into memory, query and modify the in-memory copy\nof the file, and write the modified version back to disk. When students had\nto implement this class, many of them chose a line-oriented interface, with\nmethods to read, insert, and delete whole lines of text. This resulted in a\nsimple implementation for the class, but it created complexity for higher\nlevel software. At the level of the user interface, operations rarely involve\nwhole lines. For example, keystrokes cause individual characters to be\ninserted within an existing line; copying or deleting the selection can\nmodify parts of several different lines. With the line-oriented text\ninterface, higher-level software had to split and join lines in order to\nimplement the user interface.")]),e._v(" "),a("p",[e._v("A character-oriented interface such as the one described in Section 6.3\npulls complexity downward. The user interface software can now insert\nand delete arbitrary ranges of text without splitting and merging lines, so\nit becomes simpler. The implementation of the text class probably\nbecomes more complex: if it represents the text internally as a collection\nof lines, it will have to split and merge lines to implement the character-\noriented operations. This approach is better because it encapsulates the\ncomplexity of splitting and merging within the text class, which reduces\nthe overall complexity of the system.")]),e._v(" "),a("h2",{attrs:{id:"_8-2-example-conguration-parameters"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-example-conguration-parameters"}},[e._v("#")]),e._v(" 8.2    Example: conguration parameters")]),e._v(" "),a("p",[e._v("Configuration parameters are an example of moving complexity upwards\ninstead of down. Rather than determining a particular behavior internally,\na class can export a few parameters that control its behavior, such as the\nsize of a cache or the number of times to retry a request before giving up.\nUsers of the class must then specify appropriate values for the parameters.\nConfiguration parameters have become very popular in systems today;\nsome systems have hundreds of them.")]),e._v(" "),a("p",[e._v("Advocates argue that configuration parameters are good because they\nallow users to tune the system for their particular requirements and")]),e._v(" "),a("p",[e._v("workloads. In some situations it is hard for low-level infrastructure code to\nknow the best policy to apply, whereas users are much more familiar with\ntheir domains. For instance, a user might know that some requests are\nmore time-critical than others, so it makes sense for the user to specify a\nhigher priority for those requests. In situations like this, configuration\nparameters can result in better performance across a broader variety of\ndomains.")]),e._v(" "),a("p",[e._v("However, configuration parameters also provide an easy excuse to\navoid dealing with important issues and pass them on to someone else. In\nmany cases, it’s difficult or impossible for users or administrators to\ndetermine the right values for the parameters. In other cases, the right\nvalues could have been determined automatically with a little extra work\nin the system implementation. Consider a network protocol that must deal\nwith lost packets. If it sends a request but doesn’t receive a response\nwithin a certain time period, it resends the request. One way to determine\nthe retry interval is to introduce a configuration parameter. However, the\ntransport protocol could compute a reasonable value on its own by\nmeasuring the response time for requests that succeed and then using a\nmultiple of this for the retry interval. This approach pulls complexity\ndownward and saves users from having to figure out the right retry\ninterval. It has the additional advantage of computing the retry interval\ndynamically, so it will adjust automatically if operating conditions change.\nIn contrast, configuration parameters can easily become out of date.")]),e._v(" "),a("p",[e._v("Thus, you should avoid configuration parameters as much as possible.\nBefore exporting a configuration parameter, ask yourself: “will users (or\nhigher-level modules) be able to determine a better value than we can\ndetermine here?” When you do create configuration parameters, see if you\ncan compute reasonable defaults automatically, so users will only need to\nprovide values under exceptional conditions. Ideally, each module should\nsolve a problem completely; configuration parameters result in an\nincomplete solution, which adds to system complexity.")]),e._v(" "),a("h2",{attrs:{id:"_8-3-taking-it-too-far"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-taking-it-too-far"}},[e._v("#")]),e._v(" 8.3    Taking it too far")]),e._v(" "),a("p",[e._v("Use discretion when pulling complexity downward; this is an idea that can\neasily be overdone. An extreme approach would be to pull all of the")]),e._v(" "),a("p",[e._v("functionality of the entire application down into a single class, which\nclearly doesn’t make sense. Pulling complexity down makes the most\nsense if (a) the complexity being pulled down is closely related to the\nclass’s existing functionality, (b) pulling the complexity down will result\nin many simplifications elsewhere in the application, and (c) pulling the\ncomplexity down simplifies the class’s interface. Remember that the goal\nis to minimize overall system complexity.")]),e._v(" "),a("p",[e._v("Chapter 6 described how some students defined methods in the text\nclass that reflected the user interface, such as a method that implements\nthe functionality of the backspace key. It might seem that this is good,\nsince it pulls complexity downward. However, adding knowledge of the\nuser interface to the text class doesn’t simplify higher-level code very\nmuch, and the user-interface knowledge doesn’t relate to the core\nfunctions of the text class. In this case, pulling complexity down just\nresulted in information leakage.")]),e._v(" "),a("h2",{attrs:{id:"_8-4-conclusion"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-conclusion"}},[e._v("#")]),e._v(" 8.4    Conclusion")]),e._v(" "),a("p",[e._v("When developing a module, look for opportunities to take a little bit of\nextra suffering upon yourself in order to reduce the suffering of your\nusers.")])])}),[],!1,null,null,null);t.default=n.exports}}]);