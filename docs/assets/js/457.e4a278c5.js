(window.webpackJsonp=window.webpackJsonp||[]).push([[457],{1720:function(e,t,n){"use strict";n.r(t);var o=n(7),a=Object(o.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_16-modifying-existing-code"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_16-modifying-existing-code"}},[e._v("#")]),e._v(" 16. Modifying Existing Code")]),e._v(" "),n("p",[e._v("Chapter 1 described how software development is iterative and\nincremental. A large software system develops through a series of\nevolutionary stages, where each stage adds new capabilities and modifies\nexisting modules. This means that a system’s design is constantly\nevolving. It isn’t possible to conceive the right design for a system at the\noutset; the design of a mature system is determined more by changes made\nduring the system’s evolution than by any initial conception. Previous\nchapters described how to squeeze out complexity during the initial design\nand implementation; this chapter discusses how to keep complexity from\ncreeping in as the system evolves.")]),e._v(" "),n("h2",{attrs:{id:"_16-1-stay-strategic"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_16-1-stay-strategic"}},[e._v("#")]),e._v(" 16.1  Stay strategic")]),e._v(" "),n("p",[e._v("Chapter 3 introduced the distinction between tactical programming and\nstrategic programming: in tactical programming, the primary goal is to get\nsomething working quickly, even if that results in additional complexity;\nin strategic programming, the most important goal is to produce a great\nsystem design. The tactical approach very quickly leads to a messy system\ndesign. If you want to have a system that is easy to maintain and enhance,\nthen “working” isn’t a high enough standard; you have to prioritize design\nand think strategically. This idea also applies when you are modifying\nexisting code.")]),e._v(" "),n("p",[e._v("Unfortunately, when developers go into existing code to make changes\nsuch as bug fixes or new features, they don’t usually think strategically. A\ntypical mindset is “what is the smallest possible change I can make that\ndoes what I need?” Sometimes developers justify this because they are not\ncomfortable with the code being modified; they worry that larger changes")]),e._v(" "),n("p",[e._v("carry a greater risk of introducing new bugs. However, this results in\ntactical programming. Each one of these minimal changes introduces a\nfew special cases, dependencies, or other forms of complexity. As a result,\nthe system design gets just a bit worse, and the problems accumulate with\neach step in the system’s evolution.")]),e._v(" "),n("p",[e._v("If you want to maintain a clean design for a system, you must take a\nstrategic approach when modifying existing code. Ideally, when you have\nfinished with each change, the system will have the structure it would\nhave had if you had designed it from the start with that change in\nmind. To achieve this goal, you must resist the temptation to make a quick\nfix. Instead, think about whether the current system design is still the best\none, in light of the desired change. If not, refactor the system so that you\nend up with the best possible design. With this approach, the system\ndesign improves with every modification.")]),e._v(" "),n("p",[e._v("This is also an example of the investment mindset introduced on page\n15: if you invest a little extra time to refactor and improve the system\ndesign, you’ll end up with a cleaner system. This will speed up\ndevelopment, and you will recoup the effort that you invested in the\nrefactoring. Even if your particular change doesn’t require refactoring, you\nshould still be on the lookout for design imperfections that you can fix\nwhile you’re in the code. Whenever you modify any code, try to find a way\nto improve the system design at least a little bit in the process. If you’re\nnot making the design better, you are probably making it worse.")]),e._v(" "),n("p",[e._v("As discussed in Chapter 3, an investment mindset sometimes conflicts\nwith the realities of commercial software development. If refactoring the\nsystem “the right way” would take three months but a quick and dirty fix\nwould take only two hours, you may have to take the quick and dirty\napproach, particularly if you are working against a tight deadline. Or, if\nrefactoring the system would create incompatibilities that affect many\nother people and teams, then the refactoring may not be practical.")]),e._v(" "),n("p",[e._v("Nonetheless, you should resist these compromises as much as possible.\nAsk yourself “Is this the best I can possibly do to create a clean system\ndesign, given my current constraints?” Perhaps there’s an alternative\napproach that would be almost as clean as the 3-month refactoring but\ncould be done in a couple of days? Or, if you can’t afford to do a large")]),e._v(" "),n("p",[e._v("refactoring now, get your boss to allocate time for you to come back to it\nafter the current deadline. Every development organization should plan to\nspend a small fraction of its total effort on cleanup and refactoring; this\nwork will pay for itself over the long run.")]),e._v(" "),n("h2",{attrs:{id:"_16-2-maintaining-comments-keep-the-comments-near"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_16-2-maintaining-comments-keep-the-comments-near"}},[e._v("#")]),e._v(" 16.2 Maintaining comments: keep the comments near")]),e._v(" "),n("h2",{attrs:{id:"the-code"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#the-code"}},[e._v("#")]),e._v(" the code")]),e._v(" "),n("p",[e._v("When you change existing code, there’s a good chance that the changes\nwill invalidate some of the existing comments. It’s easy to forget to update\ncomments when you modify code, which results in comments that are no\nlonger accurate. Inaccurate comments are frustrating to readers, and if\nthere are very many of them, readers begin to distrust all of the comments.\nFortunately, with a little discipline and a couple of guiding rules, it’s\npossible to keep comments up-to-date without a huge effort. This section\nand the following ones put forth some specific techniques.")]),e._v(" "),n("p",[e._v("The best way to ensure that comments get updated is to position\nthem close to the code they describe, so developers will see them when\nthey change the code. The farther a comment is from its associated code,\nthe less likely it is that it will be updated properly. For example, the best\nplace for a method’s interface comment is in the code file, right next to\nthe body of the method. Any changes to the method will involve this code,\nso the developer is likely to see the interface comments and update them if\nneeded.")]),e._v(" "),n("p",[e._v("An alternative for languages like C and C++ that have separate code\nand header files, is to place the interface comments next to the method’s\ndeclaration in the .h file. However, this is a long way from the code;")]),e._v(" "),n("p",[e._v("developers won’t see those comments when modifying the method’s body,\nand it takes additional work to open a different file and find the interface\ncomments to update them. Some might argue that interface comments\nshould go in header files so that users can learn how to use an abstraction\nwithout having to look at the code file. However, users should not need to\nread either code or header files; they should get their information from\ndocumentation compiled by tools such as Doxygen or Javadoc. In addition,\nmany IDEs will extract and present documentation to users, such as by")]),e._v(" "),n("p",[e._v("displaying a method’s documentation when the method’s name is typed.\nGiven tools such as these, the documentation should be located in the\nplace that is most convenient for developers working on the code.")]),e._v(" "),n("p",[e._v("When writing implementation comments, don’t put all the comments\nfor an entire method at the top of the method. Spread them out, pushing\neach comment down to the narrowest scope that includes all of the code\nreferred to by the comment. For example, if a method has three major\nphases, don’t write one comment at the top of the method that describes all\nof the phases in detail. Instead, write a separate comment for each phase\nand position that comment just above the first line of code in that phase.\nOn the other hand, it can also be helpful to have a comment at the top of a\nmethod’s implementation that describes the overall strategy, like this:\n//  We proceed in three phases:\n//  Phase 1: Find feasible candidates\n//  Phase 2: Assign each candidate a score\n//  Phase 3: Choose the best, and remove it")]),e._v(" "),n("p",[e._v("Additional details can be documented just above the code for each phase.")]),e._v(" "),n("p",[e._v("In general, the farther a comment is from the code it describes, the\nmore abstract it should be (this reduces the likelihood that the comment\nwill be invalidated by code changes).")]),e._v(" "),n("h2",{attrs:{id:"_16-3-comments-belong-in-the-code-not-the-commit-log"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_16-3-comments-belong-in-the-code-not-the-commit-log"}},[e._v("#")]),e._v(" 16.3  Comments belong in the code, not the commit log")]),e._v(" "),n("p",[e._v("A common mistake when modifying code is to put detailed information\nabout the change in the commit message for the source code repository,\nbut then not to document it in the code. Although commit messages can be\nbrowsed in the future by scanning the repository’s log, a developer who\nneeds the information is unlikely to think of scanning the repository log.\nEven if they do scan the log, it will be tedious to find the right log\nmessage.")]),e._v(" "),n("p",[e._v("When writing a commit message, ask yourself whether developers will\nneed to use that information in the future. If so, then document this\ninformation in the code. An example is a commit message describing a\nsubtle problem that motivated a code change. If this isn’t documented in\nthe code, then a developer might come along later and undo the change")]),e._v(" "),n("p",[e._v("without realizing that they have re-created a bug. If you want to include a\ncopy of this information in the commit message as well, that’s fine, but\nthe most important thing is to get it in the code. This illustrates the\nprinciple of placing documentation in the place where developers are most\nlikely to see it; the commit log is rarely that place.")]),e._v(" "),n("h2",{attrs:{id:"_16-4-maintaining-comments-avoid-duplication"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_16-4-maintaining-comments-avoid-duplication"}},[e._v("#")]),e._v(" 16.4  Maintaining comments: avoid duplication")]),e._v(" "),n("p",[e._v("The second technique for keeping comments up to date is to avoid\nduplication. If documentation is duplicated, it is more difficult for\ndevelopers to find and update all of the relevant copies. Instead, try to\ndocument each design decision exactly once. If there are multiple places\nin the code that are affected by a particular decision, don’t repeat the\ndocumentation at each of these points. Instead, find the most obvious\nsingle place to put the documentation. For example, suppose there is tricky\nbehavior related to a variable, which affects several different places where\nthe variable is used. You can document that behavior in the comment next\nto the variable’s declaration. This is a natural place that developers are\nlikely to check if they’re having trouble understanding code that uses the\nvariable.")]),e._v(" "),n("p",[e._v("If there is no “obvious” single place to put a particular piece of\ndocumentation where developers will find it, create a designNotes file as\ndescribed in Section 13.7. Or, pick the best of the available places and put\nthe documentation there. In addition, add short comments in the other\nplaces that refer to the central location: “See the comment in xyz for an\nexplanation of the code below.” If the reference becomes obsolete because\nthe master comment was moved or deleted, this inconsistency will be self-\nevident because developers won’t find the comment at the indicated place;\nthey can use revision control history to find out what happened to the\ncomment and then update the reference. In contrast, if the documentation\nis duplicated and some of the copies don’t get updated, there will be no\nindication to developers that they are using stale information.")]),e._v(" "),n("p",[e._v("Don’t redocument one module’s design decisions in another module.\nFor example, don’t put comments before a method call that explain what\nhappens in the called method. If readers want to know, they should look at\nthe interface comments for the method. Good development tools will")]),e._v(" "),n("p",[e._v("usually provide this information automatically, for example, by displaying\nthe interface comments for a method if you select the method’s name or\nhover the mouse over it. Try to make it easy for developers to find\nappropriate documentation, but don’t do it by repeating the\ndocumentation.")]),e._v(" "),n("p",[e._v("If information is already documented someplace outside your\nprogram, don’t repeat the documentation inside the program; just\nreference the external documentation. For example, if you write a class\nthat implements the HTTP protocol, there’s no need for you to describe the\nHTTP protocol inside your code. There are already numerous sources for\nthis documentation on the Web; just add a short comment to your code\nwith a URL for one of these sources. Another example is features that are\nalready documented in a user manual. Suppose you are writing a program\nthat implements a collection of commands, with one method responsible\nfor implementing each command. If there is a user manual that describes\nthose commands, there’s no need to duplicate this information in the code.\nInstead, include a short note like the following in the interface comment\nfor each command method:\n// Implements the Foo command; see the user manual for details.")]),e._v(" "),n("p",[e._v("It’s important that readers can easily find all the documentation needed to\nunderstand your code, but that doesn’t mean you have to write all of that\ndocumentation.")]),e._v(" "),n("h2",{attrs:{id:"_16-5-maintaining-comments-check-the-dis"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_16-5-maintaining-comments-check-the-dis"}},[e._v("#")]),e._v(" 16.5 Maintaining comments: check the dis")]),e._v(" "),n("p",[e._v("One good way to make sure documentation stays up to date is to take a few\nminutes before committing a change to your revision control system to\nscan over all the changes for that commit; make sure that each change is\nproperly reflected in the documentation. These pre-commit scans will also\ndetect several other problems, such as accidentally leaving debugging code\nin the system or failing to fix TODO items.")]),e._v(" "),n("h2",{attrs:{id:"_16-6-higher-level-comments-are-easier-to-maintain"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_16-6-higher-level-comments-are-easier-to-maintain"}},[e._v("#")]),e._v(" 16.6  Higher-level comments are easier to maintain")]),e._v(" "),n("p",[e._v("One final thought on maintaining documentation: comments are easier to\nmaintain if they are higher-level and more abstract than the code. These")]),e._v(" "),n("p",[e._v("comments do not reflect the details of the code, so they will not be\naffected by minor code changes; only changes in overall behavior will\naffect these comments. Of course, as discussed in Chapter 13, some\ncomments do need to be detailed and precise. But in general, the\ncomments that are most useful (they don’t simply repeat the code) are also\neasiest to maintain.")])])}),[],!1,null,null,null);t.default=a.exports}}]);