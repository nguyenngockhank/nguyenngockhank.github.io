(window.webpackJsonp=window.webpackJsonp||[]).push([[202],{1329:function(e,t,a){"use strict";a.r(t);var s=a(7),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"common-failure-causes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#common-failure-causes"}},[e._v("#")]),e._v(" Common Failure Causes")]),e._v(" "),a("p",[e._v("We say that a system has a failure when it no longer provides a service to its users that meets its specification. A failure is caused by a fault: a failure of an internal component or an external dependency the system depends on. Some faults can be tolerated and have no user-visible impact at all, while others lead to failures.")]),e._v(" "),a("p",[e._v("To build fault-tolerant applications, we first need to have an idea of what can go wrong. In the next few sections, we will explore some of the most common root causes of failures. By the end of it, you will likely wonder how to tolerate all these different types of faults.")]),e._v(" "),a("h2",{attrs:{id:"hardware-faults"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hardware-faults"}},[e._v("#")]),e._v(" Hardware faults")]),e._v(" "),a("p",[e._v("Any physical part of a machine can fail. HDDs, memory modules, power supplies, motherboards, SSDs, NICs, or CPUs, can all stop working for various reasons. In some cases, hardware faults can cause data corruption as well. If that wasn't enough, entire data centers can go down because of power cuts or natural disasters.")]),e._v(" "),a("p",[e._v("As we will discuss later, we can address many of these infrastructure faults with redundancy. You would think that these faults are the main cause for distributed applications failing, but in reality, they often fail for very mundane reasons.")]),e._v(" "),a("h2",{attrs:{id:"incorrect-error-handling"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#incorrect-error-handling"}},[e._v("#")]),e._v(" Incorrect error handling")]),e._v(" "),a("p",[e._v("A study from 2014 of user-reported failures from five popular distributed data stores found that the majority of catastrophic failures were the result of incorrect handling of non-fatal errors.")]),e._v(" "),a("p",[e._v('In most cases, the bugs in the error handling could have been detected with simple tests. For example, some handlers completely ignored errors. Others caught an overly generic exception, like Exception in Java, and aborted the entire process for no good reason. And some other handlers were only partially implemented and even contained "FIXME" and "TODO" comments.')]),e._v(" "),a("p",[e._v("In hindsight, this is perhaps not too surprising, given that error handling tends to be an afterthought. This is the reason the Go language puts so much emphasis on error handling. We will take a closer look at best practices for testing large distributed applications.")]),e._v(" "),a("h2",{attrs:{id:"configuration-changes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#configuration-changes"}},[e._v("#")]),e._v(" Configuration changes")]),e._v(" "),a("p",[e._v("Configuration changes are one of the leading root causes for catastrophic failures. It's not just misconfigurations that cause problems, but also valid configuration changes to enable rarely-used features that no longer work as expected (or never did).")]),e._v(" "),a("p",[e._v("What makes configuration changes particularly dangerous is that their effects can be delayed. If an application reads a configuration value only when it's actually needed, an invalid value might take effect only hours or days after it has changed and thus escape early detection.")]),e._v(" "),a("p",[e._v("This is why configuration changes should be version-controlled, tested, and released just like code changes, and their validation should happen preventively when the change happens. We will discuss safe release practices for code and configuration changes in the context of continuous deployments.")]),e._v(" "),a("h2",{attrs:{id:"single-points-of-failure"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#single-points-of-failure"}},[e._v("#")]),e._v(" Single points of failure")]),e._v(" "),a("p",[e._v("A single point of failure (SPOF) is a component whose failure brings the entire system down with it. In practice, systems can have multiple SPOFs.")]),e._v(" "),a("p",[e._v("Humans make for great SPOFs, and if you put them in a position where they can cause a catastrophic failure on their own, you can bet they eventually will. For example, human failures often happen when someone needs to manually execute a series of operational steps in a specific order without making any mistakes. On the other hand, computers are great at executing instructions, which is why automation should be leveraged whenever possible.")]),e._v(" "),a("p",[e._v("Another common SPOF is DNS. If clients can't resolve the domain name for an application, they won't be able to connect to it. There are many reasons why that can happen, ranging from domain names expiring, to entire root level domains going down.")]),e._v(" "),a("p",[e._v("Similarly, the TLS certificate used by an application for its HTTP endpoints is also a SPOF. If the certificate expires, clients won't be able to open a secure connection with the application.")]),e._v(" "),a("p",[e._v("Ideally, SPOFs should be identified when the system is designed. The best way to detect them is to examine every system component and ask what would happen if it were to fail. Some SPOFs can be architected away, e.g., by introducing redundancy, while others can't. In that case, the only option left is to reduce the SPOF's blast radius, i.e., the damage the SPOF inflicts on the system when it fails. Many of the resiliency patterns we will discuss later reduce the blast radius of failures.")]),e._v(" "),a("h2",{attrs:{id:"network-faults"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#network-faults"}},[e._v("#")]),e._v(" Network faults")]),e._v(" "),a("p",[e._v("When a client sends a request to a server, it expects to receive a response from it a while later. In the best case, it receives the response shortly after sending the request. If that doesn't happen, the client has two options: continue to wait or fail the request with a time-out exception or error.")]),e._v(" "),a("h2",{attrs:{id:"refs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#refs"}},[e._v("#")]),e._v(" Refs")]),e._v(" "),a("p",[e._v("https://blog.bytebytego.com/p/common-failure-causes")])])}),[],!1,null,null,null);t.default=n.exports}}]);