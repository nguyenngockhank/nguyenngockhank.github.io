(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{565:function(e,t,a){"use strict";a.r(t);var s=a(7),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h2",{attrs:{id:"chapter-12-schema-migrations"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#chapter-12-schema-migrations"}},[e._v("#")]),e._v(" Chapter 12. Schema Migrations")]),e._v(" "),a("h3",{attrs:{id:"_12-1-schema-changes"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-1-schema-changes"}},[e._v("#")]),e._v(" 12.1. Schema Changes")]),e._v(" "),a("p",[e._v("The recent trend in discussing NoSQL databases is to highlight their "),a("em",[e._v("schemaless")]),e._v(" nature—it is a\npopular feature that allows developers to concentrate on the domain design without worrying about\nschema changes. It’s especially true with the rise of agile methods [Agile Methods] where responding\nto changing requirements is important.")]),e._v(" "),a("p",[e._v("Discussions, iterations, and feedback loops involving domain experts and product owners are\nimportant to derive the right understanding of the data; these discussions must not be hampered by a\ndatabase’s schema complexity. With NoSQL data stores, changes to the schema can be made with the\nleast amount of friction, improving developer productivity (“The Emergence of NoSQL,” p. 9 ). We\nhave seen that developing and maintaining an application in the brave new world of schemaless\ndatabases requires careful attention to be given to schema migration.")]),e._v(" "),a("h3",{attrs:{id:"_12-2-schema-changes-in-rdbms"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-schema-changes-in-rdbms"}},[e._v("#")]),e._v(" 12.2. Schema Changes in RDBMS")]),e._v(" "),a("p",[e._v("While developing with standard RDBMS technologies, we develop objects, their corresponding\ntables, and their relationships. Consider a simple object model and data model that has Customer,\nOrder, and OrderItems. The ER model would look like Figure 12.1.")]),e._v(" "),a("p",[a("strong",[e._v("Figure 12.1. Data model of an e-commerce system")]),e._v('\nWhile this data model supports the current object model, life is good. The first time there is a\nchange in the object model, such as introducing preferredShippingType on the Customer object,\nwe have to change the object and change the database table, because without changing the table the\napplication will be out of sync with the database. When we get errors like ORA-00942: table or\nview does not exist or ORA-00904: "PREFERRED_SHIPPING_TYPE": invalid identifier,\nwe know we have this problem.')]),e._v(" "),a("p",[e._v("Typically, a database schema migration has been a project in itself. For deployment of the schema\nchanges, database change scripts are developed, using diff techniques, for all the changes in the\ndevelopment database. This approach of creating migration scripts during the deployment/release\ntime is error-prone and does not support agile development methods.")]),e._v(" "),a("p",[a("strong",[e._v("12.2.1. Migrations for Green Field Projects")])]),e._v(" "),a("p",[e._v("Scripting the database schema changes during development is better, since we can store these schema\nchanges along with the data migration scripts in the same script file. These script files should be")]),e._v(" "),a("p",[e._v("named with incrementing sequential numbers which reflect the database versions; for example, the\nfirst change to the database could have script file named as 001_Description_Of_Change.sql.\nScripting changes this way allows for the database migrations to be run preserving the order of\nchanges. Shown in Figure 12.2 is a folder of all the changes done to a database so far.")]),e._v(" "),a("p",[a("strong",[e._v("Figure 12.2. Sequence of migrations applied to a database")]),e._v("\nNow, suppose we need to change the OrderItem table to store the DiscountedPrice and the\nFullPrice of the item. This will need a change to the OrderItem table and will be change number\n007 in our sequence of changes, as shown in Figure 12.3.")]),e._v(" "),a("p",[a("strong",[e._v("Figure 12.3. New change 007_DiscountedPrice.sql applied to the database")]),e._v("\nWe applied a new change to the database. This change’s script has the code for adding a new\ncolumn, renaming the existing column, and migrating the data needed to make the new feature work.\nShown below is the script contained in the change 007_DiscountedPrice.sql:")]),e._v(" "),a("p",[a("strong",[e._v("Click here to view code image")])]),e._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("ALTER")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("TABLE")]),e._v(" orderitem "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("ADD")]),e._v(" discountedprice NUMBER"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("18")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("2")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("UPDATE")]),e._v(" orderitem "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("SET")]),e._v(" discountedprice "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" price"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("ALTER")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("TABLE")]),e._v(" orderitem "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("MODIFY")]),e._v(" discountedprice "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("NOT")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("NULL")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("ALTER")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("TABLE")]),e._v(" orderitem "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RENAME")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("COLUMN")]),e._v(" price "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("TO")]),e._v(" fullprice"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("--//@UNDO")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("ALTER")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("TABLE")]),e._v(" orderitem "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("RENAME")]),e._v(" fullprice "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("TO")]),e._v(" price"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("ALTER")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("TABLE")]),e._v(" orderitem "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("DROP")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("COLUMN")]),e._v(" discountedprice"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("p",[e._v("The change script shows the schema changes to the database as well as the data migrations needed\nto be done. In the example shown, we are using DBDeploy [DBDeploy] as the framework to manage\nthe changes to the database. DBDeploy maintains a table in the database, named ChangeLog, where\nall the changes made to the database are stored. In this table, Change_Number is what tells everyone\nwhich changes have been applied to the database. This Change_Number, which is the database\nversion, is then used to find the corresponding numbered script in the folder and apply the changes")]),e._v(" "),a("p",[e._v("which have not been applied yet. When we write a script with the change number 007 and apply it to\nthe database using DBDeploy, DBDeploy will check the ChangeLog and pick up all the scripts from\nthe folder that have not yet been applied. Figure 12.4 is the screenshot of DBDeploy applying the\nchange to the database.")]),e._v(" "),a("p",[a("strong",[e._v("Figure 12.4. DBDeploy upgrading the database with change number 007")]),e._v("\nThe best way to integrate with the rest of the developers is to use your project’s version control\nrepository to store all these change scripts, so that you can keep track of the version of the software\nand the database in the same place, eliminating possible mismatches between the database and the\napplication. There are many other tools for such upgrades, including Liquibase [Liquibase], MyBatis\nMigrator [MyBatis Migrator], DBMaintain [DBMaintain].")]),e._v(" "),a("p",[a("strong",[e._v("12.2.2. Migrations in Legacy Projects")])]),e._v(" "),a("p",[e._v("Not every project is a green field. How to implement migrations when an existing application is in\nproduction? We found that taking an existing database and extracting its structure into scripts, along\nwith all the database code and any reference data, works as a baseline for the project. This baseline\nshould not contain transactional data. Once the baseline is ready, further changes can be done using\nthe migrations technique described above (Figure 12.5).")]),e._v(" "),a("p",[a("strong",[e._v("Figure 12.5. Use of baseline scripts with a legacy database")]),e._v("\nOne of the main aspects of migrations should be maintaining backward compatibility of the\ndatabase schema. In many enterprises there are multiple applications using the database; when we\nchange the database for one application, this change should not break other applications. We can\nachieve backward compatibility by maintaining a transition phase for the change, as described in\ndetail in "),a("em",[e._v("Refactoring Databases")]),e._v(" [Ambler and Sadalage].")]),e._v(" "),a("p",[e._v("During a "),a("strong",[e._v("transition phase")]),e._v(" , the old schema and the new schema are maintained in parallel and are\navailable for all the applications using the database. For this, we have to introduce scaffolding code,\nsuch as triggers, views, and virtual columns ensuring other applications can access the database\nschema and the data they require without any code changes.")]),e._v(" "),a("p",[a("strong",[e._v("Click here to view code image")])]),e._v(" "),a("div",{staticClass:"language-sql extra-class"},[a("pre",{pre:!0,attrs:{class:"language-sql"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("ALTER")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("TABLE")]),e._v(" customer \n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("ADD")]),e._v(" fullname VARCHAR2"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("60")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("UPDATE")]),e._v(" customer "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("SET")]),e._v(" fullname "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" fname"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("CREATE")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("OR")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("REPLACE")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("TRIGGER")]),e._v(" SyncCustomerFullName\nBEFORE "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("INSERT")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("OR")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("UPDATE")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("ON")]),e._v(" customer\nREFERENCING OLD "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("AS")]),e._v(" OLD NEW "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("AS")]),e._v(" NEW\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("FOR EACH ROW")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("BEGIN")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("IF")]),e._v(" :NEW"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("fname "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("IS")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("NULL")]),e._v(" \n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("THEN")]),e._v(" :NEW"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("fname :"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" :NEW"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("fullname"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("END")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("IF")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("IF")]),e._v(" :NEW"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("fullname "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("IS")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("NULL")]),e._v(" \n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("THEN")]),e._v(" :NEW"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("fullname :"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" :NEW"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("fname\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("END")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("IF")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("END")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("/")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("--Drop Trigger and fname")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("--when all applications start using customer.fullname")]),e._v("\n")])])]),a("p",[e._v("In the example, we are trying to rename the customer.fname column to customer.fullname as\nwe want to avoid any ambiguity of fname meaning either fullname or firstname. A direct rename\nof the fname column and changing the application code we are responsible for may just work, for our\napplication—but will not for the other applications in the enterprise that are accessing the same\ndatabase.")]),e._v(" "),a("p",[e._v("Using the transition phase technique, we introduce the new column fullname, copy the data over to\nfullname, but leave the old column fname around. We also introduce a BEFORE UPDATE trigger to\nsynchronize data between the columns before they are committed to the database.")]),e._v(" "),a("p",[e._v("Now, when applications read data from the table, they will read either from fname or from\nfullname but will always get the right data. We can drop the trigger and the fname column once all\nthe applications have moved on to using the new fullname column.")]),e._v(" "),a("p",[e._v("It’s very hard to do schema migrations on large datasets in RDBMS, especially if we have to keep\nthe database available to the applications, as large data movements and structural changes usually\ncreate locks on the database tables.")]),e._v(" "),a("h3",{attrs:{id:"_12-3-schema-changes-in-a-nosql-data-store"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-schema-changes-in-a-nosql-data-store"}},[e._v("#")]),e._v(" 12.3. Schema Changes in a NoSQL Data Store")]),e._v(" "),a("p",[e._v("An RDBMS database has to be changed before the application is changed. This is what the "),a("em",[e._v("schema-\nfree")]),e._v(" , or "),a("em",[e._v("schemaless")]),e._v(" , approach tries to avoid, aiming at flexibility of schema changes per entity.\nFrequent changes to the schema are needed to react to frequent market changes and product\ninnovations.")]),e._v(" "),a("p",[e._v("When developing with NoSQL databases, in some cases the schema does not have to be thought\nabout beforehand. We still have to design and think about other aspects, such as the types of\nrelationships (with graph databases), or the names of the column families, rows, columns, order of\ncolumns (with column databases), or how are the keys assigned and what is the structure of the data\ninside the value object (with key-value stores). Even if we didn’t think about these up front, or if we\nwant to change our decisions, it is easy to do so.")]),e._v(" "),a("p",[e._v("The claim that NoSQL databases are entirely schemaless is misleading; while they store the data\nwithout regard to the schema the data adheres to, that schema has to be defined by the application,\nbecause the data stream has to be parsed by the application when reading the data from the database.\nAlso, the application has to create the data that would be saved in the database. If the application\ncannot parse the data from the database, we have a schema mismatch even if, instead of the RDBMS\ndatabase throwing a error, this error is now encountered by the application. Thus, even in schemaless\ndatabases, the schema of the data has to be taken into consideration when refactoring the application.")]),e._v(" "),a("p",[e._v("Schema changes especially matter when there is a deployed application and existing production\ndata. For the sake of simplicity, assume we are using a document data store like MongoDB\n[MongoDB] and we have the same data model as before: customer, order, and orderItems.")]),e._v(" "),a("p",[a("strong",[e._v("Click here to view code image")])]),e._v(" "),a("div",{staticClass:"language-json extra-class"},[a("pre",{pre:!0,attrs:{class:"language-json"}},[a("code",[a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"_id"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"4BD8AE97C47016442AF4A580"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"customerid"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("99999")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"name"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Foo Sushi Inc"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"since"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"12/12/2012"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"order"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"orderid"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"4821-UXWE-122012"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"orderdate"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"12/12/2001"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"orderItems"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("\n            "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"product"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Fortune Cookies"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),a("span",{pre:!0,attrs:{class:"token property"}},[e._v('"price"')]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("19.99")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("Application code to write this document structure to MongoDB:\n"),a("strong",[e._v("Click here to view code image")])]),e._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("BasicDBObject")]),e._v(" orderItem "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("BasicDBObject")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\norderItem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("put")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"product"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" productName"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\norderItem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("put")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"price"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" price"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\norderItems"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("add")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("orderItem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("p",[e._v("Code to read the document back from the database:")]),e._v(" "),a("p",[a("strong",[e._v("Click here to view code image")])]),e._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("BasicDBObject")]),e._v(" item "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("BasicDBObject")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" orderItem"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("String")]),e._v(" productName "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" item"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("getString")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"product"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Double")]),e._v(" price "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" item"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("getDouble")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"price"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("p",[e._v("Changing the objects to add preferredShippingType does not require any change in the database,\nas the database does not care that different documents do not follow the same schema. This allows for\nfaster development and easy deployments. All that needs to be deployed is the application—no\nchanges on the database side are needed. The code has to make sure that documents that do not have\nthe preferredShippingType attribute can still be parsed—and that’s all.")]),e._v(" "),a("p",[e._v("Of course we are simplifying the schema change situation here. Let’s look at the schema change we\nmade before: introducing discountedPrice and renaming price to fullPrice. To make this change,\nwe rename the price attribute to fullPrice and add discountedPrice attribute. The changed\ndocument is")]),e._v(" "),a("p",[a("strong",[e._v("Click here to view code image")])]),e._v(" "),a("p",[e._v('{\n"_id": "5BD8AE97C47016442AF4A580",\n"customerid": 66778,\n"name": "India House",\n"since": "12/12/2012",\n"order": {\n"orderid": "4821-UXWE-222012",\n"orderdate": "12/12/2001",\n"orderItems": [{"product": "Chair Covers",\n"fullPrice": 29.99,\n"discountedPrice":26.99}]\n}\n}')]),e._v(" "),a("p",[e._v("Once we deploy this change, new customers and their orders can be saved and read back without\nproblems, but for existing orders the price of their product cannot be read, because now the code is\nlooking for fullPrice but the document has only price.")]),e._v(" "),a("p",[a("strong",[e._v("12.3.1. Incremental Migration")])]),e._v(" "),a("p",[e._v("Schema mismatch trips many new converts to the NoSQL world. When schema is changed on the\napplication, we have to make sure to convert all the existing data to the new schema (depending on\ndata size, this might be an expensive operation). Another option would be to make sure that data,\nbefore the schema changed, can still be parsed by the new code, and when it’s saved, it is saved back\nin the new schema. This technique, known as "),a("strong",[e._v("incremental migration")]),e._v(" , will migrate data over time;\nsome data may never get migrated, because it was never accessed. We are reading both price and\nfullPrice from the document:")]),e._v(" "),a("p",[a("strong",[e._v("Click here to view code image")])]),e._v(" "),a("p",[e._v('BasicDBObject item = (BasicDBObject) orderItem;\nString productName = item.getString("product");')]),e._v(" "),a("p",[e._v('Double fullPrice = item.getDouble("price");\nif (fullPrice == null) {\nfullPrice = item.getDouble("fullPrice");\n}\nDouble discountedPrice = item.getDouble("discountedPrice");')]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("When writing the document back, the old attribute price is not saved:\n")])])]),a("p",[a("strong",[e._v("Click here to view code image")])]),e._v(" "),a("p",[e._v('BasicDBObject orderItem = new BasicDBObject();\norderItem.put("product", productName);\norderItem.put("fullPrice", price);\norderItem.put("discountedPrice", discountedPrice);\norderItems.add(orderItem);')]),e._v(" "),a("p",[e._v("When using incremental migration, there could be many versions of the object on the application\nside that can translate the old schema to the new schema; while saving the object back, it is saved\nusing the new object. This gradual migration of the data helps the application evolve faster.")]),e._v(" "),a("p",[e._v("The incremental migration technique will complicate the object design, especially as new changes\nare being introduced yet old changes are not being taken out. This period between the change\ndeployment and the last object in the database migrating to the new schema is known as the transition\nperiod (Figure 12.6). Keep it as short as possible and focus it to the minimum possible scope—this\nwill help you keep your objects clean.")]),e._v(" "),a("p",[a("strong",[e._v("Figure 12.6. Transition period of schema changes")]),e._v("\nThe incremental migration technique can also be implemented with a schema_version field on the\ndata, used by the application to choose the correct code to parse the data into the objects. When\nsaving, the data is migrated to the latest version and the schema_version is updated to reflect that.")]),e._v(" "),a("p",[e._v("Having a proper translation layer between your domain and the database is important so that, as the\nschema changes, managing multiple versions of the schema is restricted to the translation layer and\ndoes not leak into the whole application.")]),e._v(" "),a("p",[e._v("Mobile apps create special requirements. Since we cannot enforce the latest upgrades of the\napplication, the application should be able to handle almost all versions of the schema.")]),e._v(" "),a("p",[a("strong",[e._v("12.3.2. Migrations in Graph Databases")])]),e._v(" "),a("p",[e._v("Graph databases have edges that have types and properties. If you change the type of these edges in\nthe codebase, you no longer can traverse the database, rendering it unusable. To get around this, you\ncan traverse all the edges and change the type of each edge. This operation can be expensive and\nrequires you to write code to migrate all the edges in the database.")]),e._v(" "),a("p",[e._v("If we need to maintain backward compatibility or do not want to change the whole graph in one go,\nwe can just create new edges between the nodes; later when we are comfortable about the change, the\nold edges can be dropped. We can use traversals with multiple edge types to traverse the graph using\nthe new and old edge types. This technique may help a great deal with large databases, especially if\nwe want to maintain high availability.")]),e._v(" "),a("p",[e._v("If we have to change properties on all the nodes or edges, we have to fetch all the nodes and\nchange all the properties that need to be changed. An example would be adding NodeCreatedBy and\nNodeCreatedOn to all existing nodes to track the changes being made to each node.")]),e._v(" "),a("p",[a("strong",[e._v("Click here to view code image")])]),e._v(" "),a("p",[e._v('for (Node node : database.getAllNodes()) {\nnode.setProperty("NodeCreatedBy", getSystemUser());\nnode.setProperty("NodeCreatedOn", getSystemTimeStamp());\n}')]),e._v(" "),a("p",[e._v("We may have to change the data in the nodes. New data may be derived from the existing node\ndata, or it could be imported from some other source. The migration can be done by fetching all nodes\nusing an index provided by the source of data and writing relevant data to each node.")]),e._v(" "),a("p",[a("strong",[e._v("12.3.3. Changing Aggregate Structure")])]),e._v(" "),a("p",[e._v("Sometimes you need to change the schema design, for example by splitting large objects into smaller\nones that are stored independently. Suppose you have a customer aggregate that contains all the\ncustomers orders, and you want to separate the customer and each of their orders into different\naggregate units.")]),e._v(" "),a("p",[e._v("You then have to ensure that the code can work with both versions of the aggregates. If it does not\nfind the old objects, it will look for the new aggregates.")]),e._v(" "),a("p",[e._v("Code that runs in the background can read one aggregate at a time, make the necessary change, and\nsave the data back into different aggregates. The advantage of operating on one aggregate at a time is\nthat this way, you’re not affecting data availability for the application.")]),e._v(" "),a("h3",{attrs:{id:"_12-4-further-reading"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-4-further-reading"}},[e._v("#")]),e._v(" 12.4. Further Reading")]),e._v(" "),a("p",[e._v("For more on migrations with relational databases, see [Ambler and Sadalage]. Although much of this\ncontent is specific to relational work, the general principles in migration will also apply to other\ndatabases.")]),e._v(" "),a("h3",{attrs:{id:"_12-5-key-points"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-5-key-points"}},[e._v("#")]),e._v(" 12.5. Key Points")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("Databases with strong schemas, such as relational databases, can be migrated by saving each\nschema change, plus its data migration, in a version-controlled sequence.")])]),e._v(" "),a("li",[a("p",[e._v("Schemaless databases still need careful migration due to the implicit schema in any code that\naccesses the data.")])]),e._v(" "),a("li",[a("p",[e._v("Schemaless databases can use the same migration techniques as databases with strong schemas.")])]),e._v(" "),a("li",[a("p",[e._v("Schemaless databases can also read data in a way that’s tolerant to changes in the data’s\nimplicit schema and use incremental migration to update data.")])])])])}),[],!1,null,null,null);t.default=n.exports}}]);