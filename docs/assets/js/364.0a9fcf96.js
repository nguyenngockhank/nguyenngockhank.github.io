(window.webpackJsonp=window.webpackJsonp||[]).push([[364],{1016:function(e,t,n){"use strict";n.r(t);var s=n(7),a=Object(s.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_19-software-trends"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_19-software-trends"}},[e._v("#")]),e._v(" 19. Software Trends")]),e._v(" "),n("p",[e._v("As a way of illustrating the principles discussed in this book, this chapter\nconsiders several trends and patterns that have become popular in software\ndevelopment over the last few decades. For each trend, I will describe how\nthat trend relates to the principles in this book and use the principles to\nevaluate whether that trend provides leverage against software complexity.")]),e._v(" "),n("h2",{attrs:{id:"_19-1-object-oriented-programming-and-inheritance"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_19-1-object-oriented-programming-and-inheritance"}},[e._v("#")]),e._v(" 19.1  Object-oriented programming and inheritance")]),e._v(" "),n("p",[e._v("Object-oriented programming is one of the most important new ideas in\nsoftware development over the last 30–40 years. It introduced notions such\nas classes, inheritance, private methods, and instance variables. If used\ncarefully, these mechanisms can help to produce better software designs.\nFor example, private methods and variables can be used to ensure\ninformation hiding: no code outside a class can invoke private methods or\naccess private variables, so there can’t be any external dependencies on\nthem.")]),e._v(" "),n("p",[e._v("One of the key elements of object-oriented programming is\ninheritance. Inheritance comes in two forms, which have different\nimplications for software complexity. The first form of inheritance is\ninterface inheritance, in which a parent class defines the signatures for one\nor more methods, but does not implement the methods. Each subclass\nmust implement the signatures, but different subclasses can implement the\nsame methods in different ways. For example, the interface might define\nmethods for performing I/O; one subclass might implement the I/O\noperations for disk files, and another subclass might implement the same\noperations for network sockets.")]),e._v(" "),n("p",[e._v("Interface inheritance provides leverage against complexity by reusing\nthe same interface for multiple purposes. It allows knowledge acquired in\nsolving one problem (such as how to use an I/O interface to read and write\ndisk files) to be used to solve other problems (such as communicating over\na network socket). Another way of thinking about this is in terms of depth:\nthe more different implementations there are of an interface, the deeper\nthe interface becomes. In order for an interface to have many\nimplementations, it must capture the essential features of all the\nunderlying implementations while steering clear of the details that differ\nbetween the implementations; this notion is at the heart of abstraction.")]),e._v(" "),n("p",[e._v("The second form of inheritance is implementation inheritance. In this\nform, a parent class defines not only signatures for one or more methods,\nbut also default implementations. Subclasses can choose to inherit the\nparent’s implementation of a method or override it by defining a new\nmethod with the same signature. Without implementation inheritance, the\nsame method implementation might need to be duplicated in several\nsubclasses, which would create dependencies between those subclasses\n(modifications would need to be duplicated in all copies of the method).\nThus, implementation inheritance reduces the amount of code that needs\nto be modified as the system evolves; in other words, it reduces the change\namplification problem described in Chapter 2.")]),e._v(" "),n("p",[e._v("However, implementation inheritance creates dependencies between\nthe parent class and each of its subclasses. Class instance variables in the\nparent class are often accessed by both the parent and child classes; this\nresults in information leakage between the classes in the inheritance\nhierarchy and makes it hard to modify one class in the hierarchy without\nlooking at the others. For example, a developer making changes to the\nparent class may need to examine all of the subclasses to ensure that the\nchanges don’t break anything. Similarly, if a subclass overrides a method\nin the parent class, the developer of the subclass may need to examine the\nimplementation in the parent. In the worst case, programmers will need\ncomplete knowledge of the entire class hierarchy underneath the parent\nclass in order to make changes to any of the classes. Class hierarchies that\nuse implementation inheritance extensively tend to have high complexity.")]),e._v(" "),n("p",[e._v("Thus, implementation inheritance should be used with caution. Before\nusing implementation inheritance, consider whether an approach based on\ncomposition can provide the same benefits. For instance, it may be\npossible to use small helper classes to implement the shared functionality.\nRather than inheriting functions from a parent, the original classes can\neach build upon the features of the helper classes.")]),e._v(" "),n("p",[e._v("If there is no viable alternative to implementation inheritance, try to\nseparate the state managed by the parent class from that managed by\nsubclasses. One way to do this is for certain instance variables to be\nmanaged entirely by methods in the parent class, with subclasses using\nthem only in a read-only fashion or through other methods in the parent\nclass. This applies the notion of information hiding within the class\nhierarchy to reduce dependencies.")]),e._v(" "),n("p",[e._v("Although the mechanisms provided by object-oriented programming\ncan assist in implementing clean designs, they do not, by themselves,\nguarantee good design. For example, if classes are shallow, or have\ncomplex interfaces, or permit external access to their internal state, then\nthey will still result in high complexity.")]),e._v(" "),n("h2",{attrs:{id:"_19-2-agile-development"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_19-2-agile-development"}},[e._v("#")]),e._v(" 19.2  Agile development")]),e._v(" "),n("p",[e._v("Agile development is an approach to software development that emerged\nin the late 1990’s from a collection of ideas about how to make software\ndevelopment more lightweight, flexible, and incremental; it was formally\ndefined during a meeting of practitioners in 2001. Agile development is\nmostly about the process of software development (organizing teams,\nmanaging schedules, the role of unit testing, interacting with customers,\netc.) as opposed to software design. Nonetheless, it relates to some of the\ndesign principles in this book.")]),e._v(" "),n("p",[e._v("One of the most important elements of agile development is the notion\nthat development should be incremental and iterative. In the agile\napproach, a software system is developed in a series of iterations, each of\nwhich adds and evaluates a few new features; each iteration includes\ndesign, test, and customer input. In general, this is similar to the\nincremental approach advocated here. As mentioned in Chapter 1, it isn’t")]),e._v(" "),n("p",[e._v("possible to visualize a complex system well enough at the outset of a\nproject to determine the best design. The best way to end up with a good\ndesign is to develop a system in increments, where each increment adds a\nfew new abstractions and refactors existing abstractions based on\nexperience. This is similar to the agile development approach.")]),e._v(" "),n("p",[e._v("One of the risks of agile development is that it can lead to tactical\nprogramming. Agile development tends to focus developers on features,\nnot abstractions, and it encourages developers to put off design decisions\nin order to produce working software as soon as possible. For example,\nsome agile practitioners argue that you shouldn’t implement general-\npurpose mechanisms right away; implement a minimal special-purpose\nmechanism to start with, and refactor into something more generic later,\nonce you know that it’s needed. Although these arguments make sense to a\ndegree, they argue against an investment approach, and they encourage a\nmore tactical style of programming. This can result in a rapid\naccumulation of complexity.")]),e._v(" "),n("p",[e._v("Developing incrementally is generally a good idea, but the increments\nof development should be abstractions, not features. It’s fine to put off\nall thoughts about a particular abstraction until it’s needed by a feature.\nOnce you need the abstraction, invest the time to design it cleanly; follow\nthe advice of Chapter 6 and make it somewhat general-purpose.")]),e._v(" "),n("h2",{attrs:{id:"_19-3-unit-tests"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_19-3-unit-tests"}},[e._v("#")]),e._v(" 19.3  Unit tests")]),e._v(" "),n("p",[e._v("It used to be that developers rarely wrote tests. If tests were written at all,\nthey were written by a separate QA team. However, one of the tenets of\nagile development is that testing should be tightly integrated with\ndevelopment, and programmers should write tests for their own code. This\npractice has now become widespread. Tests are typically divided into two\nkinds: unit tests and system tests. Unit tests are the ones most often\nwritten by developers. They are small and focused: each test usually\nvalidates a small section of code in a single method. Unit tests can be run\nin isolation, without setting up a production environment for the system.\nUnit tests are often run in conjunction with a test coverage tool to ensure\nthat every line of code in the application is tested. Whenever developers")]),e._v(" "),n("p",[e._v("write new code or modify existing code, they are responsible for updating\nthe unit tests to maintain proper test coverage.")]),e._v(" "),n("p",[e._v("The second kind of test consists of system tests (sometimes called\nintegration tests), which ensure that the different parts of an application all\nwork together properly. They typically involve running the entire\napplication in a production environment. System tests are more likely to\nbe written by a separate QA or testing team.")]),e._v(" "),n("p",[e._v("Tests, particularly unit tests, play an important role in software design\nbecause they facilitate refactoring. Without a test suite, it’s dangerous to\nmake major structural changes to a system. There’s no easy way to find\nbugs, so it’s likely that bugs will go undetected until the new code is\ndeployed, where they are much more expensive to find and fix. As a result,\ndevelopers avoid refactoring in systems without good test suites; they try\nto minimize the number of code changes for each new feature or bug fix,\nwhich means that complexity accumulates and design mistakes don’t get\ncorrected.")]),e._v(" "),n("p",[e._v("With a good set of tests, developers can be more confident when\nrefactoring because the test suite will find most bugs that are introduced.\nThis encourages developers to make structural improvements to a system,\nwhich results in a better design. Unit tests are particularly valuable: they\nprovide a higher degree of code coverage than system tests, so they are\nmore likely to uncover any bugs.")]),e._v(" "),n("p",[e._v("For example, during the development of the Tcl scripting language, we\ndecided to improve performance by replacing Tcl’s interpreter with a byte-\ncode compiler. This was a huge change that affected almost every part of\nthe core Tcl engine. Fortunately, Tcl had an excellent unit test suite, which\nwe ran on the new byte-code engine. The existing tests were so effective in\nuncovering bugs in the new engine that only a single bug turned up after\nthe alpha release of the byte-code compiler.")]),e._v(" "),n("h2",{attrs:{id:"_19-4-test-driven-development"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_19-4-test-driven-development"}},[e._v("#")]),e._v(" 19.4  Test-driven development")]),e._v(" "),n("p",[e._v("Test-driven development is an approach to software development where\nprogrammers write unit tests before they write code. When creating a new\nclass, the developer first writes unit tests for the class, based on its")]),e._v(" "),n("p",[e._v("expected behavior. None of the tests pass, since there is no code for the\nclass. Then the developer works through the tests one at a time, writing\nenough code for that test to pass. When all of the tests pass, the class is\nfinished.")]),e._v(" "),n("p",[e._v("Although I am a strong advocate of unit testing, I am not a fan of test-\ndriven development. The problem with test-driven development is that\nit focuses attention on getting specific features working, rather than\nfinding the best design. This is tactical programming pure and simple,\nwith all of its disadvantages. Test-driven development is too incremental:\nat any point in time, it’s tempting to just hack in the next feature to make\nthe next test pass. There’s no obvious time to do design, so it’s easy to end\nup with a mess.")]),e._v(" "),n("p",[e._v("As mentioned in Section 19.2, the units of development should be\nabstractions, not features. Once you discover the need for an abstraction,\ndon’t create the abstraction in pieces over time; design it all at once (or at\nleast enough to provide a reasonably comprehensive set of core functions).\nThis is more likely to produce a clean design whose pieces fit together\nwell.")]),e._v(" "),n("p",[e._v("One place where it makes sense to write the tests first is when fixing\nbugs. Before fixing a bug, write a unit test that fails because of the bug.\nThen fix the bug and make sure that the unit test now passes. This is the\nbest way to make sure you really have fixed the bug. If you fix the bug\nbefore writing the test, it’s possible that the new unit test doesn’t actually\ntrigger the bug, in which case it won’t tell you whether you really fixed the\nproblem.")]),e._v(" "),n("h2",{attrs:{id:"_19-5-design-patterns"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_19-5-design-patterns"}},[e._v("#")]),e._v(" 19.5 Design patterns")]),e._v(" "),n("p",[e._v("A design pattern is a commonly used approach for solving a particular\nkind of problem, such as an iterator or an observer. The notion of design\npatterns was popularized by the book Design Patterns: Elements of\nReusable Object-Oriented Software by Gamma, Helm, Johnson, and\nVlissides, and design patterns are now widely used in object-oriented\nsoftware development.")]),e._v(" "),n("p",[e._v("Design patterns represent an alternative to design: rather than\ndesigning a new mechanism from scratch, just apply a well-known design\npattern. For the most part, this is good: design patterns arose because they\nsolve common problems, and because they are generally agreed to provide\nclean solutions. If a design pattern works well in a particular situation, it\nwill probably be hard for you to come up with a different approach that is\nbetter.")]),e._v(" "),n("p",[e._v("The greatest risk with design patterns is over-application. Not every\nproblem can be solved cleanly with an existing design pattern; don’t try to\nforce a problem into a design pattern when a custom approach will be\ncleaner. Using design patterns doesn’t automatically improve a software\nsystem; it only does so if the design patterns fit. As with many ideas in\nsoftware design, the notion that design patterns are good doesn’t\nnecessarily mean that more design patterns are better.")]),e._v(" "),n("h2",{attrs:{id:"_19-6-getters-and-setters"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_19-6-getters-and-setters"}},[e._v("#")]),e._v(" 19.6  Getters and setters")]),e._v(" "),n("p",[e._v("In the Java programming community, getter and setter methods are a\npopular design pattern. A getter and a setter are associated with an\ninstance variable for a class. They have names like getFoo and setFoo,")]),e._v(" "),n("p",[e._v("where Foo is the name of the variable. The getter method returns the\ncurrent value of the variable, and the setter method modifies the value.")]),e._v(" "),n("p",[e._v("Getters and setters aren’t strictly necessary, since instance variables\ncan be made public. The argument for getters and setters is that they allow\nadditional functions to be performed while getting and setting, such as\nupdating related values when a variable changes, notifying listeners of\nchanges, or enforcing constraints on values. Even if these features aren’t\nneeded initially, they can be added later without changing the interface.")]),e._v(" "),n("p",[e._v("Although it may make sense to use getters and setters if you must\nexpose instance variables, it’s better not to expose instance variables in the\nfirst place. Exposed instance variables mean that part of the class’s\nimplementation is visible externally, which violates the idea of\ninformation hiding and increases the complexity of the class’s interface.\nGetters and setters are shallow methods (typically only a single line), so\nthey add clutter to the class’s interface without providing much")]),e._v(" "),n("p",[e._v("functionality. It’s better to avoid getters and setters (or any exposure of\nimplementation data) as much as possible.")]),e._v(" "),n("p",[e._v("One of the risks of establishing a design pattern is that developers\nassume the pattern is good and try to use it as much as possible. This has\nled to overusage of getters and setters in Java.")]),e._v(" "),n("h2",{attrs:{id:"_19-7-conclusion"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_19-7-conclusion"}},[e._v("#")]),e._v(" 19.7  Conclusion")]),e._v(" "),n("p",[e._v("Whenever you encounter a proposal for a new software development\nparadigm, challenge it from the standpoint of complexity: does the\nproposal really help to minimize complexity in large software systems?\nMany proposals sound good on the surface, but if you look more deeply\nyou will see that some of them make complexity worse, not better.")])])}),[],!1,null,null,null);t.default=a.exports}}]);