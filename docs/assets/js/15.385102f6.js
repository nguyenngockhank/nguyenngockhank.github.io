(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{589:function(e,t,a){e.exports=a.p+"assets/img/image--004.019ede3e.jpg"},590:function(e,t,a){e.exports=a.p+"assets/img/image--005.b90151cf.jpg"},591:function(e,t,a){e.exports=a.p+"assets/img/image--006.9c6c95b6.jpg"},592:function(e,t,a){e.exports=a.p+"assets/img/image--007.8a14ae1d.jpg"},593:function(e,t,a){e.exports=a.p+"assets/img/image--008.d87c5e12.jpg"},942:function(e,t,a){"use strict";a.r(t);var s=a(7),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"chapter-2-aggregate-data-models"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#chapter-2-aggregate-data-models"}},[e._v("#")]),e._v(" Chapter 2. Aggregate Data Models")]),e._v(" "),s("p",[e._v("A data model is the model through which we perceive and manipulate our data. For people using a\ndatabase, the data model describes how we interact with the data in the database. This is distinct\nfrom a storage model, which describes how the database stores and manipulates the data internally. In\nan ideal world, we should be ignorant of the storage model, but in practice we need at least some\ninkling of it—primarily to achieve decent performance.")]),e._v(" "),s("p",[e._v("In conversation, the term “data model” often means the model of the specific data in an application.\nA developer might point to an entity-relationship diagram of their database and refer to that as their\ndata model containing customers, orders, products, and the like. However, in this book we’ll mostly\nbe using “data model” to refer to the model by which the database organizes data—what might be\nmore formally called a metamodel.")]),e._v(" "),s("p",[e._v("The dominant data model of the last couple of decades is the relational data model, which is best\nvisualized as a set of tables, rather like a page of a spreadsheet. Each table has rows, with each row\nrepresenting some entity of interest. We describe this entity through columns, each having a single\nvalue. A column may refer to another row in the same or different table, which constitutes a\nrelationship between those entities. (We’re using informal but common terminology when we speak\nof tables and rows; the more formal terms would be relations and tuples.)")]),e._v(" "),s("p",[e._v("One of the most obvious shifts with NoSQL is a move away from the relational model. Each\nNoSQL solution has a different model that it uses, which we put into four categories widely used in\nthe NoSQL ecosystem: key-value, document, column-family, and graph. Of these, the first three share\na common characteristic of their data models which we will call aggregate orientation. In this chapter\nwe’ll explain what we mean by aggregate orientation and what it means for data models.")]),e._v(" "),s("h2",{attrs:{id:"_2-1-aggregates"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-aggregates"}},[e._v("#")]),e._v(" 2.1. Aggregates")]),e._v(" "),s("p",[e._v("The relational model takes the information that we want to store and divides it into tuples (rows). A\ntuple is a limited data structure: It captures a set of values, so you cannot nest one tuple within another\nto get nested records, nor can you put a list of values or tuples within another. This simplicity\nunderpins the relational model—it allows us to think of all operations as operating on and returning\ntuples.")]),e._v(" "),s("p",[e._v("Aggregate orientation takes a different approach. It recognizes that often, you want to operate on\ndata in units that have a more complex structure than a set of tuples. It can be handy to think in terms\nof a complex record that allows lists and other record structures to be nested inside it. As we’ll see,\nkey-value, document, and column-family databases all make use of this more complex record.\nHowever, there is no common term for this complex record; in this book we use the term “aggregate.”")]),e._v(" "),s("p",[e._v("Aggregate is a term that comes from Domain-Driven Design [Evans]. In Domain-Driven Design, an\n"),s("strong",[e._v("aggregate")]),e._v(" is a collection of related objects that we wish to treat as a unit. In particular, it is a unit for\ndata manipulation and management of consistency. Typically, we like to update aggregates with\natomic operations and communicate with our data storage in terms of aggregates. This definition\nmatches really well with how key-value, document, and column-family databases work. Dealing in\naggregates makes it much easier for these databases to handle operating on a cluster, since the\naggregate makes a natural unit for replication and sharding. Aggregates are also often easier for\napplication programmers to work with, since they often manipulate data through aggregate structures.")]),e._v(" "),s("h3",{attrs:{id:"_2-1-1-example-of-relations-and-aggregates"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-1-example-of-relations-and-aggregates"}},[e._v("#")]),e._v(" "),s("strong",[e._v("2.1.1. Example of Relations and Aggregates")])]),e._v(" "),s("p",[e._v("At this point, an example may help explain what we’re talking about. Let’s assume we have to build\nan e-commerce website; we are going to be selling items directly to customers over the web, and we\nwill have to store information about users, our product catalog, orders, shipping addresses, billing\naddresses, and payment data. We can use this scenario to model the data using a relation data store as\nwell as NoSQL data stores and talk about their pros and cons. For a relational database, we might\nstart with a data model shown in Figure 2.1.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(589),alt:"Img"}})]),e._v(" "),s("p",[s("strong",[e._v("Figure 2.1. Data model oriented around a relational database (using UML notation FowlerUML))")])]),e._v(" "),s("p",[e._v("Figure 2.2 presents some sample data for this model.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(590),alt:"Img"}})]),e._v(" "),s("p",[s("strong",[e._v("Figure 2.2. Typical data using RDBMS data model")])]),e._v(" "),s("p",[e._v("As we’re good relational soldiers, everything is properly normalized, so that no data is repeated in\nmultiple tables. We also have referential integrity. A realistic order system would naturally be more\ninvolved than this, but this is the benefit of the rarefied air of a book.")]),e._v(" "),s("p",[e._v("Now let’s see how this model might look when we think in more aggregate-oriented terms (Figure\n2.3).")]),e._v(" "),s("p",[s("img",{attrs:{src:a(591),alt:"Img"}})]),e._v(" "),s("p",[s("strong",[e._v("Figure 2.3. An aggregate data model")])]),e._v(" "),s("p",[e._v("Again, we have some sample data, which we’ll show in JSON format as that’s a common representation for data in NoSQL land.")]),e._v(" "),s("div",{staticClass:"language-javascript extra-class"},[s("pre",{pre:!0,attrs:{class:"language-javascript"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// in customers")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"id"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"name"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Martin"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"billingAddress"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"city"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Chicago"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// in orders")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"id"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("99")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"customerId"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"orderItems"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n            "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"productId"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("27")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n            "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"price"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("32.45")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n            "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"productName"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"NoSQL Distilled"')]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"shippingAddress"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"city"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Chicago"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"orderPayment"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n            "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"ccinfo"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"1000-1000-1000-1000"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n            "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"txnId"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"abelif879rft"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n            "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"billingAddress"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"city"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Chicago"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),s("p",[e._v("In this model, we have two main aggregates: customer and order. We’ve used the black-diamond\ncomposition marker in UML to show how data fits into the aggregation structure. The customer\ncontains a list of billing addresses; the order contains a list of order items, a shipping address, and\npayments. The payment itself contains a billing address for that payment.")]),e._v(" "),s("p",[e._v("A single logical address record appears three times in the example data, but instead of using IDs\nit’s treated as a value and copied each time. This fits the domain where we would not want the\nshipping address, nor the payment’s billing address, to change. In a relational database, we would\nensure that the address rows aren’t updated for this case, making a new row instead. With aggregates,\nwe can copy the whole address structure into the aggregate as we need to.")]),e._v(" "),s("p",[e._v("The link between the customer and the order isn’t within either aggregate—it’s a relationship\nbetween aggregates. Similarly, the link from an order item would cross into a separate aggregate\nstructure for products, which we haven’t gone into. We’ve shown the product name as part of the\norder item here—this kind of denormalization is similar to the tradeoffs with relational databases, but\nis more common with aggregates because we want to minimize the number of aggregates we access\nduring a data interaction.")]),e._v(" "),s("p",[e._v("The important thing to notice here isn’t the particular way we’ve drawn the aggregate boundary so\nmuch as the fact that you have to think about accessing that data—and make that part of your thinking\nwhen developing the application data model. Indeed we could draw our aggregate boundaries\ndifferently, putting all the orders for a customer into the customer aggregate (Figure 2.4).")]),e._v(" "),s("p",[s("img",{attrs:{src:a(592),alt:"Img"}})]),e._v(" "),s("p",[s("strong",[e._v("Figure 2.4. Embed all the objects for customer and the customer’s orders")])]),e._v(" "),s("p",[e._v("Using the above data model, an example Customer and Order would look like this:")]),e._v(" "),s("div",{staticClass:"language-json extra-class"},[s("pre",{pre:!0,attrs:{class:"language-json"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// in customers")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"customer"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"id"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"name"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Martin"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"billingAddress"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"city"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Chicago"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"orders"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n                "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"id"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("99")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n                "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"customerId"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n                "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"orderItems"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("\n                    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n                        "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"productId"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("27")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n                        "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"price"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("32.45")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n                        "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"productName"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"NoSQL Distilled"')]),e._v("\n                    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n                "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"shippingAddress"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"city"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Chicago"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n                "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"orderPayment"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("\n                    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n                    "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"ccinfo"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"1000-1000-1000-1000"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n                    "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"txnId"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"abelif879rft"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n                    "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"billingAddress"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"city"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Chicago"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n                    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),s("p",[e._v("Like most things in modeling, there’s no universal answer for how to draw your aggregate\nboundaries. It depends entirely on how you tend to manipulate your data. If you tend to access a\ncustomer together with all of that customer’s orders at once, then you would prefer a single aggregate.\nHowever, if you tend to focus on accessing a single order at a time, then you should prefer having\nseparate aggregates for each order. Naturally, this is very context-specific; some applications will\nprefer one or the other, even within a single system, which is exactly why many people prefer\naggregate ignorance.")]),e._v(" "),s("h3",{attrs:{id:"_2-1-2-consequences-of-aggregate-orientation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-2-consequences-of-aggregate-orientation"}},[e._v("#")]),e._v(" "),s("strong",[e._v("2.1.2. Consequences of Aggregate Orientation")])]),e._v(" "),s("p",[e._v("While the relational mapping captures the various data elements and their relationships reasonably\nwell, it does so without any notion of an aggregate entity. In our domain language, we might say that\nan order consists of order items, a shipping address, and a payment. This can be expressed in the\nrelational model in terms of foreign key relationships—but there is nothing to distinguish\nrelationships that represent aggregations from those that don’t. As a result, the database can’t use a\nknowledge of aggregate structure to help it store and distribute the data.")]),e._v(" "),s("p",[e._v("Various data modeling techniques have provided ways of marking aggregate or composite\nstructures. The problem, however, is that modelers rarely provide any semantics for what makes an\naggregate relationship different from any other; where there are semantics, they vary. When working\nwith aggregate-oriented databases, we have a clearer semantics to consider by focusing on the unit of\ninteraction with the data storage. It is, however, not a logical data property: It’s all about how the\ndata is being used by applications—a concern that is often outside the bounds of data modeling.")]),e._v(" "),s("p",[e._v("Relational databases have no concept of aggregate within their data model, so we call them\n"),s("strong",[e._v("aggregate-ignorant")]),e._v(". In the NoSQL world, graph databases are also aggregate-ignorant. Being\naggregate-ignorant is not a bad thing. It’s often difficult to draw aggregate boundaries well,\nparticularly if the same data is used in many different contexts. An order makes a good aggregate\nwhen a customer is making and reviewing orders, and when the retailer is processing orders.\nHowever, if a retailer wants to analyze its product sales over the last few months, then an order\naggregate becomes a trouble. To get to product sales history, you’ll have to dig into every aggregate\nin the database. So an aggregate structure may help with some data interactions but be an obstacle for\nothers. An aggregate-ignorant model allows you to easily look at the data in different ways, so it is a\nbetter choice when you don’t have a primary structure for manipulating your data.")]),e._v(" "),s("p",[e._v("The clinching reason for aggregate orientation is that it helps greatly with running on a cluster,\nwhich as you’ll remember is the killer argument for the rise of NoSQL. If we’re running on a cluster,\nwe need to minimize how many nodes we need to query when we are gathering data. By explicitly\nincluding aggregates, we give the database important information about which bits of data will be\nmanipulated together, and thus should live on the same node.")]),e._v(" "),s("p",[e._v("Aggregates have an important consequence for transactions. Relational databases allow you to\nmanipulate any combination of rows from any tables in a single transaction. Such transactions are\ncalled "),s("strong",[e._v("ACID transactions")]),e._v(" : Atomic, Consistent, Isolated, and Durable. ACID is a rather contrived\nacronym; the real point is the atomicity: Many rows spanning many tables are updated as a single\noperation. This operation either succeeds or fails in its entirety, and concurrent operations are isolated from each other so they cannot see a partial update.")]),e._v(" "),s("p",[e._v("It’s often said that NoSQL databases don’t support ACID transactions and thus sacrifice\nconsistency. This is a rather sweeping simplification. In general, it’s true that aggregate-oriented\ndatabases don’t have ACID transactions that span multiple aggregates. Instead, they support atomic\nmanipulation of a single aggregate at a time. This means that if we need to manipulate multiple\naggregates in an atomic way, we have to manage that ourselves in the application code. In practice,\nwe find that most of the time we are able to keep our atomicity needs to within a single aggregate;\nindeed, that’s part of the consideration for deciding how to divide up our data into aggregates. We\nshould also remember that graph and other aggregate-ignorant databases usually do support ACID\ntransactions similar to relational databases. Above all, the topic of consistency is much more\ninvolved than whether a database is ACID or not, as we’ll explore in Chapter 5.")]),e._v(" "),s("h2",{attrs:{id:"_2-2-key-value-and-document-data-models"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-key-value-and-document-data-models"}},[e._v("#")]),e._v(" 2.2. Key-Value and Document Data Models")]),e._v(" "),s("p",[e._v("We said earlier on that key-value and document databases were strongly aggregate-oriented. What we\nmeant by this was that we think of these databases as primarily constructed through aggregates. Both\nof these types of databases consist of lots of aggregates with each aggregate having a key or ID that’s\nused to get at the data.")]),e._v(" "),s("p",[e._v("The two models differ in that in a key-value database, the aggregate is opaque to the database—just\nsome big blob of mostly meaningless bits. In contrast, a document database is able to see a structure\nin the aggregate. The advantage of opacity is that we can store whatever we like in the aggregate. The\ndatabase may impose some general size limit, but other than that we have complete freedom. A\ndocument database imposes limits on what we can place in it, defining allowable structures and\ntypes. In return, however, we get more flexibility in access.")]),e._v(" "),s("p",[e._v("With a key-value store, we can only access an aggregate by lookup based on its key. With a\ndocument database, we can submit queries to the database based on the fields in the aggregate, we\ncan retrieve part of the aggregate rather than the whole thing, and database can create indexes based\non the contents of the aggregate.")]),e._v(" "),s("p",[e._v("In practice, the line between key-value and document gets a bit blurry. People often put an ID field\nin a document database to do a key-value style lookup. Databases classified as key-value databases\nmay allow you structures for data beyond just an opaque aggregate. For example, Riak allows you to\nadd metadata to aggregates for indexing and interaggregate links, Redis allows you to break down the\naggregate into lists or sets. You can support querying by integrating search tools such as Solr. As an\nexample, Riak includes a search facility that uses Solr-like searching on any aggregates that are\nstored as JSON or XML structures.")]),e._v(" "),s("p",[e._v("Despite this blurriness, the general distinction still holds. With key-value databases, we expect to\nmostly look up aggregates using a key. With document databases, we mostly expect to submit some\nform of query based on the internal structure of the document; this might be a key, but it’s more likely\nto be something else.")]),e._v(" "),s("h2",{attrs:{id:"_2-3-column-family-stores"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-column-family-stores"}},[e._v("#")]),e._v(" 2.3. Column-Family Stores")]),e._v(" "),s("p",[e._v("One of the early and influential NoSQL databases was Google’s BigTable [Chang etc.]. Its name\nconjured up a tabular structure which it realized with sparse columns and no schema. As you’ll soon\nsee, it doesn’t help to think of this structure as a table; rather, it is a two-level map. But, however you\nthink about the structure, it has been a model that influenced later databases such as HBase and")]),e._v(" "),s("p",[e._v("Cassandra.")]),e._v(" "),s("p",[e._v("These databases with a bigtable-style data model are often referred to as column stores, but that\nname has been around for a while to describe a different animal. Pre-NoSQL column stores, such as\nC-Store [C-Store], were happy with SQL and the relational model. The thing that made them different\nwas the way in which they physically stored data. Most databases have a row as a unit of storage\nwhich, in particular, helps write performance. However, there are many scenarios where writes are\nrare, but you often need to read a few columns of many rows at once. In this situation, it’s better to\nstore groups of columns for all rows as the basic storage unit—which is why these databases are\ncalled column stores.")]),e._v(" "),s("p",[e._v("Bigtable and its offspring follow this notion of storing groups of columns (column families)\ntogether, but part company with C-Store and friends by abandoning the relational model and SQL. In\nthis book, we refer to this class of databases as column-family databases.")]),e._v(" "),s("p",[e._v("Perhaps the best way to think of the column-family model is as a two-level aggregate structure. As\nwith key-value stores, the first key is often described as a row identifier, picking up the aggregate of\ninterest. The difference with column-family structures is that this row aggregate is itself formed of a\nmap of more detailed values. These second-level values are referred to as columns. As well as\naccessing the row as a whole, operations also allow picking out a particular column, so to get a\nparticular customer’s name from Figure 2.5 you could do something like get('1234', 'name').")]),e._v(" "),s("p",[s("img",{attrs:{src:a(593),alt:"Img"}})]),e._v(" "),s("p",[s("strong",[e._v("Figure 2.5. Representing customer information in a column-family structure")])]),e._v(" "),s("p",[e._v("Column-family databases organize their columns into column families. Each column has to be part\nof a single column family, and the column acts as unit for access, with the assumption that data for a\nparticular column family will be usually accessed together.")]),e._v(" "),s("p",[e._v("This also gives you a couple of ways to think about how the data is structured.")]),e._v(" "),s("ul",[s("li",[e._v("Row-oriented: Each row is an aggregate (for example, customer with the ID of 1234) with column families representing useful chunks of data (profile, order history) within that aggregate.")]),e._v(" "),s("li",[e._v("Column-oriented: Each column family defines a record type (e.g., customer profiles) with rows for each of the records. You then think of a row as the join of records in all column families.")])]),e._v(" "),s("p",[e._v("This latter aspect reflects the columnar nature of column-family databases. Since the database knows about these common groupings of data, it can use this information for its storage and access behavior. Even though a document database declares some structure to the database, each document is still seen as a single unit. Column families give a two-dimensional quality to column-family databases.")]),e._v(" "),s("p",[e._v("This terminology is as established by Google Bigtable and HBase, but Cassandra looks at things\nslightly differently. A row in Cassandra only occurs in one column family, but that column family may\ncontain supercolumns—columns that contain nested columns. The supercolumns in Cassandra are the\nbest equivalent to the classic Bigtable column families.")]),e._v(" "),s("p",[e._v("It can still be confusing to think of column-families as tables. You can add any column to any row,\nand rows can have very different column keys. While new columns are added to rows during regular\ndatabase access, defining new column families is much rarer and may involve stopping the database\nfor it to happen.")]),e._v(" "),s("p",[e._v("The example of Figure 2.5 illustrates another aspect of column-family databases that may be\nunfamiliar for people used to relational tables: the orders column family. Since columns can be\nadded freely, you can model a list of items by making each item a separate column. This is very odd if\nyou think of a column family as a table, but quite natural if you think of a column-family row as an\naggregate. Cassandra uses the terms “wide” and “skinny.” "),s("strong",[e._v("Skinny rows")]),e._v(" have few columns with the\nsame columns used across the many different rows. In this case, the column family defines a record\ntype, each row is a record, and each column is a field. A "),s("strong",[e._v("wide row")]),e._v(" has many columns (perhaps\nthousands), with rows having very different columns. A wide column family models a list, with each\ncolumn being one element in that list.")]),e._v(" "),s("p",[e._v("A consequence of wide column families is that a column family may define a sort order for its\ncolumns. This way we can access orders by their order key and access ranges of orders by their keys.\nWhile this might not be useful if we keyed orders by their IDs, it would be if we made the key out of a\nconcatenation of date and ID (e.g., 20111027-1001).")]),e._v(" "),s("p",[e._v("Although it’s useful to distinguish column families by their wide or skinny nature, there’s no\ntechnical reason why a column family cannot contain both field-like columns and list-like columns—\nalthough doing this would confuse the sort ordering.")]),e._v(" "),s("h2",{attrs:{id:"_2-4-summarizing-aggregate-oriented-databases"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-summarizing-aggregate-oriented-databases"}},[e._v("#")]),e._v(" 2.4. Summarizing Aggregate-Oriented Databases")]),e._v(" "),s("p",[e._v("At this point, we’ve covered enough material to give you a reasonable overview of the three different\nstyles of aggregate-oriented data models and how they differ.")]),e._v(" "),s("p",[e._v("What they all share is the notion of an aggregate indexed by a key that you can use for lookup. This\naggregate is central to running on a cluster, as the database will ensure that all the data for an\naggregate is stored together on one node. The aggregate also acts as the atomic unit for updates,\nproviding a useful, if limited, amount of transactional control.")]),e._v(" "),s("p",[e._v("Within that notion of aggregate, we have some differences. The key-value data model treats the\naggregate as an opaque whole, which means you can only do key lookup for the whole aggregate—")]),e._v(" "),s("p",[e._v("you cannot run a query nor retrieve a part of the aggregate.")]),e._v(" "),s("p",[e._v("The document model makes the aggregate transparent to the database allowing you to do queries\nand partial retrievals. However, since the document has no schema, the database cannot act much on\nthe structure of the document to optimize the storage and retrieval of parts of the aggregate.")]),e._v(" "),s("p",[e._v("Column-family models divide the aggregate into column families, allowing the database to treat\nthem as units of data within the row aggregate. This imposes some structure on the aggregate but\nallows the database to take advantage of that structure to improve its accessibility.")]),e._v(" "),s("h2",{attrs:{id:"_2-5-further-reading"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-further-reading"}},[e._v("#")]),e._v(" 2.5. Further Reading")]),e._v(" "),s("p",[e._v("For more on the general concept of aggregates, which are often used with relational databases too,\nsee [Evans]. The Domain-Driven Design community is the best source for further information about\naggregates—recent information usually appears at "),s("a",{attrs:{href:"http://domaindrivendesign.org.",target:"_blank",rel:"noopener noreferrer"}},[e._v("http://domaindrivendesign.org."),s("OutboundLink")],1)]),e._v(" "),s("h2",{attrs:{id:"_2-6-key-points"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-6-key-points"}},[e._v("#")]),e._v(" 2.6. Key Points")]),e._v(" "),s("ul",[s("li",[e._v("An aggregate is a collection of data that we interact with as a unit. Aggregates form the boundaries for ACID operations with the database.")]),e._v(" "),s("li",[e._v("Key-value, document, and column-family databases can all be seen as forms of aggregate-oriented database.")]),e._v(" "),s("li",[e._v("Aggregates make it easier for the database to manage data storage over clusters.")]),e._v(" "),s("li",[e._v("Aggregate-oriented databases work best when most data interaction is done with the same aggregate; aggregate-ignorant databases are better when interactions use data organized in many different formations.")])])])}),[],!1,null,null,null);t.default=n.exports}}]);