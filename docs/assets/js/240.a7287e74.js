(window.webpackJsonp=window.webpackJsonp||[]).push([[240],{807:function(e,t,a){"use strict";a.r(t);var s=a(7),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"_12-emergence"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-emergence"}},[e._v("#")]),e._v(" 12. Emergence")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("by Jeff Langr\n")])])]),a("h2",{attrs:{id:"getting-clean-via-emergent-design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getting-clean-via-emergent-design"}},[e._v("#")]),e._v(" Getting Clean via Emergent Design")]),e._v(" "),a("p",[e._v("What if there were four simple rules that you could follow that would help you create good\ndesigns as you worked? What if by following these rules you gained insights into the struc-\nture and design of your code, making it easier to apply principles such as SRP and DIP?\nWhat if these four rules facilitated the "),a("em",[e._v("emergence")]),e._v(" of good designs?")]),e._v(" "),a("p",[e._v("Many of us feel that Kent Beck’s four rules of "),a("em",[e._v("Simple Design")]),e._v("^1 are of significant help in\ncreating well-designed software.")]),e._v(" "),a("ol",[a("li",[e._v("[XPE].")])]),e._v(" "),a("p",[e._v("172 "),a("strong",[e._v("Chapter 12: Emergence")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("According to Kent, a design is “simple” if it follows these rules:\n")])])]),a("ul",[a("li",[e._v("Runs all the tests")]),e._v(" "),a("li",[e._v("Contains no duplication")]),e._v(" "),a("li",[e._v("Expresses the intent of the programmer")]),e._v(" "),a("li",[e._v("Minimizes the number of classes and methods")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("The rules are given in order of importance.\n")])])]),a("h2",{attrs:{id:"simple-design-rule-1-runs-all-the-tests"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-design-rule-1-runs-all-the-tests"}},[e._v("#")]),e._v(" Simple Design Rule 1: Runs All the Tests")]),e._v(" "),a("p",[e._v("First and foremost, a design must produce a system that acts as intended. A system might\nhave a perfect design on paper, but if there is no simple way to verify that the system actu-\nally works as intended, then all the paper effort is questionable.")]),e._v(" "),a("p",[e._v("A system that is comprehensively tested and passes all of its tests all of the time is a test-\nable system. That’s an obvious statement, but an important one. Systems that aren’t testable\naren’t verifiable. Arguably, a system that cannot be verified should never be deployed.")]),e._v(" "),a("p",[e._v("Fortunately, making our systems testable pushes us toward a design where our classes\nare small and single purpose. It’s just easier to test classes that conform to the SRP. The\nmore tests we write, the more we’ll continue to push toward things that are simpler to test.\nSo making sure our system is fully testable helps us create better designs.")]),e._v(" "),a("p",[e._v("Tight coupling makes it difficult to write tests. So, similarly, the more tests we write,\nthe more we use principles like DIP and tools like dependency injection, interfaces, and\nabstraction to minimize coupling. Our designs improve even more.")]),e._v(" "),a("p",[e._v("Remarkably, following a simple and obvious rule that says we need to have tests and\nrun them continuously impacts our system’s adherence to the primary OO goals of low\ncoupling and high cohesion. Writing tests leads to better designs.")]),e._v(" "),a("h2",{attrs:{id:"simple-design-rules-2-4-refactoring"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#simple-design-rules-2-4-refactoring"}},[e._v("#")]),e._v(" Simple Design Rules 2–4: Refactoring")]),e._v(" "),a("p",[e._v("Once we have tests, we are empowered to keep our code and classes clean. We do this by\nincrementally refactoring the code. For each few lines of code we add, we pause and reflect\non the new design. Did we just degrade it? If so, we clean it up and run our tests to demon-\nstrate that we haven’t broken anything. "),a("em",[e._v("The fact that we have these tests eliminates the fear\nthat cleaning up the code will break it!")])]),e._v(" "),a("p",[e._v("During this refactoring step, we can apply anything from the entire body of knowledge\nabout good software design. We can increase cohesion, decrease coupling, separate con-\ncerns, modularize system concerns, shrink our functions and classes, choose better names,\nand so on. This is also where we apply the final three rules of simple design: Eliminate\nduplication, ensure expressiveness, and minimize the number of classes and methods.")]),e._v(" "),a("p",[a("strong",[e._v("No Duplication")]),e._v(" 173")]),e._v(" "),a("h2",{attrs:{id:"no-duplication"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#no-duplication"}},[e._v("#")]),e._v(" No Duplication ...")]),e._v(" "),a("p",[e._v("Duplication is the primary enemy of a well-designed system. It represents additional\nwork, additional risk, and additional unnecessary complexity. Duplication manifests\nitself in many forms. Lines of code that look exactly alike are, of course, duplication.\nLines of code that are similar can often be massaged to look even more alike so that\nthey can be more easily refactored. And duplication can exist in other forms such as\nduplication of implementation. For example, we might have two methods in a collection\nclass:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("int size() {}\nboolean isEmpty() {}\n")])])]),a("p",[e._v("We could have separate implementations for each method. The isEmptymethod could track\na boolean, while sizecould track a counter. Or, we can eliminate this duplication by tying\nisEmpty to the definition of size:")]),e._v(" "),a("p",[e._v("boolean isEmpty() {\nreturn 0 == size();\n}\nCreating a clean system requires the will to eliminate duplication, even in just a few\nlines of code. For example, consider the following code:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public void scaleToOneDimension(\nfloat desiredDimension, float imageDimension) {\nif (Math.abs(desiredDimension - imageDimension) < errorThreshold)\nreturn;\nfloat scalingFactor = desiredDimension / imageDimension;\nscalingFactor = (float)(Math.floor(scalingFactor * 100) * 0.01f);\nRenderedOp newImage = ImageUtilities.getScaledImage(\nimage, scalingFactor, scalingFactor);\nimage.dispose();\nSystem.gc();\nimage = newImage;\n}\npublic synchronized void rotate(int degrees) {\nRenderedOp newImage = ImageUtilities.getRotatedImage(\nimage, degrees);\nimage.dispose();\nSystem.gc();\nimage = newImage;\n}\n")])])]),a("p",[e._v("To keep this system clean, we should eliminate the small amount of duplication between\nthescaleToOneDimension and rotate methods:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public void scaleToOneDimension(\nfloat desiredDimension, float imageDimension) {\nif (Math.abs(desiredDimension - imageDimension) < errorThreshold)\nreturn;\nfloat scalingFactor = desiredDimension / imageDimension;\nscalingFactor = (float)(Math.floor(scalingFactor * 100) * 0.01f);\n")])])]),a("p",[e._v("174 "),a("strong",[e._v("Chapter 12: Emergence")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("replaceImage(ImageUtilities.getScaledImage(\nimage, scalingFactor, scalingFactor));\n}\npublic synchronized void rotate(int degrees) {\nreplaceImage(ImageUtilities.getRotatedImage(image, degrees));\n}\nprivate void replaceImage(RenderedOp newImage) {\nimage.dispose();\nSystem.gc();\nimage = newImage;\n}\n")])])]),a("p",[e._v("As we extract commonality at this very tiny level, we start to recognize violations of SRP.\nSo we might move a newly extracted method to another class. That elevates its visibility.\nSomeone else on the team may recognize the opportunity to further abstract the new\nmethod and reuse it in a different context. This “reuse in the small” can cause system com-\nplexity to shrink dramatically. Understanding how to achieve reuse in the small is essential\nto achieving reuse in the large.")]),e._v(" "),a("p",[e._v("The TEMPLATE METHOD^2 pattern is a common technique for removing higher-level\nduplication. For example:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("public class VacationPolicy {\npublic void accrueUSDivisionVacation() {\n// code to calculate vacation based on hours worked to date\n// ...\n// code to ensure vacation meets US minimums\n// ...\n// code to apply vaction to payroll record\n// ...\n}\npublic void accrueEUDivisionVacation() {\n// code to calculate vacation based on hours worked to date\n// ...\n// code to ensure vacation meets EU minimums\n// ...\n// code to apply vaction to payroll record\n// ...\n}\n}\n")])])]),a("p",[e._v("The code across accrueUSDivisionVacationandaccrueEuropeanDivisionVacationis largely\nthe same, with the exception of calculating legal minimums. That bit of the algorithm\nchanges based on the employee type.")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("We can eliminate the obvious duplication by applying the TEMPLATE METHOD pattern.\nabstract public class VacationPolicy {\npublic void accrueVacation() {\ncalculateBaseVacationHours();\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[e._v("[GOF].")])]),e._v(" "),a("p",[a("strong",[e._v("Expressive")]),e._v(" 175")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("alterForLegalMinimums();\napplyToPayroll();\n}\nprivate void calculateBaseVacationHours() { /* ... */ };\nabstract protected void alterForLegalMinimums();\nprivate void applyToPayroll() { /* ... */ };\n}\npublic class USVacationPolicy extends VacationPolicy {\n@Override protected void alterForLegalMinimums() {\n// US specific logic\n}\n}\npublic class EUVacationPolicy extends VacationPolicy {\n@Override protected void alterForLegalMinimums() {\n// EU specific logic\n}\n}\n")])])]),a("p",[e._v("The subclasses fill in the “hole” in the accrueVacationalgorithm, supplying the only bits of\ninformation that are not duplicated.")]),e._v(" "),a("h2",{attrs:{id:"expressive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#expressive"}},[e._v("#")]),e._v(" Expressive ...")]),e._v(" "),a("p",[e._v("Most of us have had the experience of working on convoluted code. Many of us have pro-\nduced some convoluted code ourselves. It’s easy to write code that "),a("em",[e._v("we")]),e._v(" understand, because\nat the time we write it we’re deep in an understanding of the problem we’re trying to solve.\nOther maintainers of the code aren’t going to have so deep an understanding.")]),e._v(" "),a("p",[e._v("The majority of the cost of a software project is in long-term maintenance. In order to\nminimize the potential for defects as we introduce change, it’s critical for us to be able to\nunderstand what a system does. As systems become more complex, they take more and\nmore time for a developer to understand, and there is an ever greater opportunity for a mis-\nunderstanding. Therefore, code should clearly express the intent of its author. The clearer\nthe author can make the code, the less time others will have to spend understanding it. This\nwill reduce defects and shrink the cost of maintenance.")]),e._v(" "),a("p",[e._v("You can express yourself by choosing good names. We want to be able to hear a class\nor function name and not be surprised when we discover its responsibilities.")]),e._v(" "),a("p",[e._v("You can also express yourself by keeping your functions and classes small. Small\nclasses and functions are usually easy to name, easy to write, and easy to understand.")]),e._v(" "),a("p",[e._v("You can also express yourself by using standard nomenclature. Design patterns, for\nexample, are largely about communication and expressiveness. By using the standard\npattern names, such as COMMANDor VISITOR, in the names of the classes that imple-\nment those patterns, you can succinctly describe your design to other developers.")]),e._v(" "),a("p",[e._v("Well-written unit tests are also expressive. A primary goal of tests is to act as docu-\nmentation by example. Someone reading our tests should be able to get a quick under-\nstanding of what a class is all about.")]),e._v(" "),a("p",[e._v("176 "),a("strong",[e._v("Chapter 12: Emergence")])]),e._v(" "),a("p",[e._v("But the most important way to be expressive is to "),a("em",[e._v("try")]),e._v(". All too often we get our code\nworking and then move on to the next problem without giving sufficient thought to making\nthat code easy for the next person to read. Remember, the most likely next person to read\nthe code will be you.")]),e._v(" "),a("p",[e._v("So take a little pride in your workmanship. Spend a little time with each of your func-\ntions and classes. Choose better names, split large functions into smaller functions, and\ngenerally just take care of what you’ve created. Care is a precious resource.")]),e._v(" "),a("h2",{attrs:{id:"minimal-classes-and-methods"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#minimal-classes-and-methods"}},[e._v("#")]),e._v(" Minimal Classes and Methods .")]),e._v(" "),a("p",[e._v("Even concepts as fundamental as elimination of duplication, code expressiveness, and the\nSRP can be taken too far. In an effort to make our classes and methods small, we might\ncreate too many tiny classes and methods. So this rule suggests that we also keep our func-\ntion and class counts low.")]),e._v(" "),a("p",[e._v("High class and method counts are sometimes the result of pointless dogmatism. Con-\nsider, for example, a coding standard that insists on creating an interface for each and\nevery class. Or consider developers who insist that fields and behavior must always be sep-\narated into data classes and behavior classes. Such dogma should be resisted and a more\npragmatic approach adopted.")]),e._v(" "),a("p",[e._v("Our goal is to keep our overall system small while we are also keeping our functions\nand classes small. Remember, however, that this rule is the lowest priority of the four rules\nof Simple Design. So, although it’s important to keep class and function count low, it’s\nmore important to have tests, eliminate duplication, and express yourself.")]),e._v(" "),a("h2",{attrs:{id:"conclusion"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[e._v("#")]),e._v(" Conclusion ..")]),e._v(" "),a("p",[e._v("Is there a set of simple practices that can replace experience? Clearly not. On the other\nhand, the practices described in this chapter and in this book are a crystallized form of the\nmany decades of experience enjoyed by the authors. Following the practice of simple\ndesign can and does encourage and enable developers to adhere to good principles and\npatterns that otherwise take years to learn.")]),e._v(" "),a("h2",{attrs:{id:"bibliography"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bibliography"}},[e._v("#")]),e._v(" Bibliography ...")]),e._v(" "),a("p",[a("strong",[e._v("[XPE]:")]),e._v(" "),a("em",[e._v("Extreme Programming Explained: Embrace Change,")]),e._v(" Kent Beck, Addison-\nWesley, 1999.")]),e._v(" "),a("p",[a("strong",[e._v("[GOF]:")]),e._v(" "),a("em",[e._v("Design Patterns: Elements of Reusable Object Oriented Software,")]),e._v(" Gamma et al.,\nAddison-Wesley, 1996.")])])}),[],!1,null,null,null);t.default=n.exports}}]);