(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{1142:function(e,t,s){"use strict";s.r(t);var a=s(7),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"nearby-friends"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nearby-friends"}},[e._v("#")]),e._v(" Nearby Friends")]),e._v(" "),a("p",[e._v('In this chapter, we design a scalable backend system for a new mobile app feature called “Nearby Friends". For an opt-in user who grants permission to access their location, the mobile client presents list of friends who are geographically nearby. If you are looking for 2 real-world example, please refer to this article [1] about similar\nfeature in the Facebook app.')]),e._v(" "),a("p",[e._v('If you read the Proximity Service chapter, you may wonder why we need a separate chapter for designing “nearby friends” since it looks similar to proximity services. If you think carefully though, you will find major differences. In proximity services, the addresses for businesses are static as their locations do not change, while in “nearby friends", data is more dynamic because user locations change frequently.')]),e._v(" "),a("h2",{attrs:{id:"s1-understand-the-problem-and-establish-design-scope"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#s1-understand-the-problem-and-establish-design-scope"}},[e._v("#")]),e._v(" S1 - Understand the problem and establish design scope")]),e._v(" "),a("p",[e._v("Any backend system at the Facebook scale is complicated. Before starting with the design, we need to ask clarification questions to narrow down the scope.")]),e._v(" "),a("p",[a("strong",[e._v("Candidate")]),e._v(": How geographically close is considered to be “nearby™?"),a("br"),e._v(" "),a("strong",[e._v("Interviewer")]),e._v(": 5 miles. This number should be configurable.")]),e._v(" "),a("p",[a("strong",[e._v("Candidate")]),e._v(": Can | assume the distance is calculated as the straight-line distance between two users? In real life, there could be, for example, a river in between the users, resulting in a longer travel distance."),a("br"),e._v(" "),a("strong",[e._v("Interviewer")]),e._v(": Yes, that's a reasonable assumption.")]),e._v(" "),a("p",[a("strong",[e._v("Candidate")]),e._v(": How many users does the app have? Can | assume 1 billion users and 10% of them use the nearby friends feature?"),a("br"),e._v(" "),a("strong",[e._v("Interviewer")]),e._v(": Yes, that's a reasonable assumption.")]),e._v(" "),a("p",[a("strong",[e._v("Candidate")]),e._v(": Do we need to store location history?"),a("br"),e._v(" "),a("strong",[e._v("Interviewer")]),e._v(": Yes, location history can be valuable for different purposes such as machine learning.")]),e._v(" "),a("p",[e._v("‘"),a("strong",[e._v("Candidate")]),e._v(": Could we assume if a friend is inactive for more than 10 minutes, that friend will disappear from the nearby friend list? Or should we display the last known location?"),a("br"),e._v(" "),a("strong",[e._v("Interviewer")]),e._v(": We can assume inactive friends will no longer be shown.")]),e._v(" "),a("p",[a("strong",[e._v("Candidate")]),e._v(": Do we need to worry about privacy and data laws such as GDPR or CCPA?"),a("br"),e._v(" "),a("strong",[e._v("Interviewer")]),e._v(": Good question. For simplicity, don't worry about it for now.")]),e._v(" "),a("h3",{attrs:{id:"functional-requirements"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#functional-requirements"}},[e._v("#")]),e._v(" Functional requirements")]),e._v(" "),a("ul",[a("li",[e._v("Users should be able to see nearby friends on their mobile apps. Each entry in the nearby friend list has a distance and a timestamp indicating when the distance was last updated.")]),e._v(" "),a("li",[e._v("Nearby friend lists should be updated every few seconds.")])]),e._v(" "),a("h3",{attrs:{id:"non-functional-requirements"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#non-functional-requirements"}},[e._v("#")]),e._v(" Non-functional requirements")]),e._v(" "),a("ul",[a("li",[e._v("Low latency. It's important to receive location updates from friends without too much delay.")]),e._v(" "),a("li",[e._v("Reliability. The system needs to be reliable overall, but occasional data point loss is acceptable.")]),e._v(" "),a("li",[e._v("Eventual consistency. The location data store doesn't need strong consistency. A few seconds delay in receiving location data in different replicas is acceptable.")])]),e._v(" "),a("h3",{attrs:{id:"back-of-the-envelope-estimation"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#back-of-the-envelope-estimation"}},[e._v("#")]),e._v(" Back of the envelope estimation")]),e._v(" "),a("p",[e._v("Let's do a back-of-the-envelope estimation to determine the potential scale and challenges our solution will need 10 address. Some constraints and assumptions are listed below:")]),e._v(" "),a("ul",[a("li",[e._v("Nearby friends are defined as friends whose locations are within a 5-mile radius.")]),e._v(" "),a("li",[e._v("The location refresh interval is 30 seconds. The reason for this is that human walking speed is slow (average 3-4 miles per hour). The distance traveled in 30 seconds does not make a significant difference on the “nearby friends” feature.")]),e._v(" "),a("li",[e._v('On average, 100 milion users use the “nearby friends" feature every day.')]),e._v(" "),a("li",[e._v("Assume the number of concurrent users is 10% of DAU, 5o the number of concurrent users is 10 million")]),e._v(" "),a("li",[e._v('On average, a user has 400 friends. Assume all of them use the “nearby friends" feature.')]),e._v(" "),a("li",[e._v("The app displays 20 nearby friends per page and may load more nearby friends upon request.")])]),e._v(" "),a("p",[a("strong",[e._v("Calculate QPS")])]),e._v(" "),a("ul",[a("li",[e._v("100 million DAU")]),e._v(" "),a("li",[e._v("Concurrent users: 10% * 100 million = 10 million")]),e._v(" "),a("li",[e._v("Users report their locations every 30 seconds")]),e._v(" "),a("li",[e._v("Location update QPS = 10 million / 30 = ~334,000")])]),e._v(" "),a("h2",{attrs:{id:"s2-propose-high-level-design-and-get-buy-in"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#s2-propose-high-level-design-and-get-buy-in"}},[e._v("#")]),e._v(" S2 - Propose High-Level Design and Get Buy-In")]),e._v(" "),a("p",[e._v("In this section, we will discuss the following:")]),e._v(" "),a("ul",[a("li",[e._v("High-level design")]),e._v(" "),a("li",[e._v("APl design")]),e._v(" "),a("li",[e._v("Data model")])]),e._v(" "),a("p",[e._v("In other chapters, we usually discuss API design and data model before the high-level design. However, for this problem, the communication protocol between client and server might not be a straightforward HTTP protocol, as we need to push location data to allfriends. Without understanding the high-level design, its difficult to know what the APls look like. Therefore, we discuss the high-level design first.")]),e._v(" "),a("h3",{attrs:{id:"high-level-design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#high-level-design"}},[e._v("#")]),e._v(" High-level design")]),e._v(" "),a("p",[e._v("At a high level, this problem calls for a design with efficient message passing. Conceptually, a user would ke to receive location updates from every active friend nearby. It could in theory be done purely peer-to-peer, that is, a user could maintain a persistent connection to every other active friend in the vicinity")]),e._v(" "),a("p",[a("img",{attrs:{src:s(629),alt:"img"}})]),e._v(" "),a("p",[e._v("This solution is not practical for a mobile device with sometimes flaky connections and a tight power consumption budget, but the idea sheds some light on the general design direction.")]),e._v(" "),a("p",[e._v("A more practical design would have a shared backend and look like this:")]),e._v(" "),a("p",[a("img",{attrs:{src:s(630),alt:"img"}})]),e._v(" "),a("p",[e._v("What are the responsibilities of the backend in Figure above?")]),e._v(" "),a("ul",[a("li",[e._v("Receive location updates from all active users.")]),e._v(" "),a("li",[e._v("For each location update, find all the active friends who should receive it and forward it to those users’ devices.")]),e._v(" "),a("li",[e._v("If the distance between two users is over a certain threshold, do not forward it to the recipient's device.")])]),e._v(" "),a("p",[e._v("This sounds pretty simple. What is the issue? Well, to do this at scale is not easy. We have 10 million active users.")]),e._v(" "),a("p",[e._v("With each user updating the location information every 30 seconds, there are 334K updates per second. If on average each user has 400 friends, and we further assume that roughly 10% of those friends are online and nearby, every second the backend forwards 334K * 400 * 10% = 14 million location updates per second. That is a ot of updates to forward.")]),e._v(" "),a("h4",{attrs:{id:"proposed-design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#proposed-design"}},[e._v("#")]),e._v(" Proposed design")]),e._v(" "),a("p",[e._v("We will first come up with a high-level design for the backend at a lower scale. Later in the deep dive section, we\nwill optimize the design for scale.\nFigure 4 shows the basic design that should satisfy the functional requirements. Let's go over each component in\nthe design.")]),e._v(" "),a("p",[a("img",{attrs:{src:s(631),alt:"img"}})]),e._v(" "),a("h4",{attrs:{id:"load-balancer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#load-balancer"}},[e._v("#")]),e._v(" Load balancer")]),e._v(" "),a("p",[e._v("The load balancer sits in front of the RESTful AP servers and the stateful, bi-directional WebSocket servers. It\ndistributes traffic across those servers to spread out load evenly.")]),e._v(" "),a("h3",{attrs:{id:"restful-api-servers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#restful-api-servers"}},[e._v("#")]),e._v(" RESTful API servers")]),e._v(" "),a("p",[e._v("This is a cluster of stateless HTTP servers that handles the typical request/response traffic. The API request flow is highlighted in Figure below. This API layer handles auxiliary tasks like adding/removing friends, updating user profiles, etc. These are very common and we will not go into more detail.")]),e._v(" "),a("p",[a("img",{attrs:{src:s(632),alt:"img"}})]),e._v(" "),a("h4",{attrs:{id:"websocket-servers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#websocket-servers"}},[e._v("#")]),e._v(" Websocket servers")]),e._v(" "),a("p",[e._v("This is a cluster of stateful servers that handles the near real-time update of friends locations. Each client maintains one persistent WebSocket connection to one of these servers. When there is location update from a friend who is within the search radius, the update is sent on this connection to the client.")]),e._v(" "),a("p",[e._v("Another major responsibility of the WebSocket servers is to handle client initialization for the “nearby friends™ feature. It seeds the mobile client with the locations of all nearby online friends. We will discuss how this is done in more detail later.")]),e._v(" "),a("p",[e._v('Note "WebSocket connection” and "WebSocket connection handler” are interchangeable in this chapter.')]),e._v(" "),a("h4",{attrs:{id:"redis-location-cache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-location-cache"}},[e._v("#")]),e._v(" Redis location cache")]),e._v(" "),a("p",[e._v("Redis is used 10 store the most recent location data for each active user. There is a Time o Live (TTL) set on each entry in the cache. When the TTL expires, the user is no longer active and the location data is expunged from the cache. Every update refreshes the TTL. Other KV stores that support TTL could also be used.")]),e._v(" "),a("h4",{attrs:{id:"user-database"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#user-database"}},[e._v("#")]),e._v(" User database")]),e._v(" "),a("p",[e._v("The user database stores user data and user friendship data. Either a relational database or a NoSQL database can be used for this.")]),e._v(" "),a("h4",{attrs:{id:"location-history-database"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#location-history-database"}},[e._v("#")]),e._v(" Location history database")]),e._v(" "),a("p",[e._v("This database stores users’ historical location data. It is not directly related to the “nearby friends” feature.")]),e._v(" "),a("h4",{attrs:{id:"redis-pub-sub-server"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-pub-sub-server"}},[e._v("#")]),e._v(" Redis pub/sub server")]),e._v(" "),a("p",[e._v("Redis pub/sub is a very lightweight message bus. Channels in Redis pub/sub are very cheap to create. A modern Redis server with GBS of memory could hold millions of channels (also called topics). Figure below shows how Redis Pub/Sub works.")]),e._v(" "),a("p",[a("img",{attrs:{src:s(633),alt:"img"}})]),e._v(" "),a("p",[e._v("In this design, location updates received via the WebSocket server are published to the user’'s own channel in the Redis pub/sub server. A dedicated WebSocket connection handler for each active friend subscribes to the channel.")]),e._v(" "),a("p",[e._v("When there is a location update, the WebSocket handler function gets invoked, and for each active friend, the function recomputes the distance. If the new distance is within the search radius, the new location and timestamp are sent via the WebSocket connection to the friend's client. Other message buses with lightweight channels could also be used.")]),e._v(" "),a("p",[e._v("Now that we understand what each component does, let's examine what happens when a user’s location changes from the system’s perspective.")]),e._v(" "),a("h3",{attrs:{id:"periodic-location-update"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#periodic-location-update"}},[e._v("#")]),e._v(" Periodic location update")]),e._v(" "),a("p",[e._v("The mobile dlient sends periodic location updates over the persistent WebSocket connection. The flow is shown in Figure below.")]),e._v(" "),a("p",[a("img",{attrs:{src:s(634),alt:"img"}})]),e._v(" "),a("ol",[a("li",[e._v("The mobile client sends a location update to the load balancer.")]),e._v(" "),a("li",[e._v("The load balancer forwards the location update to the persistent connection on the WebSocket server for that client.")]),e._v(" "),a("li",[e._v("The WebSocket server saves the location data to the location history database.")]),e._v(" "),a("li",[e._v("The WebSocket server updates the new location in the location cache. The update refreshes the TTL. The ‘WebSocket server also saves the new location in a variable in the user's WebSocket connection handler for subsequent distance calculations.")]),e._v(" "),a("li",[e._v("The WebSocket server publishes the new location to the user's channel in the Redis pub/sub server. Steps 3 to 5 can be executed in parallel.")]),e._v(" "),a("li",[e._v("When Redis pub/sub receives a location update on a channel, it broadcasts the update on all the subscribers (WebSocket connection handlers). In this case, the subscribers are all the online friends of the user sending the update. For each subscriber (.., for each of the user's friends), its WebSocket connection handler would receive the user location update.")]),e._v(" "),a("li",[e._v("On receiving the message, the WebSocket server, on which the connection handler lives, computes the distance between the user sending the new location (the location data is in the message) and the subscriber (the location data is stored in a variable with the WebSocket connection handler for the subscriber).")]),e._v(" "),a("li",[e._v("This step is not drawn on the diagram. If the distance does not exceed the search radius, the new location and the last updated timestamp are sent to the subscriber’s client. Otherwise, the update is dropped.")])]),e._v(" "),a("p",[e._v("Since understanding this flow is extremely important, let's examine it again with a concrete example, as shown in\nFigure 8. Before we start, let's make a few assumptions.")]),e._v(" "),a("ul",[a("li",[e._v("User 1's friends: user 2, user 3, and user 4.")]),e._v(" "),a("li",[e._v("User 5's friends: user 4 and user 6.")])]),e._v(" "),a("p",[a("img",{attrs:{src:s(635),alt:"img"}})]),e._v(" "),a("ol",[a("li",[e._v("When user 1's location changes, their location update is sent to the WebSocket server which holds user 1's connection.")]),e._v(" "),a("li",[e._v("The location is published to user 1's channel in Redis puby/sub server.")]),e._v(" "),a("li",[e._v("Redis pub/sub server broadcasts the location update to all subscribers. In this case, subscribers are WebSocket connection handlers (user 1's friends).")]),e._v(" "),a("li",[e._v("If the distance between the user sending the location (user 1) and the subscriber (user 2) doesn't exceed the search radius, the new location is sent to the client (user 2).")])]),e._v(" "),a("p",[e._v("This computation is repeated for every subscriber to the channel. Since there are 400 friends on average, and we assume that 10% of those friends are online and nearby, there are about 40 location updates to forward for each user’s location update.")]),e._v(" "),a("h3",{attrs:{id:"api-design"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#api-design"}},[e._v("#")]),e._v(" API design")]),e._v(" "),a("p",[e._v("Now that we have created a high-level design, let’s list APIs needed.")]),e._v(" "),a("p",[a("strong",[e._v("WebSocket")]),e._v(": Users send and receive location updates through the WebSocket protocol. At the minimum, we need the following APIs.")]),e._v(" "),a("p",[a("strong",[e._v("1. Periodic location update")]),a("br"),e._v("\nRequest: Client sends latitude, longitude, and timestamp.\nResponse: Nothing.")]),e._v(" "),a("p",[a("strong",[e._v("2. Client receives location updates")]),e._v("\nData sent: Friend location data and timestamp.")]),e._v(" "),a("p",[a("strong",[e._v("3. WebSocket initialization")]),a("br"),e._v("\nRequest: Client sends latitude, longitude, and timestamp.\nResponse: Client receives friends’ location data.")]),e._v(" "),a("p",[a("strong",[e._v("4. Subscribe to a new friend")]),a("br"),e._v("\nRequest: WebSocket server sends friend ID.\nResponse: Friend’s latest latitude, longitude, and timestamp.")]),e._v(" "),a("p",[a("strong",[e._v("5. Unsubscribe a friend")]),a("br"),e._v("\nRequest: WebSocket server sends friend ID.\nResponse: Nothing.")]),e._v(" "),a("p",[a("strong",[e._v("HTTP requests:")]),e._v(" the API servers handle tasks like adding/removing friends, updating user profiles, etc. These are very common and we will not go into detail here.")]),e._v(" "),a("h3",{attrs:{id:"data-model"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#data-model"}},[e._v("#")]),e._v(" Data model")]),e._v(" "),a("p",[e._v("Another important element to discuss is the data model. We already talked about the User DB in the high-level design, so let's focus on the location cache and location history database.")]),e._v(" "),a("h4",{attrs:{id:"location-cache"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#location-cache"}},[e._v("#")]),e._v(" Location cache")]),e._v(" "),a("p",[e._v("The location cache stores the latest locations of all active users who have had the nearby friends feature turned on. We use Redis for this cache. The key/value of the cache is shown in Table 1.")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("key")]),e._v(" "),a("th",[e._v("value")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("user_id")]),e._v(" "),a("td",[a("code",[e._v("{ gatitude, longitude, timestamp }")])])])])]),e._v(" "),a("h4",{attrs:{id:"why-don-t-we-use-a-database-to-store-location-data"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#why-don-t-we-use-a-database-to-store-location-data"}},[e._v("#")]),e._v(" Why don't we use a database to store location data?")]),e._v(" "),a("p",[e._v('The “nearby friends" feature only cares about the '),a("strong",[e._v("current")]),e._v(" location of a user. Therefore, we only need to store one location per user. Redis is an excellent choice because it provides super-fast read and write operations. It supports TTL, which we use to auto-purge users from the cache who are no longer active. The current locations do not need 10 be durably stored. If the Redis instance goes down, we could replace it with an empty new instance and let the cache be filled as new location updates stream in. The active users could miss location updates from friends for an update cycle or two while the new cache warms. It is an acceptable tradeoff. In the deep dive section, we will discuss ways to lessen the impact on users when the cache gets replaced.")]),e._v(" "),a("h4",{attrs:{id:"location-history-database-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#location-history-database-2"}},[e._v("#")]),e._v(" Location history database")]),e._v(" "),a("p",[e._v("The location history database stores users' historical location data and the schema looks like this:")]),e._v(" "),a("p",[a("code",[e._v("| user_id | latitude | longitude | timestamp |")])]),e._v(" "),a("p",[e._v("We need a database that handles the heavy-write workload well and can be horizontally scaled. Cassandra is a good candidate. We could also use a relational database. However, with a relational database, the historical data would not fit in a single instance so we need to shard that data. The most basic approach is to shard by user ID. This sharding scheme ensures that load is evenly distributed among all the shards, and operationally, it i easy to maintain.")]),e._v(" "),a("h2",{attrs:{id:"step-3-design-deep-dive"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#step-3-design-deep-dive"}},[e._v("#")]),e._v(" Step 3 - Design Deep Dive")]),e._v(" "),a("p",[e._v("The high-level design we created in the previous section works in most cases, but it will likely break at our scale. In this section, we work together to uncover the bottienecks as we increase the scale, and along the way work on solutions to eliminate those bottienecks.")]),e._v(" "),a("h3",{attrs:{id:"how-well-does-each-component-scale"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#how-well-does-each-component-scale"}},[e._v("#")]),e._v(" How well does each component scale?")]),e._v(" "),a("h4",{attrs:{id:"api-servers"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#api-servers"}},[e._v("#")]),e._v(" API servers")]),e._v(" "),a("p",[e._v("The methods to scale the RESTful API tiers are well understood. These are stateless servers, and there are many ways to auto-scale the clusters based on CPU usage, load, or I/O. We will not go into detail here.")]),e._v(" "),a("h4",{attrs:{id:"websocket-servers-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#websocket-servers-2"}},[e._v("#")]),e._v(" WebSocket servers")]),e._v(" "),a("p",[e._v("For the WebSocket cluster, it is not difficult to auto-scale based on usage. However, the WebSocket servers are stateful, so care must be taken when removing existing nodes. Before a node can be removed, all existing connections should be allowed to drain. To achieve that, we can mark a node as “draining” at the load balancer so that no new WebSocket connections will be routed to the draining server. Once all the existing connections are closed (or after a reasonably long wait), the server is then removed.")]),e._v(" "),a("p",[e._v("Releasing a new version of the application software on a WebSocket server requires the same level of care.")]),e._v(" "),a("p",[e._v("It is worth noting that effective auto-scaling of stateful servers is the job of a good load balancer. Most cloud load balancers handle this job very well.")]),e._v(" "),a("h5",{attrs:{id:"client-initialization"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#client-initialization"}},[e._v("#")]),e._v(" Client Initialization")]),e._v(" "),a("p",[e._v("The mobile client on startup establishes a persistent WebSocket connection with one of the WebSocket server instances. Each connection is long-running. Most modern languages are capable of maintaining many long-running connections with a reasonably small memory footprint.")]),e._v(" "),a("p",[e._v("When a WebSocket connection is initialized, the client sends the initial location of the user, and the server performs the following tasks in the WebSocket connection handler.")]),e._v(" "),a("ol",[a("li",[e._v("It updates the user’s location in the location cache.")]),e._v(" "),a("li",[e._v("It saves the location in a variable of the connection handler for subsequent calculations.")]),e._v(" "),a("li",[e._v("It loads all the user’s friends from the user database.")]),e._v(" "),a("li",[e._v("It makes a batched request to the location cache to fetch the locations for all the friends. Note that because we set 2 TTL on each entry in the location cache to match our inactivity timeout period, if a friend is inactive then their location will not be in the location cache.")]),e._v(" "),a("li",[e._v("For each location returned by the cache, the server computes the distance between the user and the friend at that location. If the distance is within the search radius, the friend’s profile, location, and last updated timestamp are returned over the WebSocket connection to the client.")]),e._v(" "),a("li",[e._v("For each friend, the server subscribes to the friend's channel in the Redis pub/sub server. We will explain our use of Redis pub/sub shortly. Since creating a new channel is cheap, the user subscribes to all active and inactive friends. The inactive friends will take up a small amount of memory on the Redis pub/sub server, but they will not consume any CPU or I/O (since they do not publish updates) until they come online.")]),e._v(" "),a("li",[e._v("It sends the user's current location to the user's channel in the Redis pub/sub server.")])]),e._v(" "),a("h4",{attrs:{id:"user-database-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#user-database-2"}},[e._v("#")]),e._v(" User database")]),e._v(" "),a("p",[e._v("The user database holds two distinct sets of data; user profiles (user ID, usemame, profile URL, etc) and friendships. These datasets at our design scale willlikely not fit in a single relational database instance. The good news is that the data is horizontally scalable by sharding based on user ID. Relational database sharding is a very common technique.")]),e._v(" "),a("p",[e._v("As a side note, at the scale we are designing for, the user and friendship datasets will likely be managed by a dedicated team and be available via an internal AP, In this scenario, the WebSocket servers will use the internal API instead of querying the database directly to fetch user and friendship-related data. Whether accessing via AP or direct database queries, it does not make much difference in terms of functionality or performance.")]),e._v(" "),a("h4",{attrs:{id:"location-cache-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#location-cache-2"}},[e._v("#")]),e._v(" Location cache")]),e._v(" "),a("p",[e._v("We choose Redis to cache the most recent locations of al the active users. As mentioned earlier, we also set a TTL on each key. The TTL is renewed upon every location update. This puts 2 cap on the maximum amount of memory ‘used. With 10 million active users at peak, and with each location taking no more than 100 bytes, a single modern Redis server with many GBs of memory should be able to easily hold the location information for all users.")]),e._v(" "),a("p",[e._v("However, with 10 million active users roughly updating every 30 seconds, the Redis server will have to handle 334K updates per second. That is likely a little to0 high, even for a modem high-end server. Luckily, this cache data is easy to shard. The location data for each user is independent, and we can evenly spread the load among several Redis servers by sharding the location data based on user ID.")]),e._v(" "),a("p",[e._v("To improve availability, we could replicate the location data on each shard to a standby node. If the primary node ‘goes down, the standby could be quickly promoted to minimize downtime.")]),e._v(" "),a("h4",{attrs:{id:"redis-pub-sub-server-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redis-pub-sub-server-2"}},[e._v("#")]),e._v(" Redis pub/sub server")]),e._v(" "),a("p",[e._v("The puby/sub server is used as a routing layer to direct messages (location updates) from one user to all the online friends. As mentioned earlier, we choose Redis pub/sub because it s very lightweight to create new channels. A new channel is created when someone subscribes to it. If a message is published to a channel that has no subscribers, the message is dropped, placing very little load on the server. When a channel is created, Redis uses a small amount of memory to maintain a hash table and a linked lst  1o track the subscribers. If there is no update on a channel when a user is offline, no CPU cycles are used after a channel is created. We take advantage of this in our design in the following ways:")]),e._v(" "),a("ol",[a("li",[e._v("We assign 2 unique channel to every user who uses the “nearby friends” feature. A user would, upon app initialization, subscribe to each friends channel, whether the friend is online or not. This simplifies the design since the backend does not need to handle subscribing to a friend's channel when the friend becomes active, ‘or handling unsubscribing when the friend becomes inactive.")]),e._v(" "),a("li",[e._v("The tradeoff is that the design would use more memory. As we will see later, memory use is unlikely to be the\nbottleneck. Trading higher memory use for a simpler architecture is worth it in this case.")])]),e._v(" "),a("p",[a("strong",[e._v("How many Redis pub/sub servers do we need?")]),a("br"),e._v("\nLet's do some math on memory and CPU usage.")]),e._v(" "),a("p",[a("strong",[e._v("Memory usage")])]),e._v(" "),a("p",[e._v("Assuming a channel is allocated for each user who uses the nearby friends feature, we need 100 million channels (1 billion * 10%). Assuming that on average a user has 100 active friends using this feature (this includes friends who are nearby, or not), and it takes about 20 bytes of pointers in the intemal hash table and linked list to track each subscriber, it will need about 200 GB (100 million * 20 bytes * 100 friends / 10~9 = 200 GB) to hold all the channes.")]),e._v(" "),a("p",[e._v("For a modern server with 100 GB of memory, we will need about 2 Redis pub/sub servers to hold all the channels.")]),e._v(" "),a("p",[a("strong",[e._v("CPU usage")])]),e._v(" "),a("p",[e._v("As previously calculated, the pub/sub server pushes about 14 million updates per second to subscribers. Even though it is not easy 1o estimate with any accuracy how many messages a modern Redis server could push a second without actual benchmarking, it is safe to assume that a single Redis server will not be able to handie that 1oad. Let's pick a conservative number and assume that a modem server with a gigabit network could handle about 100,000 subscriber pushes per second. Given how small our location update messages are, this number is likely to be conservative. Using this conservative estimate, we will need to distribute the load among 14 million / 100000 = 140 Redis servers. Again, this number is likely 100 conservative, and the actual number of servers could be much lower.")]),e._v(" "),a("p",[e._v("From the math, we conclude that:")]),e._v(" "),a("ul",[a("li",[e._v("The bottieneck of Redis pub/sub server is the CPU usage, not the memory usage.")]),e._v(" "),a("li",[e._v("To support our scale, we need a distributed Redis pub/sub cluster.")])]),e._v(" "),a("p",[a("strong",[e._v("Distributed Redis pub/sub server cluster")])]),e._v(" "),a("p",[e._v("How do we distribute the channels to hundreds of Redis servers? The good news is that the channels are independent of each other. This makes it relatively easy to spread the channels among multiple pub/sub servers by sharding, based on the publisher's user ID. Practically speaking though, with 100s of pub/sub servers, we should go into a bit more detail on how this s done so that operationally it is somewhat manageable, as servers inevitably go down from time to time.")]),e._v(" "),a("p",[e._v("Here, we introduce a service discovery component to our design. There are many service discovery packages available, with etcd and Zookeeper  among the most popular ones. Our need for the service discovery component is very basic. We need these two features:")]),e._v(" "),a("ol",[a("li",[e._v("The ability to keep a list of servers in the service discovery component, and a simple Ul or API to update it Fundamentally, service discovery is a small key-value store for holding configuration data. Using Figure below as an\nexample, the key and value for the hash ring could look like this:")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('Key: /config/pub_sub.ring\nValue: [\'p_1",p.2", \'p_3", "p_4\']\n')])])]),a("ol",{attrs:{start:"2"}},[a("li",[e._v('The ability for clients (in this case, the WebSocket servers) to subscribe to any updates to the “Value™ (Redis pub/sub servers). Under the “Key" mentioned in point 1, we store a hash ring of all the active Redis pub/sub servers in the service discovery component. The hash ring is used by the publishers and subscribers of the Redis pub/sub servers to\ndetermine the pub/sub server to talk to for each channel. For example, channel 2 lives in Redis pub/sub server 1 in\nFigure below.')])]),e._v(" "),a("p",[a("img",{attrs:{src:s(636),alt:"img"}}),e._v("\nFigure 9")]),e._v(" "),a("p",[e._v("Figure below shows what happens when a WebSocket server publishes a location update to a user’s channel."),a("br"),e._v(" "),a("img",{attrs:{src:s(637),alt:"img"}})]),e._v(" "),a("ol",[a("li",[a("p",[e._v("The WebSocket server consults the hash ring to determine the Redis pub/sub server to write to. The source of truth is stored in service discovery, but for efficiency, a copy of the hash ring could be cached on each ‘WebSocket server. The WebSocket server subscribes to any updates on the hash ring to keep its local in-memory copy up to date.")])]),e._v(" "),a("li",[a("p",[e._v("WebSocket server publishes the location update to the user's channel on that Redis pub/sub server.")])])]),e._v(" "),a("p",[e._v("Subscribing to a channel for location updates uses the same mechanism.")]),e._v(" "),a("p",[a("strong",[e._v("Scaling considerations for Redis pub/sub servers")])]),e._v(" "),a("p",[e._v("How should we scale the Redis publ/sub server cluster? Should we scale it up and down daily, based on traffic\npattems? This is a very common practice for stateless servers because it is low risk and saves costs. To answer these\nquestions, let's examine some of the properties of the Redis pub/sub server cluster.")]),e._v(" "),a("ol",[a("li",[a("p",[e._v("The messages sent on a pubj/sub channel are not persisted in memory or on disk. They are sent to all subscribers of the channel and removed immediately after. If there are no subscribers, the messages are just dropped. In this sense, the data going through the pub/sub channel is stateless.")])]),e._v(" "),a("li",[a("p",[e._v("However, there are indeed states stored in the pub/sub servers for the channels. Specifically, the subscriber list for each channel is a key piece of the states tracked by the pub/sub servers. f a channel is moved, which could happen when the channel's pub/sub server is replaced, or if a new server is added or an old server removed on the hash ring, then every subscriber to the moved channel must know about it, 5o they could unsubscribe from the channel on the old server and resubscribe to the replacement channel on the new server. In this sense, a pub/sub server is stateful, and coordination with all subscribers to the server must be orchestrated to minimize service interruptions.")])])]),e._v(" "),a("p",[e._v("For these reasons, we should treat the Redis pub/sub cluster more like a stateful cluster, similar to how we would handle a storage cluster. With stateful clusters, scaling up or down has some operational overhead and risks, so it should be done with careful planning. The cluster is normally over-provisioned to make sure it can handie daily peak traffic with some comfortable headroom to avoid unnecessary resizing of the cluster.")]),e._v(" "),a("p",[e._v("When we inevitably have to scale, be mindful of these potential issues:")]),e._v(" "),a("ul",[a("li",[e._v("When we resize a cluster, many channels will be moved to different servers on the hash ring. When the service discovery component notifies all the WebSocket servers of the hash ring update, there will be a ton of resubscription requests.")]),e._v(" "),a("li",[e._v("During these mass resubscription events, some location updates might be missed by the clients. Although occasional misses are acceptable for our design, we should minimize the occurrences.")]),e._v(" "),a("li",[e._v("Because of the potential interruptions, resizing should be done when usage is at its lowest in the day.")])]),e._v(" "),a("p",[e._v("How is resizing actually done? It is quite simple. Follow these steps:")]),e._v(" "),a("ul",[a("li",[e._v("Determine the new ring size, and if scaling up, provision enough new servers.")]),e._v(" "),a("li",[e._v("Update the keys of the hash ring with the new content.")]),e._v(" "),a("li",[e._v("Monitor your dashboard. There should be some spike in CPU usage in the WebSocket cluster.\nUsing the hash ring from Figure 9 above, if we were to add 2 new nodes, say, p_S, and p_6, the hash ring would be\nupdated like this:")])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('Old: ["p_1","p_2", "p_3", "p_4"]\nNew: ["p_1","p_2", "p_3", "p_4", "p_5", "p_6"]\n')])])]),a("p",[a("strong",[e._v("Operational considerations for Redis pub/sub servers")])]),e._v(" "),a("p",[e._v("The operational sk of replacing an existing Redis pub/sub server is much, much lower. It does not cause a large number of channels to be moved. Only the channels on the server being replaced will need to be handled. This is good because servers inevitably go down and need to be replaced reqularly.")]),e._v(" "),a("p",[e._v("When a pub/sub server goes down, the monitoring software should alert the on-call operator. Precisely how the monitoring software monitors the health of a pub/sub server is beyond the scope of this chapter, so it is not covered. The on-call operator updates the hash ring key in service discovery to replace the dead node with a fresh standby node. The WebSocket servers are notified about the update and each one then notifies its connection handlers to re-subscribe to the channels on the new pub/sub server. Each WebSocket handler keeps a list of all channes it has subscribed to, and upon receiving the notification from the server, it checks each channel against the hash ring to determine if a channel needs to be re-subscribed on a new server.")]),e._v(" "),a("p",[e._v("Using the hash ring from Figure 9 above, if "),a("strong",[e._v("p_1")]),e._v(" went down, and we replace it with "),a("strong",[e._v("p1_new")]),e._v(", the hash ring would be\nupdated like so:")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('Old: ["p_1","p_2", "p_3", "p_4"]\nNew: ["p_1_new","p_2", "p_3", "p_4"]\n')])])]),a("p",[a("img",{attrs:{src:s(638),alt:"imng"}})]),e._v(" "),a("h3",{attrs:{id:"adding-removing-friends"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#adding-removing-friends"}},[e._v("#")]),e._v(" Adding/removing friends")]),e._v(" "),a("p",[e._v("What should the dlient do when the user adds or removes a friend? When a new friend is added, the client's WebSocket connection handler on the server needs to be notified, so it can subscribe to the new friend’s pub/sub channel.")]),e._v(" "),a("p",[e._v("Since the “nearby friends\" feature is within the ecosystem of a larger app, we can assume that the “nearby friends™ feature could register a callback on the mobile client whenever a new friend is added. The callback, upon invocation, sends a message to the WebSocket server to subscribe to the new friend's pub/sub channel. The WebSocket server also returns a message containing the new friend's latest location and timestamp, if they are active.")]),e._v(" "),a("p",[e._v("Likewise, the client could register a callback in the application whenever a friend is removed. The callback would send a message to the WebSocket server to unsubscribe from the friend’s pub/sub channel.")]),e._v(" "),a("p",[e._v("This subscribe/unsubscribe callback could also be used whenever a friend has opted in or out of the location update.")]),e._v(" "),a("h3",{attrs:{id:"users-with-many-friends"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#users-with-many-friends"}},[e._v("#")]),e._v(" Users with many friends")]),e._v(" "),a("p",[e._v("It is worth discussing whether a user with many friends could cause performance hotspots in our design. We assume here that there is a hard cap on the number of friends. (Facebook has a cap of 5,000 friends, for example). Friendships are bi-directional. We are not talking about a follower model in which a celebrity could have millions of followers.")]),e._v(" "),a("p",[e._v("In 2 scenario with thousands of friends, the pub/sub subscribers will be scattered among the many WebSocket servers in the dluster. The update load would be spread among them and it's unlikely to cause any hotspots.")]),e._v(" "),a("p",[e._v("The user would place a bit more load on the pub/sub server where their channel lives. Since there are over 100 pub/sub servers, these “whale™ users would be spread out among the pub/sub servers and the incremental load should not overwhelm any single one.")]),e._v(" "),a("h3",{attrs:{id:"nearby-random-person"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nearby-random-person"}},[e._v("#")]),e._v(" Nearby random person")]),e._v(" "),a("p",[e._v("You might call this section an extra credit, as it's not in the initial functional requirements. What if the interviewer wants to update the design to show random people who opted-in to location-sharing?")]),e._v(" "),a("p",[e._v("One way to do this while leveraging our design is to add a pool of pub/sub channels by geohash. (See the Proximity Service chapter for details on geohash). As shown in Figure 12, an area is divided into four geohash grids and a channel is created for each grid.")]),e._v(" "),a("p",[a("img",{attrs:{src:s(639),alt:"img"}})]),e._v(" "),a("p",[e._v("Anyone within the grid subscribes to the same channel. Let's take grid 9g8znd for example as shown in Figure below.")]),e._v(" "),a("p",[a("img",{attrs:{src:s(640),alt:"img"}})]),e._v(" "),a("ol",[a("li",[e._v("Here, when user 2 updates their location, the WebSocket connection handler computes the user's geohash ID 2nd sends the location to the channel for that geohash.")]),e._v(" "),a("li",[e._v("Anyone nearby who subscribes to the channel (exclude the sender) wil receive a location update message.")])]),e._v(" "),a("p",[e._v("To handle people who are close to the border of a geohash grid, every dient could subscribe to the geohash the user is in and the eight surounding geohash grids. An example with allnine geohash grids highlighted is shown in Figure below.")]),e._v(" "),a("p",[a("img",{attrs:{src:s(641),alt:"img"}})]),e._v(" "),a("h4",{attrs:{id:"alternative-to-redis-pub-sub"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#alternative-to-redis-pub-sub"}},[e._v("#")]),e._v(" Alternative to Redis pub/sub")]),e._v(" "),a("p",[e._v("Is there any good alternative to using Redis pub/sub as the routing layer? The answer is a resounding yes. Erlang is a great solution for this particular problem. We would argue that Erlang is a better solution than the Redis pub/sub proposed above. However, Erlang is quite a niche, and hiring good Erlang programmers is hard. But if your team has Erlang expertise, this is a great option.")]),e._v(" "),a("p",[e._v("So, why Erlang? Erlang is a general programming language and runtime environment built for highly distributed and concurrent applications. When we say Erlang here, we specifically talk about the Erlang ecosystem itself. This includes the language component (Erlang or Elixir) and the runtime environment and libraries (the Erlang virtual machine called BEAM and the Erlang runtime libraries called OTP).")]),e._v(" "),a("p",[e._v("The power of Erlang lies in its lightweight processes. An Erlang process is an entity running on the BEAM VM. It is several orders of magnitude cheaper to create than a Linux process. A minimal Erlang process takes about 300 bytes, and we can have millions of these processes on a single modern server. If there is no work to do in an Erlang process, it just sits there without using any CPU cycles at all. In other words, it is extremely cheap to model each of the 10 million active users in our design as an individual Erlang process.")]),e._v(" "),a("p",[e._v("Erlang is also very easy to distribute among many Erlang servers. The operational overhead is very low, and there are great tools to support debugging live production issues, safely. The deployment tools are also very strong.")]),e._v(" "),a("p",[e._v("How would we use Erlang in our design? We would implement the WebSocket service in Erlang, and also replace the entire cluster of Redis pub/sub with a distributed Erlang application. In this application, each user is modeled as an Erlang process. The user process would receive updates from the WebSocket server when a user’s location is updated by the client. The user process also subscribes to updates from the Erlang processes of the user's friends. Subscription is native in Erlang/OTP and it's easy to build. This forms a mesh of connections that would efficiently\nroute location updates from one user to many friends.")]),e._v(" "),a("h2",{attrs:{id:"step-4-wrap-up"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#step-4-wrap-up"}},[e._v("#")]),e._v(" Step 4 - Wrap Up")]),e._v(" "),a("p",[e._v("In this chapter, we presented a design that supports a nearby friends feature. Conceptually, we want to design a\nsystem that can efficiently pass location updates from one user to their friends.\nSome of the core components include:")]),e._v(" "),a("ul",[a("li",[e._v("WebSocket: real-time communication between diients and the server.")]),e._v(" "),a("li",[e._v("Redis: fast read and write of location data.")]),e._v(" "),a("li",[e._v("Redis pub/sub: routing layer to direct location updates from one user to all the online friends.")])]),e._v(" "),a("p",[e._v("We first came up with a high-level design at a lower scale and then discussed challenges that arise as the scale increases. We explored how to scale the following:")]),e._v(" "),a("ul",[a("li",[e._v("Restful API servers")]),e._v(" "),a("li",[e._v("WebSocket servers")]),e._v(" "),a("li",[e._v("Data layer")]),e._v(" "),a("li",[e._v("Redis pub/sub servers")]),e._v(" "),a("li",[e._v("Altemative to Redis pub/sub")])]),e._v(" "),a("p",[e._v("Finally, we discussed potential bottienecks when a user has many friends and we proposed a design for the “nearby random person” feature.")]),e._v(" "),a("h2",{attrs:{id:"summary"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#summary"}},[e._v("#")]),e._v(" Summary")]),e._v(" "),a("p",[a("img",{attrs:{src:s(642),alt:"img"}})])])}),[],!1,null,null,null);t.default=i.exports},629:function(e,t,s){e.exports=s.p+"assets/img/f2.9cae2f95.png"},630:function(e,t,s){e.exports=s.p+"assets/img/f3.d18ed8eb.png"},631:function(e,t,s){e.exports=s.p+"assets/img/f4.a9fe73df.png"},632:function(e,t,s){e.exports=s.p+"assets/img/f5.f99d0833.png"},633:function(e,t,s){e.exports=s.p+"assets/img/f6.4a12b927.png"},634:function(e,t,s){e.exports=s.p+"assets/img/f7.d9ed1dc3.png"},635:function(e,t,s){e.exports=s.p+"assets/img/f8.53e89476.png"},636:function(e,t,s){e.exports=s.p+"assets/img/f9.46f9f257.png"},637:function(e,t,s){e.exports=s.p+"assets/img/f10.79c370cd.png"},638:function(e,t,s){e.exports=s.p+"assets/img/f11.63ac50d1.png"},639:function(e,t,s){e.exports=s.p+"assets/img/f12.9a453bd8.png"},640:function(e,t,s){e.exports=s.p+"assets/img/f13.383808c3.png"},641:function(e,t,s){e.exports=s.p+"assets/img/f14.c0ab5fde.png"},642:function(e,t,s){e.exports=s.p+"assets/img/f15.2184d595.png"}}]);