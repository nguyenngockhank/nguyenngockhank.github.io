(window.webpackJsonp=window.webpackJsonp||[]).push([[300],{908:function(e,t,o){"use strict";o.r(t);var n=o(7),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"_12-why-write-comments-the-four-excuses"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_12-why-write-comments-the-four-excuses"}},[e._v("#")]),e._v(" 12. Why Write Comments? The Four Excuses")]),e._v(" "),o("p",[e._v("In-code documentation plays a crucial role in software design. Comments\nare essential to help developers understand a system and work efficiently,\nbut the role of comments goes beyond this. Documentation also plays an\nimportant role in abstraction; without comments, you can’t hide\ncomplexity. Finally, the process of writing comments, if done correctly,\nwill actually improve a system’s design. Conversely, a good software\ndesign loses much of its value if it is poorly documented.")]),e._v(" "),o("p",[e._v("Unfortunately, this view is not universally shared. A significant\nfraction of production code contains essentially no comments. Many\ndevelopers think that comments are a waste of time; others see the value in\ncomments, but somehow never get around to writing them. Fortunately,\nmany development teams recognize the value of documentation, and it\nfeels like the prevalence of these teams is gradually increasing. However,\neven in teams that encourage documentation, comments are often viewed\nas drudge work and many developers don’t understand how to write them,\nso the resulting documentation is often mediocre. Inadequate\ndocumentation creates a huge and unnecessary drag on software\ndevelopment.")]),e._v(" "),o("p",[e._v("In this chapter I will discuss the excuses developers use to avoid\nwriting comments, and the reasons why comments really do matter.\nChapter 13 will then describe how to write good comments and the next\nfew chapters after that will discuss related issues such as choosing variable\nnames and how to use documentation to improve a system’s design. I hope\nthese chapters will convince you of three things: good comments can make\na big difference in the overall quality of software; it isn’t hard to write\ngood comments; and (this may be hard to believe) writing comments can\nactually be fun.")]),e._v(" "),o("p",[e._v("When developers don’t write comments, they usually justify their\nbehavior with one or more of the following excuses:\n“Good code is self-documenting.”\n“I don’t have time to write comments.”\n“Comments get out of date and become misleading.”\n“The comments I have seen are all worthless; why bother?” In the\nsections below I will address each of these excuses in turn.")]),e._v(" "),o("h2",{attrs:{id:"_12-1-good-code-is-self-documenting"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_12-1-good-code-is-self-documenting"}},[e._v("#")]),e._v(" 12.1  Good code is self-documenting")]),e._v(" "),o("p",[e._v("Some people believe that if code is written well, it is so obvious that no\ncomments are needed. This is a delicious myth, like a rumor that ice\ncream is good for your health: we’d really like to believe it! Unfortunately,\nit’s simply not true. To be sure, there are things you can do when writing\ncode to reduce the need for comments, such as choosing good variable\nnames (see Chapter 14). Nonetheless, there is still a significant amount of\ndesign information that can’t be represented in code. For example, only a\nsmall part of a class’s interface, such as the signatures of its methods, can\nbe specified formally in the code. The informal aspects of an interface,\nsuch as a high-level description of what each method does or the meaning\nof its result, can only be described in comments. There are many other\nexamples of things that can’t be described in the code, such as the\nrationale for a particular design decision, or the conditions under which it\nmakes sense to call a particular method.")]),e._v(" "),o("p",[e._v("Some developers argue that if others want to know what a method\ndoes, they should just read the code of the method: this will be more\naccurate than any comment. It’s possible that a reader could deduce the\nabstract interface of the method by reading its code, but it would be time-\nconsuming and painful. In addition, if you write code with the expectation\nthat users will read method implementations, you will try to make each\nmethod as short as possible, so that it’s easy to read. If the method does\nanything nontrivial, you will break it up into several smaller methods. This\nwill result in a large number of shallow methods. Furthermore, it doesn’t\nreally make the code easier to read: in order to understand the behavior of\nthe top-level method, readers will probably need to understand the")]),e._v(" "),o("p",[e._v("behaviors of the nested methods. For large systems it isn’t practical for\nusers to read the code to learn the behavior.")]),e._v(" "),o("p",[e._v("Moreover, comments are fundamental to abstractions. Recall from\nChapter 4 that the goal of abstractions is to hide complexity: an\nabstraction is a simplified view of an entity, which preserves essential\ninformation but omits details that can safely be ignored. If users must\nread the code of a method in order to use it, then there is no\nabstraction: all of the complexity of the method is exposed. Without\ncomments, the only abstraction of a method is its declaration, which\nspecifies its name and the names and types of its arguments and results.\nThe declaration is missing too much essential information to provide a\nuseful abstraction by itself. For example, a method to extract a substring\nmight have two arguments, start and end, indicating the range of")]),e._v(" "),o("p",[e._v("characters to extract. From the declaration alone, it isn’t possible to tell\nwhether the extracted substring will include the character indicated by end,\nor what happens if start > end. Comments allow us to capture the")]),e._v(" "),o("p",[e._v("additional information that callers need, thereby completing the simplified\nview while hiding implementation details. It’s also important that\ncomments are written in a human language such as English; this makes\nthem less precise than code, but it provides more expressive power, so we\ncan create simple, intuitive descriptions. If you want to use abstractions to\nhide complexity, comments are essential.")]),e._v(" "),o("h2",{attrs:{id:"_12-2-i-don-t-have-time-to-write-comments"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_12-2-i-don-t-have-time-to-write-comments"}},[e._v("#")]),e._v(" 12.2  I don’t have time to write comments")]),e._v(" "),o("p",[e._v("It’s tempting to prioritize comments lower than other development tasks.\nGiven a choice between adding a new feature and documenting an existing\nfeature, it seems logical to choose the new feature. However, software\nprojects are almost always under time pressure, and there will always be\nthings that seem higher priority than writing comments. Thus, if you allow\ndocumentation to be de-prioritized, you’ll end up with no documentation.")]),e._v(" "),o("p",[e._v("The counter-argument to this excuse is the investment mindset\ndiscussed on page 15. If you want a clean software structure, which will\nallow you to work efficiently over the long-term, then you must take some\nextra time up front in order to create that structure. Good comments make")]),e._v(" "),o("p",[e._v("a huge difference in the maintainability of software, so the effort spent on\nthem will pay for itself quickly. Furthermore, writing comments needn’t\ntake a lot of time. Ask yourself how much of your development time you\nspend typing in code (as opposed to designing, compiling, testing, etc.),\nassuming you don’t include any comments; I doubt that the answer is more\nthan 10%. Now suppose that you spend as much time typing comments as\ntyping code; this should be a safe upper bound. With these assumptions,\nwriting good comments won’t add more than about 10% to your\ndevelopment time. The benefits of having good documentation will\nquickly offset this cost.")]),e._v(" "),o("p",[e._v("Furthermore, many of the most important comments are those related\nto abstractions, such as the top-level documentation for classes and\nmethods. Chapter 15 will argue that these comments should be written as\npart of the design process, and that the act of writing the documentation\nserves as an important design tool that improves the overall design. These\ncomments pay for themselves immediately.")]),e._v(" "),o("h2",{attrs:{id:"_12-3-comments-get-out-of-date-and-become-misleading"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_12-3-comments-get-out-of-date-and-become-misleading"}},[e._v("#")]),e._v(" 12.3  Comments get out of date and become misleading")]),e._v(" "),o("p",[e._v("Comments do sometimes get out of date, but this need not be a major\nproblem in practice. Keeping documentation up-to-date does not require\nan enormous effort. Large changes to the documentation are only required\nif there have been large changes to the code, and the code changes will\ntake more time than the documentation changes. Chapter 16 discusses how\nto organize documentation so that it is as easy as possible to keep it\nupdated after code modifications (the key ideas are to avoid duplicated documentation and keep the documentation close to the corresponding code). Code reviews provide a great mechanism for detecting and fixing\nstale comments.")]),e._v(" "),o("h2",{attrs:{id:"_12-4-all-the-comments-i-have-seen-are-worthless"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_12-4-all-the-comments-i-have-seen-are-worthless"}},[e._v("#")]),e._v(" 12.4  All the comments I have seen are worthless")]),e._v(" "),o("p",[e._v("Of the four excuses, this is probably the one with the most merit. Every software developer has seen comments that provide no useful information, and most existing documentation is so-so at best. Fortunately, this problem\nis solvable; writing solid documentation is not hard, once you know how.")]),e._v(" "),o("p",[e._v("The next chapters will lay out a framework for how to write good documentation and maintain it over time.")]),e._v(" "),o("h2",{attrs:{id:"_12-5-benets-of-well-written-comments"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_12-5-benets-of-well-written-comments"}},[e._v("#")]),e._v(" 12.5  Benets of well-written comments")]),e._v(" "),o("p",[e._v("Now that I have discussed (and, hopefully, debunked) the arguments against writing comments, let’s consider the benefits that you will get from good comments. The overall idea behind comments is to capture\ninformation that was in the mind of the designer but couldn’t be represented in the code. This information ranges from low-level details, such as a hardware quirk that motivates a particularly tricky piece of code,\nup to high-level concepts such as the rationale for a class. When other\ndevelopers come along later to make modifications, the comments will\nallow them to work more quickly and accurately. Without documentation,\nfuture developers will have to rederive or guess at the developer’s original\nknowledge; this will take additional time, and there is a risk of bugs if the\nnew developer misunderstands the original designer’s intentions.\nComments are valuable even when the original designer is the one making\nthe changes: if it has been more than a few weeks since you last worked in\na piece of code, you will have forgotten many of the details of the original\ndesign.")]),e._v(" "),o("p",[o("RouterLink",{attrs:{to:"/kungfu/philosophy/c2.html"}},[e._v("Chapter 2")]),e._v(" described three ways in which complexity manifests itself in\nsoftware systems:\nChange amplification: a seemingly simple change requires code modifications in many places.\nCognitive load: in order to make a change, the developer must accumulate a large amount of information.\nUnknown unknowns: it is unclear what code needs to be modified, or what information must be considered in order to make those\nmodifications.")],1),e._v(" "),o("p",[e._v("Good documentation helps with the last two of these issues.\nDocumentation can reduce cognitive load by providing developers with the\ninformation they need to make changes and by making it easy for\ndevelopers to ignore information that is irrelevant. Without adequate\ndocumentation, developers may have to read large amounts of code to\nreconstruct what was in the designer’s mind. Documentation can also reduce the unknown unknowns by clarifying the structure of the system, so that it is clear what information and code is relevant for any given change.")]),e._v(" "),o("p",[o("RouterLink",{attrs:{to:"/kungfu/philosophy/c2.html"}},[e._v("Chapter 2")]),e._v("  pointed out that the primary causes of complexity are dependencies and obscurity. Good documentation can clarify dependencies, and it fills in gaps to eliminate obscurity.")],1),e._v(" "),o("p",[e._v("The next few chapters will show you how to write good documentation.\nThey will also discuss how to integrate documentation-writing into the design process so that it improves the design of your software.")])])}),[],!1,null,null,null);t.default=a.exports}}]);