(window.webpackJsonp=window.webpackJsonp||[]).push([[303],{915:function(e,t,n){"use strict";n.r(t);var a=n(7),i=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_15-junit-internals"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_15-junit-internals"}},[e._v("#")]),e._v(" 15. JUnit Internals")]),e._v(" "),n("p",[e._v("JUnit is one of the most famous of all Java frameworks. As frameworks go, it is simple in\nconception, precise in definition, and elegant in implementation. But what does the code\nlook like? In this chapter we’ll critique an example drawn from the JUnit framework.")]),e._v(" "),n("p",[e._v("252 "),n("strong",[e._v("Chapter 15: JUnit Internals")])]),e._v(" "),n("h2",{attrs:{id:"the-junit-framework"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#the-junit-framework"}},[e._v("#")]),e._v(" The JUnit Framework ...")]),e._v(" "),n("p",[e._v("JUnit has had many authors, but it began with Kent Beck and Eric Gamma together on a\nplane to Atlanta. Kent wanted to learn Java, and Eric wanted to learn about Kent’s Small-\ntalk testing framework. “What could be more natural to a couple of geeks in cramped\nquarters than to pull out our laptops and start coding?”^1 After three hours of high-altitude\nwork, they had written the basics of JUnit.")]),e._v(" "),n("p",[e._v("The module we’ll look at is the clever bit of code that helps identify string compari-\nson errors. This module is called ComparisonCompactor. Given two strings that differ,\nsuch as ABCDEandABXDE,it will expose the difference by generating a string such as\n<...B[X]D...>.")]),e._v(" "),n("p",[e._v("I could explain it further, but the test cases do a better job. So take a look at Listing 15-1\nand you will understand the requirements of this module in depth. While you are at it,\ncritique the structure of the tests. Could they be simpler or more obvious?")]),e._v(" "),n("ol",[n("li",[n("em",[e._v("JUnit Pocket Guide")]),e._v(" , Kent Beck, O’Reilly, 2004, p. 43.")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('Listing 15-1\nComparisonCompactorTest.java\npackage junit.tests.framework;\nimport junit.framework.ComparisonCompactor;\nimport junit.framework.TestCase;\npublic class ComparisonCompactorTest extends TestCase {\npublic void testMessage() {\nString failure= new ComparisonCompactor(0, "b", "c").compact("a");\nassertTrue("a expected:<[b]> but was:<[c]>".equals(failure));\n}\npublic void testStartSame() {\nString failure= new ComparisonCompactor(1, "ba", "bc").compact(null);\nassertEquals("expected:<b[a]> but was:<b[c]>", failure);\n}\npublic void testEndSame() {\nString failure= new ComparisonCompactor(1, "ab", "cb").compact(null);\nassertEquals("expected:<[a]b> but was:<[c]b>", failure);\n}\npublic void testSame() {\nString failure= new ComparisonCompactor(1, "ab", "ab").compact(null);\nassertEquals("expected:<ab> but was:<ab>", failure);\n}\npublic void testNoContextStartAndEndSame() {\nString failure= new ComparisonCompactor(0, "abc", "adc").compact(null);\nassertEquals("expected:<...[b]...> but was:<...[d]...>", failure);\n}\n')])])]),n("p",[n("strong",[e._v("The JUnit Framework")]),e._v(" 253")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public void testStartAndEndContext() {\nString failure= new ComparisonCompactor(1, "abc", "adc").compact(null);\nassertEquals("expected:<a[b]c> but was:<a[d]c>", failure);\n}\npublic void testStartAndEndContextWithEllipses() {\nString failure=\nnew ComparisonCompactor(1, "abcde", "abfde").compact(null);\nassertEquals("expected:<...b[c]d...> but was:<...b[f]d...>", failure);\n}\npublic void testComparisonErrorStartSameComplete() {\nString failure= new ComparisonCompactor(2, "ab", "abc").compact(null);\nassertEquals("expected:<ab[]> but was:<ab[c]>", failure);\n}\npublic void testComparisonErrorEndSameComplete() {\nString failure= new ComparisonCompactor(0, "bc", "abc").compact(null);\nassertEquals("expected:<[]...> but was:<[a]...>", failure);\n}\npublic void testComparisonErrorEndSameCompleteContext() {\nString failure= new ComparisonCompactor(2, "bc", "abc").compact(null);\nassertEquals("expected:<[]bc> but was:<[a]bc>", failure);\n}\npublic void testComparisonErrorOverlapingMatches() {\nString failure= new ComparisonCompactor(0, "abc", "abbc").compact(null);\nassertEquals("expected:<...[]...> but was:<...[b]...>", failure);\n}\npublic void testComparisonErrorOverlapingMatchesContext() {\nString failure= new ComparisonCompactor(2, "abc", "abbc").compact(null);\nassertEquals("expected:<ab[]c> but was:<ab[b]c>", failure);\n}\npublic void testComparisonErrorOverlapingMatches2() {\nString failure= new ComparisonCompactor(0, "abcdde",\n"abcde").compact(null);\nassertEquals("expected:<...[d]...> but was:<...[]...>", failure);\n}\npublic void testComparisonErrorOverlapingMatches2Context() {\nString failure=\nnew ComparisonCompactor(2, "abcdde", "abcde").compact(null);\nassertEquals("expected:<...cd[d]e> but was:<...cd[]e>", failure);\n}\npublic void testComparisonErrorWithActualNull() {\nString failure= new ComparisonCompactor(0, "a", null).compact(null);\nassertEquals("expected:<a> but was:<null>", failure);\n}\npublic void testComparisonErrorWithActualNullContext() {\nString failure= new ComparisonCompactor(2, "a", null).compact(null);\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Listing 15-1 (continued)\nComparisonCompactorTest.java\n")])])]),n("p",[e._v("254 "),n("strong",[e._v("Chapter 15: JUnit Internals")])]),e._v(" "),n("p",[e._v("I ran a code coverage analysis on the ComparisonCompactorusing these tests. The code\nis 100 percent covered. Every line of code, every ifstatement and forloop, is executed by\nthe tests. This gives me a high degree of confidence that the code works and a high degree\nof respect for the craftsmanship of the authors.")]),e._v(" "),n("p",[e._v("The code for ComparisonCompactoris in Listing 15-2. Take a moment to look over this\ncode. I think you’ll find it to be nicely partitioned, reasonably expressive, and simple in\nstructure. Once you are done, then we’ll pick the nits together.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('assertEquals("expected:<a> but was:<null>", failure);\n}\npublic void testComparisonErrorWithExpectedNull() {\nString failure= new ComparisonCompactor(0, null, "a").compact(null);\nassertEquals("expected:<null> but was:<a>", failure);\n}\npublic void testComparisonErrorWithExpectedNullContext() {\nString failure= new ComparisonCompactor(2, null, "a").compact(null);\nassertEquals("expected:<null> but was:<a>", failure);\n}\npublic void testBug609972() {\nString failure= new ComparisonCompactor(10, "S&P500", "0").compact(null);\nassertEquals("expected:<[S&P50]0> but was:<[]0>", failure);\n}\n}\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('Listing 15-2\nComparisonCompactor.java (Original)\npackage junit.framework;\npublic class ComparisonCompactor {\nprivate static final String ELLIPSIS = "...";\nprivate static final String DELTA_END = "]";\nprivate static final String DELTA_START = "[";\nprivate int fContextLength;\nprivate String fExpected;\nprivate String fActual;\nprivate int fPrefix;\nprivate int fSuffix;\npublic ComparisonCompactor(int contextLength,\nString expected,\nString actual) {\nfContextLength = contextLength;\nfExpected = expected;\nfActual = actual;\n}\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Listing 15-1 (continued)\nComparisonCompactorTest.java\n")])])]),n("p",[n("strong",[e._v("The JUnit Framework")]),e._v(" 255")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('public String compact(String message) {\nif (fExpected == null || fActual == null || areStringsEqual())\nreturn Assert.format(message, fExpected, fActual);\nfindCommonPrefix();\nfindCommonSuffix();\nString expected = compactString(fExpected);\nString actual = compactString(fActual);\nreturn Assert.format(message, expected, actual);\n}\nprivate String compactString(String source) {\nString result = DELTA_START +\nsource.substring(fPrefix, source.length() -\nfSuffix + 1) + DELTA_END;\nif (fPrefix > 0)\nresult = computeCommonPrefix() + result;\nif (fSuffix > 0)\nresult = result + computeCommonSuffix();\nreturn result;\n}\nprivate void findCommonPrefix() {\nfPrefix = 0;\nint end = Math.min(fExpected.length(), fActual.length());\nfor (; fPrefix < end; fPrefix++) {\nif (fExpected.charAt(fPrefix) != fActual.charAt(fPrefix))\nbreak;\n}\n}\nprivate void findCommonSuffix() {\nint expectedSuffix = fExpected.length() - 1;\nint actualSuffix = fActual.length() - 1;\nfor (;\nactualSuffix >= fPrefix && expectedSuffix >= fPrefix;\nactualSuffix--, expectedSuffix--) {\nif (fExpected.charAt(expectedSuffix) != fActual.charAt(actualSuffix))\nbreak;\n}\nfSuffix = fExpected.length() - expectedSuffix;\n}\nprivate String computeCommonPrefix() {\nreturn (fPrefix > fContextLength? ELLIPSIS : "") +\nfExpected.substring(Math.max(0, fPrefix - fContextLength),\nfPrefix);\n}\nprivate String computeCommonSuffix() {\nint end = Math.min(fExpected.length() - fSuffix + 1 + fContextLength,\nfExpected.length());\nreturn fExpected.substring(fExpected.length() - fSuffix + 1, end) +\n(fExpected.length() - fSuffix + 1 < fExpected.length() -\nfContextLength? ELLIPSIS : "");\n}\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Listing 15-2 (continued)\nComparisonCompactor.java (Original)\n")])])]),n("p",[e._v("256 "),n("strong",[e._v("Chapter 15: JUnit Internals")])]),e._v(" "),n("p",[e._v("You might have a few complaints about this module. There are some long expressions\nand some strange +1s and so forth. But overall this module is pretty good. After all, it\nmight have looked like Listing 15-3.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("private boolean areStringsEqual() {\nreturn fExpected.equals(fActual);\n}\n}\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('Listing 15-3\nComparisonCompator.java (defactored)\npackage junit.framework;\npublic class ComparisonCompactor {\nprivate int ctxt;\nprivate String s1;\nprivate String s2;\nprivate int pfx;\nprivate int sfx;\npublic ComparisonCompactor(int ctxt, String s1, String s2) {\nthis.ctxt = ctxt;\nthis.s1 = s1;\nthis.s2 = s2;\n}\npublic String compact(String msg) {\nif (s1 == null || s2 == null || s1.equals(s2))\nreturn Assert.format(msg, s1, s2);\npfx = 0;\nfor (; pfx < Math.min(s1.length(), s2.length()); pfx++) {\nif (s1.charAt(pfx) != s2.charAt(pfx))\nbreak;\n}\nint sfx1 = s1.length() - 1;\nint sfx2 = s2.length() - 1;\nfor (; sfx2 >= pfx && sfx1 >= pfx; sfx2--, sfx1--) {\nif (s1.charAt(sfx1) != s2.charAt(sfx2))\nbreak;\n}\nsfx = s1.length() - sfx1;\nString cmp1 = compactString(s1);\nString cmp2 = compactString(s2);\nreturn Assert.format(msg, cmp1, cmp2);\n}\nprivate String compactString(String s) {\nString result =\n"[" + s.substring(pfx, s.length() - sfx + 1) + "]";\nif (pfx > 0)\nresult = (pfx > ctxt? "..." : "") +\ns1.substring(Math.max(0, pfx - ctxt), pfx) + result;\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Listing 15-2 (continued)\nComparisonCompactor.java (Original)\n")])])]),n("p",[n("strong",[e._v("The JUnit Framework")]),e._v(" 257")]),e._v(" "),n("p",[e._v("Even though the authors left this module in very good shape, the "),n("em",[e._v("Boy Scout Rule")]),e._v("^2 tells\nus we should leave it cleaner than we found it. So, how can we improve on the original\ncode in Listing 15-2?")]),e._v(" "),n("p",[e._v("The first thing I don’t care for is the fprefix for the member variables [N6]. Today’s\nenvironments make this kind of scope encoding redundant. So let’s eliminate all the f’s.")]),e._v(" "),n("p",[e._v("private int contextLength;\nprivate String expected;\nprivate String actual;\nprivate int prefix;\nprivate int suffix;\nNext, we have an unencapsulated conditional at the beginning of the compactfunction\n[G28].")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public String compact(String message) {\nif (expected == null || actual == null || areStringsEqual())\nreturn Assert.format(message, expected, actual);\nfindCommonPrefix();\nfindCommonSuffix();\nString expected = compactString(this.expected);\nString actual = compactString(this.actual);\nreturn Assert.format(message, expected, actual);\n}\n")])])]),n("p",[e._v("This conditional should be encapsulated to make our intent clear. So let’s extract a method\nthat explains it.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("public String compact(String message) {\nif ( shouldNotCompact() )\nreturn Assert.format(message, expected, actual);\nfindCommonPrefix();\nfindCommonSuffix();\nString expected = compactString(this.expected);\nString actual = compactString(this.actual);\nreturn Assert.format(message, expected, actual);\n}\n")])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('if (sfx > 0) {\nint end = Math.min(s1.length() - sfx + 1 + ctxt, s1.length());\nresult = result + (s1.substring(s1.length() - sfx + 1, end) +\n(s1.length() - sfx + 1 < s1.length() - ctxt? "..." : ""));\n}\nreturn result;\n}\n}\n')])])]),n("ol",{attrs:{start:"2"}},[n("li",[e._v("See “The Boy Scout Rule” on page 14.")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Listing 15-3 (continued)\nComparisonCompator.java (defactored)\n")])])]),n("p",[e._v("258 "),n("strong",[e._v("Chapter 15: JUnit Internals")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("private boolean shouldNotCompact() {\nreturn expected == null || actual == null || areStringsEqual();\n}\nI don’t much care for the this.expectedandthis.actualnotation in the compactfunc-\ntion. This happened when we changed the name of fExpectedtoexpected. Why are there\nvariables in this function that have the same names as the member variables? Don’t they\nrepresent something else [N4]? We should make the names unambiguous.\nString compactExpected = compactString( expected );\nString compactActual = compactString( actual );\nNegatives are slightly harder to understand than positives [G29]. So let’s turn that if\nstatement on its head and invert the sense of the conditional.\npublic String compact(String message) {\nif ( canBeCompacted ()) {\nfindCommonPrefix();\nfindCommonSuffix();\nString compactExpected = compactString(expected);\nString compactActual = compactString(actual);\nreturn Assert.format(message, compactExpected, compactActual);\n} else {\nreturn Assert.format(message, expected, actual);\n}\n}\nprivate boolean canBeCompacted () {\nreturn expected != null && actual != null &&! areStringsEqual();\n}\nThe name of the function is strange [N7]. Although it does compact the strings, it\nactually might not compact the strings if canBeCompactedreturns false. So naming this\nfunctioncompacthides the side effect of the error check. Notice also that the function\nreturns a formatted message, not just the compacted strings. So the name of the function\nshould really be formatCompactedComparison. That makes it read a lot better when taken\nwith the function argument:\npublic String formatCompactedComparison(String message) {\nThe body of the ifstatement is where the true compacting of the expected and actual\nstrings is done. We should extract that as a method named compactExpectedAndActual. How-\never, we want the formatCompactedComparisonfunction to do all the formatting. The\ncompact... function should do nothing but compacting [G30]. So let’s split it up as follows:\n...\nprivate String compactExpected;\nprivate String compactActual;\n...\npublic String formatCompactedComparison(String message) {\nif (canBeCompacted()) {\ncompactExpectedAndActual();\nreturn Assert.format(message, compactExpected, compactActual);\n} else {\n")])])]),n("p",[n("strong",[e._v("The JUnit Framework")]),e._v(" 259")]),e._v(" "),n("p",[e._v("return Assert.format(message, expected, actual);\n}\n}\nprivate void "),n("strong",[e._v("compactExpectedAndActual")]),e._v(" () {\nfindCommonPrefix();\nfindCommonSuffix();\ncompactExpected = compactString(expected);\ncompactActual = compactString(actual);\n}\nNotice that this required us to promote compactExpectedandcompactActualto member\nvariables. I don’t like the way that the last two lines of the new function return variables,\nbut the first two don’t. They aren’t using consistent conventions [G11]. So we should\nchangefindCommonPrefix and findCommonSuffix to return the prefix and suffix values.")]),e._v(" "),n("p",[e._v("private void compactExpectedAndActual() {\n"),n("strong",[e._v("prefixIndex =")]),e._v(" findCommonPrefix();\n"),n("strong",[e._v("suffixIndex =")]),e._v(" findCommonSuffix();\ncompactExpected = compactString(expected);\ncompactActual = compactString(actual);\n}\nprivate "),n("strong",[e._v("int")]),e._v(" findCommonPrefix() {\n"),n("strong",[e._v("int")]),e._v(" prefix "),n("strong",[e._v("Index")]),e._v(" = 0;\nint end = Math.min(expected.length(), actual.length());\nfor (; prefix "),n("strong",[e._v("Index")]),e._v(" < end; prefix "),n("strong",[e._v("Index")]),e._v(" ++) {\nif (expected.charAt(prefix "),n("strong",[e._v("Index")]),e._v(" ) != actual.charAt(prefix "),n("strong",[e._v("Index")]),e._v(" ))\nbreak;\n}\n"),n("strong",[e._v("return prefixIndex;")]),e._v("\n}\nprivate "),n("strong",[e._v("int")]),e._v(" findCommonSuffix() {\nint expectedSuffix = expected.length() - 1;\nint actualSuffix = actual.length() - 1;\nfor (; actualSuffix >= prefix "),n("strong",[e._v("Index")]),e._v(" && expectedSuffix >= prefixIndex;\nactualSuffix--, expectedSuffix--) {\nif (expected.charAt(expectedSuffix) != actual.charAt(actualSuffix))\nbreak;\n}\n"),n("strong",[e._v("return")]),e._v(" expected.length() - expectedSuffix;\n}\nWe should also change the names of the member variables to be a little more accurate\n[N1]; after all, they are both indices.")]),e._v(" "),n("p",[e._v("Careful inspection of findCommonSuffixexposes a "),n("em",[e._v("hidden temporal coupling")]),e._v(" [G31]; it\ndepends on the fact that prefixIndexis calculated by findCommonPrefix. If these two func-\ntions were called out of order, there would be a difficult debugging session ahead. So, to\nexpose this temporal coupling, let’s have findCommonSuffixtake the prefixIndexas an\nargument.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("private void compactExpectedAndActual() {\nprefixIndex = findCommonPrefix();\nsuffixIndex = findCommonSuffix( prefixIndex );\n")])])]),n("p",[e._v("260 "),n("strong",[e._v("Chapter 15: JUnit Internals")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("compactExpected = compactString(expected);\ncompactActual = compactString(actual);\n}\nprivate int findCommonSuffix( int prefixIndex ) {\nint expectedSuffix = expected.length() - 1;\nint actualSuffix = actual.length() - 1;\nfor (; actualSuffix >= prefixIndex && expectedSuffix >= prefixIndex;\nactualSuffix--, expectedSuffix--) {\nif (expected.charAt(expectedSuffix) != actual.charAt(actualSuffix))\nbreak;\n}\nreturn expected.length() - expectedSuffix;\n}\n")])])]),n("p",[e._v("I’m not really happy with this. The passing of the prefixIndexargument is a bit arbitrary\n[G32]. It works to establish the ordering but does nothing to explain the need for that\nordering. Another programmer might undo what we have done because there’s no indica-\ntion that the parameter is really needed. So let’s take a different tack.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("private void compactExpectedAndActual() {\nfindCommonPrefixAndSuffix ();\ncompactExpected = compactString(expected);\ncompactActual = compactString(actual);\n}\nprivate void findCommonPrefixAndSuffix () {\nfindCommonPrefix();\nint expectedSuffix = expected.length() - 1;\nint actualSuffix = actual.length() - 1;\nfor (;\nactualSuffix >= prefixIndex && expectedSuffix >= prefixIndex;\nactualSuffix--, expectedSuffix--\n) {\nif (expected.charAt(expectedSuffix) != actual.charAt(actualSuffix))\nbreak;\n}\nsuffixIndex = expected.length() - expectedSuffix;\n}\nprivate void findCommonPrefix() {\nprefixIndex = 0;\nint end = Math.min(expected.length(), actual.length());\nfor (; prefixIndex < end; prefixIndex++)\nif (expected.charAt(prefixIndex) != actual.charAt(prefixIndex))\nbreak;\n}\n")])])]),n("p",[e._v("We putfindCommonPrefixandfindCommonSuffixback the way they were, changing the\nname of findCommonSuffixtofindCommon "),n("strong",[e._v("PrefixAnd")]),e._v(" Suffixand having it call findCommon-\nPrefixbefore doing anything else. That establishes the temporal nature of the two func-\ntions in a much more dramatic way than the previous solution. It also points out how ugly\nfindCommonPrefixAndSuffix is. Let’s clean it up now.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("private void findCommonPrefixAndSuffix() {\nfindCommonPrefix();\nint suffixLength = 1;\n")])])]),n("p",[n("strong",[e._v("The JUnit Framework")]),e._v(" 261")]),e._v(" "),n("p",[e._v("for (; !suffixOverlapsPrefix(suffixLength); suffixLength++) {\nif (charFromEnd(expected, suffixLength) !=\ncharFromEnd(actual, suffixLength))\nbreak;\n}\nsuffixIndex = suffixLength;\n}\nprivate char charFromEnd(String s, int i) {\nreturn s.charAt(s.length()-i);}\nprivate boolean suffixOverlapsPrefix(int suffixLength) {\nreturn actual.length() - suffixLength < prefixLength ||\nexpected.length() - suffixLength < prefixLength;\n}\nThis is much better. It exposes that the suffixIndexis really the length of the suffix\nand is not well named. The same is true of the prefixIndex, though in that case “index” and\n“length” are synonymous. Even so, it is more consistent to use “length.” The problem is\nthat the suffixIndexvariable is not zero based; it is 1 based and so is not a true length. This\nis also the reason that there are all those +1s in computeCommonSuffix[G33]. So let’s fix that.\nThe result is in Listing 15-4.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Listing 15-4\nComparisonCompactor.java (interim)\npublic class ComparisonCompactor {\n...\nprivate int suffixLength ;\n...\nprivate void findCommonPrefixAndSuffix() {\nfindCommonPrefix();\nsuffixLength = 0;\nfor (; !suffixOverlapsPrefix(suffixLength); suffixLength++) {\nif (charFromEnd(expected, suffixLength) !=\ncharFromEnd(actual, suffixLength))\nbreak;\n}\n}\nprivate char charFromEnd(String s, int i) {\nreturn s.charAt(s.length() - i - 1 );\n}\nprivate boolean suffixOverlapsPrefix(int suffixLength) {\nreturn actual.length() - suffixLength <= prefixLength ||\nexpected.length() - suffixLength <= prefixLength;\n}\n...\nprivate String compactString(String source) {\nString result =\nDELTA_START +\nsource.substring(prefixLength, source.length() - suffixLength ) +\nDELTA_END;\nif (prefixLength > 0)\nresult = computeCommonPrefix() + result;\n")])])]),n("p",[e._v("262 "),n("strong",[e._v("Chapter 15: JUnit Internals")])]),e._v(" "),n("p",[e._v("We replaced the +1s in computeCommonSuffixwith a -1incharFromEnd, where it makes\nperfect sense, and two <=operators in suffixOverlapsPrefix, where they also make perfect\nsense. This allowed us to change the name of suffixIndextosuffixLength, greatly enhanc-\ning the readability of the code.")]),e._v(" "),n("p",[e._v("There is a problem however. As I was eliminating the +1s, I noticed the following line\nincompactString:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("if (suffixLength > 0)\n")])])]),n("p",[e._v("Take a look at it in Listing 15-4. By rights, because suffixLengthis now one less than it\nused to be, I should change the >operator to a >=operator. But that makes no sense. It\nmakes sense "),n("em",[e._v("now!")]),e._v(" This means that it didn’t use to make sense and was probably a bug.\nWell, not quite a bug. Upon further analysis we see that the ifstatement now prevents a\nzero length suffix from being appended. Before we made the change, the if statement was\nnonfunctional because suffixIndex could never be less than one!")]),e._v(" "),n("p",[e._v("This calls into question "),n("em",[e._v("both")]),e._v(" ifstatements in compactString! It looks as though they\ncould both be eliminated. So let’s comment them out and run the tests. They passed! So\nlet’s restructure compactStringto eliminate the extraneous ifstatements and make the\nfunction much simpler [G9].")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("private String compactString(String source) {\nreturn\ncomputeCommonPrefix() +\nDELTA_START +\nsource.substring(prefixLength, source.length() - suffixLength) +\nDELTA_END +\ncomputeCommonSuffix();\n}\n")])])]),n("p",[e._v("This is much better! Now we see that the compactStringfunction is simply composing the\nfragments together. We can probably make this even clearer. Indeed, there are lots of little")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('if ( suffixLength > 0)\nresult = result + computeCommonSuffix();\nreturn result;\n}\n...\nprivate String computeCommonSuffix() {\nint end = Math.min(expected.length() - suffixLength +\ncontextLength, expected.length()\n);\nreturn\nexpected.substring(expected.length() - suffixLength , end) +\n(expected.length() - suffixLength <\nexpected.length() - contextLength?\nELLIPSIS : "");\n}\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Listing 15-4 (continued)\nComparisonCompactor.java (interim)\n")])])]),n("p",[n("strong",[e._v("The JUnit Framework")]),e._v(" 263")]),e._v(" "),n("p",[e._v("cleanups we could do. But rather than drag you through the rest of the changes, I’ll just\nshow you the result in Listing 15-5.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('Listing 15-5\nComparisonCompactor.java (final)\npackage junit.framework;\npublic class ComparisonCompactor {\nprivate static final String ELLIPSIS = "...";\nprivate static final String DELTA_END = "]";\nprivate static final String DELTA_START = "[";\nprivate int contextLength;\nprivate String expected;\nprivate String actual;\nprivate int prefixLength;\nprivate int suffixLength;\npublic ComparisonCompactor(\nint contextLength, String expected, String actual\n) {\nthis.contextLength = contextLength;\nthis.expected = expected;\nthis.actual = actual;\n}\npublic String formatCompactedComparison(String message) {\nString compactExpected = expected;\nString compactActual = actual;\nif (shouldBeCompacted()) {\nfindCommonPrefixAndSuffix();\ncompactExpected = compact(expected);\ncompactActual = compact(actual);\n}\nreturn Assert.format(message, compactExpected, compactActual);\n}\nprivate boolean shouldBeCompacted() {\nreturn !shouldNotBeCompacted();\n}\nprivate boolean shouldNotBeCompacted() {\nreturn expected == null ||\nactual == null ||\nexpected.equals(actual);\n}\nprivate void findCommonPrefixAndSuffix() {\nfindCommonPrefix();\nsuffixLength = 0;\nfor (; !suffixOverlapsPrefix(); suffixLength++) {\nif (charFromEnd(expected, suffixLength) !=\ncharFromEnd(actual, suffixLength)\n)\n')])])]),n("p",[e._v("264 "),n("strong",[e._v("Chapter 15: JUnit Internals")])]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('break;\n}\n}\nprivate char charFromEnd(String s, int i) {\nreturn s.charAt(s.length() - i - 1);\n}\nprivate boolean suffixOverlapsPrefix() {\nreturn actual.length() - suffixLength <= prefixLength ||\nexpected.length() - suffixLength <= prefixLength;\n}\nprivate void findCommonPrefix() {\nprefixLength = 0;\nint end = Math.min(expected.length(), actual.length());\nfor (; prefixLength < end; prefixLength++)\nif (expected.charAt(prefixLength) != actual.charAt(prefixLength))\nbreak;\n}\nprivate String compact(String s) {\nreturn new StringBuilder()\n.append(startingEllipsis())\n.append(startingContext())\n.append(DELTA_START)\n.append(delta(s))\n.append(DELTA_END)\n.append(endingContext())\n.append(endingEllipsis())\n.toString();\n}\nprivate String startingEllipsis() {\nreturn prefixLength > contextLength? ELLIPSIS : "";\n}\nprivate String startingContext() {\nint contextStart = Math.max(0, prefixLength - contextLength);\nint contextEnd = prefixLength;\nreturn expected.substring(contextStart, contextEnd);\n}\nprivate String delta(String s) {\nint deltaStart = prefixLength;\nint deltaEnd = s.length() - suffixLength;\nreturn s.substring(deltaStart, deltaEnd);\n}\nprivate String endingContext() {\nint contextStart = expected.length() - suffixLength;\nint contextEnd =\nMath.min(contextStart + contextLength, expected.length());\nreturn expected.substring(contextStart, contextEnd);\n}\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Listing 15-5 (continued)\nComparisonCompactor.java (final)\n")])])]),n("p",[n("strong",[e._v("Conclusion")]),e._v(" 265")]),e._v(" "),n("p",[e._v("This is actually quite pretty. The module is separated into a group of analysis func-\ntions and another group of synthesis functions. They are topologically sorted so that the\ndefinition of each function appears just after it is used. All the analysis functions appear\nfirst, and all the synthesis functions appear last.")]),e._v(" "),n("p",[e._v("If you look carefully, you will notice that I reversed several of the decisions I made\nearlier in this chapter. For example, I inlined some extracted methods back into\nformatCompactedComparison, and I changed the sense of the shouldNotBeCompactedexpres-\nsion. This is typical. Often one refactoring leads to another that leads to the undoing of the\nfirst. Refactoring is an iterative process full of trial and error, inevitably converging on\nsomething that we feel is worthy of a professional.")]),e._v(" "),n("h2",{attrs:{id:"conclusion"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#conclusion"}},[e._v("#")]),e._v(" Conclusion ..")]),e._v(" "),n("p",[e._v("And so we have satisfied the Boy Scout Rule. We have left this module a bit cleaner than\nwe found it. Not that it wasn’t clean already. The authors had done an excellent job with it.\nBut no module is immune from improvement, and each of us has the responsibility to\nleave the code a little better than we found it.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v('private String endingEllipsis() {\nreturn (suffixLength > contextLength? ELLIPSIS : "");\n}\n}\n')])])]),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Listing 15-5 (continued)\nComparisonCompactor.java (final)\n")])])])])}),[],!1,null,null,null);t.default=i.exports}}]);