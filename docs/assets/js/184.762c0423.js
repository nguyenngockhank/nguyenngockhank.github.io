(window.webpackJsonp=window.webpackJsonp||[]).push([[184],{1314:function(e,t,s){"use strict";s.r(t);var a=s(7),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"patterns-of-distributed-systems"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#patterns-of-distributed-systems"}},[e._v("#")]),e._v(" Patterns of Distributed Systems")]),e._v(" "),s("h3",{attrs:{id:"service-oriented-architecture-soa"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#service-oriented-architecture-soa"}},[e._v("#")]),e._v(" Service-Oriented Architecture (SOA)")]),e._v(" "),s("p",[e._v("SOA is a design pattern that involves breaking down a system into smaller, independent services that can communicate with each other. Each service performs a specific function and can be developed, deployed, and scaled independently. SOA is a popular pattern used in distributed systems as it allows for better scalability, fault tolerance, and flexibility.")]),e._v(" "),s("h3",{attrs:{id:"mapreduce"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#mapreduce"}},[e._v("#")]),e._v(" MapReduce")]),e._v(" "),s("p",[e._v("MapReduce is a pattern that involves breaking down a large data processing task into smaller, independent tasks that can be processed in parallel. This pattern is commonly used in distributed systems to improve performance and scalability.")]),e._v(" "),s("h2",{attrs:{id:"ðŸ’Ž-event-driven-architecture-eda-patterns"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ðŸ’Ž-event-driven-architecture-eda-patterns"}},[e._v("#")]),e._v(" ðŸ’Ž Event-Driven Architecture (EDA) Patterns")]),e._v(" "),s("h3",{attrs:{id:"event-notification"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#event-notification"}},[e._v("#")]),e._v(" Event Notification")]),e._v(" "),s("p",[e._v("The event notification pattern is the most basic pattern used in EDA. In this pattern, an event is generated by a component and sent to other components that have subscribed to it. The subscribers can then process the event and take appropriate actions. This pattern is useful when a component needs to notify other components about a change in its state or when a specific condition is met.")]),e._v(" "),s("h3",{attrs:{id:"event-carried-state-transfer"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#event-carried-state-transfer"}},[e._v("#")]),e._v(" Event-Carried State Transfer")]),e._v(" "),s("p",[e._v("The event-carried state transfer (ECST) pattern is used to transfer the state of an object between different components in an event-driven system. In this pattern, the state of an object is encapsulated in an event and sent to other components. The receiving components can then use the state to update their own state. This pattern is useful when a component needs to share its state with other components in the system.")]),e._v(" "),s("h3",{attrs:{id:"event-sourcing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#event-sourcing"}},[e._v("#")]),e._v(" Event Sourcing")]),e._v(" "),s("p",[e._v("Event sourcing is a pattern used to store the state of an object as a sequence of events. In this pattern, every change to the state of an object is captured as an event and stored in an event log. The current state of the object can then be reconstructed by replaying the events in the log. This pattern is useful when a system needs to maintain a complete history of changes to an object's state.")]),e._v(" "),s("h3",{attrs:{id:"cqrs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#cqrs"}},[e._v("#")]),e._v(" CQRS")]),e._v(" "),s("p",[e._v("Command Query Responsibility Segregation (CQRS) is a pattern used to separate the read and write operations of a system. In this pattern, the read operations are handled by a separate component from the write operations. The write operations generate events that are sent to the read component, which updates its state accordingly. This pattern is useful when a system needs to handle a large number of read and write operations.")]),e._v(" "),s("h3",{attrs:{id:"saga"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#saga"}},[e._v("#")]),e._v(" Saga")]),e._v(" "),s("p",[e._v("The saga pattern is used to manage long-running transactions in an event-driven system. In this pattern, a saga is a sequence of events that are executed in a specific order. If an event fails, the saga can be rolled back to a previous state. This pattern is useful when a system needs to handle complex transactions that involve multiple components.")]),e._v(" "),s("h2",{attrs:{id:"ðŸ’Ž-fault-tolerance"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ðŸ’Ž-fault-tolerance"}},[e._v("#")]),e._v(" ðŸ’Ž Fault-Tolerance")]),e._v(" "),s("h3",{attrs:{id:"redundancy"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#redundancy"}},[e._v("#")]),e._v(" Redundancy")]),e._v(" "),s("p",[e._v("Redundancy is the duplication of critical components or data to ensure that the system can continue operating even if some components fail. There are several types of redundancy:")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Hardware redundancy")]),e._v(": multiple instances of hardware components are used to ensure that the system can continue operating even if some components fail. For example, a distributed database may have multiple servers that store the same data.")]),e._v(" "),s("li",[s("strong",[e._v("Software redundancy")]),e._v(": multiple instances of software components are used to ensure that the system can continue operating even if some components fail. For example, a load balancer may have multiple instances that distribute requests to multiple servers.")]),e._v(" "),s("li",[s("strong",[e._v("Data redundancy")]),e._v(": multiple copies of data are stored to ensure that the system can continue operating even if some data is lost. For example, a distributed file system may store multiple copies of files on different servers.")])]),e._v(" "),s("h3",{attrs:{id:"replication"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#replication"}},[e._v("#")]),e._v(" Replication")]),e._v(" "),s("p",[e._v("Replication is the process of copying data or components to multiple locations to ensure that the system can continue operating even if some components fail. There are several types of replication:")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Active-active replication")]),e._v(": multiple instances of components are active at the same time and handle requests concurrently. For example, a distributed database may have multiple servers that handle read and write requests.")]),e._v(" "),s("li",[s("strong",[e._v("Active-passive replication")]),e._v(": one instance of a component is active and handles requests, while other instances are passive and only become active if the active instance fails. For example, a load balancer may have one active instance that distributes requests to multiple servers, and one passive instance that becomes active if the active instance fails.")])]),e._v(" "),s("h3",{attrs:{id:"graceful-degradation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#graceful-degradation"}},[e._v("#")]),e._v(" Graceful Degradation")]),e._v(" "),s("p",[e._v("Graceful degradation is a pattern that allows a system to continue operating even if some components are unavailable or degraded. The system detects the unavailability or degradation of components and adjusts its behavior to minimize the impact on users. For example, a search engine may return fewer results or slower results if some servers are unavailable.")]),e._v(" "),s("h3",{attrs:{id:"retry-pattern"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#retry-pattern"}},[e._v("#")]),e._v(" Retry pattern")]),e._v(" "),s("p",[e._v("The Retry pattern  is used to handle transient failures in a distributed system. It works by retrying a failed operation a certain number of times before giving up. This allows the system to recover from temporary failures and continue to function.")]),e._v(" "),s("p",[s("RouterLink",{attrs:{to:"/architect/patterns/retry.html"}},[e._v("Read more")])],1),e._v(" "),s("h3",{attrs:{id:"timeout-pattern"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#timeout-pattern"}},[e._v("#")]),e._v(" Timeout Pattern")]),e._v(" "),s("p",[e._v("The Timeout pattern is used to prevent a distributed system from becoming unresponsive due to long-running operations. It works by setting a timeout for each operation and aborting the operation if it exceeds the timeout. This allows the system to continue to function even if some operations fail.")]),e._v(" "),s("h3",{attrs:{id:"bulkhead"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#bulkhead"}},[e._v("#")]),e._v(" Bulkhead")]),e._v(" "),s("p",[e._v("The Bulkhead pattern is used to isolate failures in a distributed system. It works by partitioning the system into separate compartments, each with its own resources and failure modes. This allows failures in one compartment to be contained and not affect other compartments.")]),e._v(" "),s("h3",{attrs:{id:"failover"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#failover"}},[e._v("#")]),e._v(" Failover")]),e._v(" "),s("p",[e._v("Failover is a pattern that involves switching to a backup system when the primary system fails. This can be achieved through hardware redundancy or through software redundancy, where multiple instances of a component are run on different machines.")]),e._v(" "),s("h3",{attrs:{id:"circuit-breaker"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#circuit-breaker"}},[e._v("#")]),e._v(" Circuit Breaker")]),e._v(" "),s("p",[e._v("A circuit breaker is a pattern that prevents a component from repeatedly failing and causing cascading failures in the system. The circuit breaker monitors the number of failures that occur within a certain period of time, and if the number exceeds a threshold, it trips the circuit and stops sending requests to the component. This allows the component to recover and prevents it from causing further failures in the system.")]),e._v(" "),s("h2",{attrs:{id:"ðŸ’Ž-communication-patterns"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ðŸ’Ž-communication-patterns"}},[e._v("#")]),e._v(" ðŸ’Ž Communication Patterns")]),e._v(" "),s("h3",{attrs:{id:"request-reply-pattern"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#request-reply-pattern"}},[e._v("#")]),e._v(" Request-Reply Pattern")]),e._v(" "),s("p",[e._v("The request-reply pattern is one of the most common communication patterns used in distributed systems. In this pattern, a client sends a request to a server, and the server responds with a reply. The request-reply pattern is synchronous, meaning that the client waits for the server to respond before continuing with its execution. This pattern is commonly used in client-server architectures, where the client sends a request to the server and waits for a response.")]),e._v(" "),s("h4",{attrs:{id:"remote-procedure-call-rpc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#remote-procedure-call-rpc"}},[e._v("#")]),e._v(" Remote Procedure Call (RPC)")]),e._v(" "),s("p",[e._v("RPC is a pattern that involves calling a function or method on a remote system as if it were a local function or method. RPC is a popular pattern used in distributed systems as it allows for better scalability, fault tolerance, and decoupling of components.")]),e._v(" "),s("h3",{attrs:{id:"message-oriented-middleware-mom"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#message-oriented-middleware-mom"}},[e._v("#")]),e._v(" Message-Oriented Middleware (MOM)")]),e._v(" "),s("p",[e._v("MOM is a pattern that involves using a messaging system to facilitate communication between different components of a distributed system. Messages are sent between components asynchronously, which means that the sender does not have to wait for a response before continuing with other tasks. MOM is a popular pattern used in distributed systems as it allows for better scalability, fault tolerance, and decoupling of components.")]),e._v(" "),s("h4",{attrs:{id:"publish-subscribe"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#publish-subscribe"}},[e._v("#")]),e._v(" Publish-Subscribe")]),e._v(" "),s("p",[e._v("Publish-Subscribe is a pattern that involves sending messages to a group of subscribers who have expressed interest in receiving those messages. This pattern is commonly used in distributed systems to facilitate communication between different components.")]),e._v(" "),s("h4",{attrs:{id:"message-queue-pattern"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#message-queue-pattern"}},[e._v("#")]),e._v(" Message Queue Pattern")]),e._v(" "),s("p",[e._v("The message queue pattern is a communication pattern used in distributed systems to decouple the sender and receiver of a message. In this pattern, a sender sends a message to a message queue, and the receiver retrieves the message from the queue. The message queue pattern is asynchronous, meaning that the sender does not wait for the receiver to receive the message before continuing with its execution. This pattern is commonly used in microservices architectures, where services communicate with each other through message queues.")]),e._v(" "),s("h2",{attrs:{id:"ðŸ’Ž-optimizing-performance"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ðŸ’Ž-optimizing-performance"}},[e._v("#")]),e._v(" ðŸ’Ž Optimizing Performance")]),e._v(" "),s("h3",{attrs:{id:"caching"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#caching"}},[e._v("#")]),e._v(" Caching")]),e._v(" "),s("p",[e._v("Caching is a technique used to store frequently accessed data in memory, reducing the need to fetch it from the network or disk. In distributed systems, caching can be used to reduce the number of requests made to remote services, improving response times and reducing network traffic. There are several caching strategies, including:")]),e._v(" "),s("ul",[s("li",[e._v("Client-side caching: where the client caches responses from the server.")]),e._v(" "),s("li",[e._v("Server-side caching: where the server caches responses from the database or other services.")]),e._v(" "),s("li",[e._v("Distributed caching: where multiple nodes in the system share a cache.")])]),e._v(" "),s("h3",{attrs:{id:"load-balancing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#load-balancing"}},[e._v("#")]),e._v(" Load Balancing")]),e._v(" "),s("p",[e._v("Load balancing is a technique used to distribute incoming requests across multiple servers, ensuring that no single server is overloaded. Load balancing can improve performance by reducing response times and increasing availability. There are several load balancing strategies, including:")]),e._v(" "),s("ul",[s("li",[e._v("Round-robin: where requests are distributed evenly across servers.")]),e._v(" "),s("li",[e._v("Least connections: where requests are sent to the server with the fewest active connections.")]),e._v(" "),s("li",[e._v("IP hash: where requests are sent to the server based on the client's IP address.")])]),e._v(" "),s("h3",{attrs:{id:"asynchronous-processing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#asynchronous-processing"}},[e._v("#")]),e._v(" Asynchronous Processing")]),e._v(" "),s("p",[e._v("Asynchronous processing is a technique used to improve performance by allowing tasks to be executed in the background, freeing up resources for other tasks. In distributed systems, asynchronous processing can be used to improve response times and reduce network traffic. There are several asynchronous processing strategies, including:")]),e._v(" "),s("ul",[s("li",[e._v("Message queues: where tasks are added to a queue and processed asynchronously.")]),e._v(" "),s("li",[e._v("Event-driven architecture: where tasks are triggered by events and processed asynchronously.")]),e._v(" "),s("li",[e._v("Actor model: where tasks are executed by actors, which are independent units of computation.")])]),e._v(" "),s("h3",{attrs:{id:"data-partitioning"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#data-partitioning"}},[e._v("#")]),e._v(" Data Partitioning")]),e._v(" "),s("p",[e._v("Data partitioning is a technique used to split data across multiple servers, improving performance by reducing the amount of data that needs to be processed by each server. In distributed systems, data partitioning can be used to improve scalability and reduce response times. There are several data partitioning strategies, including:")]),e._v(" "),s("ul",[s("li",[e._v("Horizontal partitioning: where data is split by rows.")]),e._v(" "),s("li",[e._v("Vertical partitioning: where data is split by columns.")]),e._v(" "),s("li",[e._v("Hash partitioning: where data is split based on a hash function.")])]),e._v(" "),s("h3",{attrs:{id:"replication-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#replication-2"}},[e._v("#")]),e._v(" Replication")]),e._v(" "),s("p",[e._v("Replication is a technique used to create copies of data across multiple servers, improving performance by reducing the need to fetch data from remote servers. In distributed systems, replication can be used to improve availability and reduce response times. There are several replication strategies, including:")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Master-slave replication")]),e._v(": where one server is designated as the master and all writes are sent to it, while reads can be sent to any of the slaves.")]),e._v(" "),s("li",[s("strong",[e._v("Master-master replication")]),e._v(": where multiple servers act as masters and can both read and write data.")]),e._v(" "),s("li",[s("strong",[e._v("Multi-master replication")]),e._v(": where multiple servers can both read and write data, and conflicts are resolved using a consensus algorithm.")])]),e._v(" "),s("h2",{attrs:{id:"ðŸ’Ž-idempotency-patterns"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ðŸ’Ž-idempotency-patterns"}},[e._v("#")]),e._v(" ðŸ’Ž Idempotency Patterns")]),e._v(" "),s("h3",{attrs:{id:"idempotency-keys"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#idempotency-keys"}},[e._v("#")]),e._v(" Idempotency Keys")]),e._v(" "),s("p",[e._v("One common pattern for achieving idempotency is to use idempotency keys. An idempotency key is a unique identifier that is associated with a particular operation. When an operation is performed, the idempotency key is recorded, along with the result of the operation. If the operation is repeated with the same idempotency key, the system will recognize that the operation has already been performed and return the same result as before. This pattern is commonly used in REST APIs, where a client can include an idempotency key in a request header to ensure that the request is idempotent.")]),e._v(" "),s("h3",{attrs:{id:"idempotent-state-machines"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#idempotent-state-machines"}},[e._v("#")]),e._v(" Idempotent State Machines")]),e._v(" "),s("p",[e._v("Another pattern for achieving idempotency is to use idempotent state machines. In this pattern, the system maintains a state machine that tracks the progress of an operation. Each state in the state machine is idempotent, meaning that it can be repeated without changing the result beyond the initial application. When an operation is performed, the system transitions to the next state in the state machine. If the operation is repeated, the system will recognize that it has already transitioned to the next state and will not repeat the transition. This pattern is commonly used in distributed systems that perform complex operations, such as payment processing or order fulfillment.")]),e._v(" "),s("h2",{attrs:{id:"ðŸ’Ž-patterns-for-concurrency"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ðŸ’Ž-patterns-for-concurrency"}},[e._v("#")]),e._v(" ðŸ’Ž Patterns for concurrency")]),e._v(" "),s("h3",{attrs:{id:"locking"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#locking"}},[e._v("#")]),e._v(" Locking")]),e._v(" "),s("p",[e._v("Locking is a common pattern used to manage concurrency in distributed systems. It involves acquiring a lock on a shared resource to prevent other processes from accessing it simultaneously. Locking can be implemented using various techniques such as mutual exclusion, semaphores, and monitors. However, locking can also introduce performance overhead and can lead to deadlocks if not implemented correctly.")]),e._v(" "),s("h3",{attrs:{id:"message-passing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#message-passing"}},[e._v("#")]),e._v(" Message Passing")]),e._v(" "),s("p",[e._v("Message passing is another pattern used to manage concurrency in distributed systems. It involves sending messages between processes to coordinate their activities. Message passing can be implemented using various techniques such as remote procedure calls (RPC), message queues, and publish-subscribe systems. Message passing can be more efficient than locking in some cases, as it allows processes to communicate without the need for shared resources.")]),e._v(" "),s("h3",{attrs:{id:"event-driven-architecture"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#event-driven-architecture"}},[e._v("#")]),e._v(" Event-driven Architecture")]),e._v(" "),s("p",[e._v("Event-driven architecture is a pattern that involves processing events asynchronously. It involves decoupling the processing of events from the generation of events, allowing processes to handle events independently. Event-driven architecture can be implemented using various techniques such as event sourcing, event-driven messaging, and reactive programming. Event-driven architecture can be more scalable than locking or message passing in some cases, as it allows processes to handle events independently and asynchronously.")]),e._v(" "),s("h3",{attrs:{id:"actor-model"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#actor-model"}},[e._v("#")]),e._v(" Actor Model")]),e._v(" "),s("p",[e._v("The actor model is a pattern that involves modeling concurrent processes as actors. Each actor has its own state and can communicate with other actors by sending messages. The actor model can be implemented using various techniques such as Akka, Erlang, and Orleans. The actor model can be more scalable than locking or message passing in some cases, as it allows processes to handle messages independently and asynchronously.")]),e._v(" "),s("h3",{attrs:{id:"data-partitioning-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#data-partitioning-2"}},[e._v("#")]),e._v(" Data Partitioning")]),e._v(" "),s("p",[e._v("Data partitioning is a pattern that involves partitioning data across multiple nodes in a distributed system. Each node is responsible for a subset of the data, allowing processes to access data independently and concurrently. Data partitioning can be implemented using various techniques such as sharding, consistent hashing, and range partitioning. Data partitioning can be more scalable than locking or message passing in some cases, as it allows processes to access data independently and concurrently.")]),e._v(" "),s("h2",{attrs:{id:"ðŸ’Ž-patterns-for-increasing-concurrency"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ðŸ’Ž-patterns-for-increasing-concurrency"}},[e._v("#")]),e._v(" ðŸ’Ž Patterns for Increasing Concurrency")]),e._v(" "),s("h3",{attrs:{id:"_1-thread-pool-pattern"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-thread-pool-pattern"}},[e._v("#")]),e._v(" 1. Thread Pool Pattern")]),e._v(" "),s("p",[e._v("The Thread Pool pattern is a concurrency pattern that involves creating a pool of threads that can be used to execute tasks. When a task is submitted to the system, it is assigned to an available thread in the pool. This pattern is useful for systems that have a large number of short-lived tasks that need to be executed quickly.")]),e._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ExecutorService")]),e._v(" executor "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Executors")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("newFixedThreadPool")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("for")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("100")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    executor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("execute")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Task")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),s("h3",{attrs:{id:"_2-asynchronous-messaging-pattern"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-asynchronous-messaging-pattern"}},[e._v("#")]),e._v(" 2. Asynchronous Messaging Pattern")]),e._v(" "),s("p",[e._v("The Asynchronous Messaging pattern is a concurrency pattern that involves using messaging to communicate between different parts of a system. This pattern is useful for systems that have long-running tasks that can be executed asynchronously. When a task is submitted to the system, it is sent as a message to a queue. A worker process then retrieves the message from the queue and executes the task.")]),e._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("class")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("TaskListener")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("implements")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MessageListener")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("onMessage")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token parameter"}},[e._v("Message message")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Execute task asynchronously")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\nConnectionFactory connectionFactory "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("ActiveMQConnectionFactory")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"tcp://localhost:61616"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nConnection connection "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" connectionFactory"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("createConnection")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nSession session "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" connection"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("createSession")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" Session"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token constant"}},[e._v("AUTO_ACKNOWLEDGE")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nDestination destination "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" session"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("createQueue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"taskQueue"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nMessageConsumer consumer "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" session"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("createConsumer")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("destination"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nconsumer"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("setMessageListener")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("TaskListener")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),s("h3",{attrs:{id:"_3-actor-model-pattern"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-actor-model-pattern"}},[e._v("#")]),e._v(" 3. Actor Model Pattern")]),e._v(" "),s("p",[e._v("The Actor Model pattern is a concurrency pattern that involves creating actors that can communicate with each other through messages. Each actor has its own state and can execute tasks independently. This pattern is useful for systems that have a large number of long-running tasks that need to be executed concurrently.")]),e._v(" "),s("div",{staticClass:"language-js extra-class"},[s("pre",{pre:!0,attrs:{class:"language-js"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("class")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("MyActor")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("extends")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("UntypedActor")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("public")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("onReceive")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("Object message"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" throws Exception "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Execute task asynchronously")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n\nActorSystem system "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" ActorSystem"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("create")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"MySystem"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nActorRef myActor "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" system"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("actorOf")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("Props"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("create")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("MyActor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("class"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\nmyActor"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("tell")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"Task"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" ActorRef"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("noSender")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),s("h2",{attrs:{id:"ðŸ’Ž-patterns-for-race-condition"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ðŸ’Ž-patterns-for-race-condition"}},[e._v("#")]),e._v(" ðŸ’Ž Patterns for Race Condition")]),e._v(" "),s("h3",{attrs:{id:"read-modify-write"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#read-modify-write"}},[e._v("#")]),e._v(" Read-Modify-Write")]),e._v(" "),s("p",[e._v("The Read-Modify-Write pattern is a common source of race conditions in distributed systems. It occurs when multiple processes or threads read a shared resource, modify it, and write it back to the same location. If two or more processes modify the same resource concurrently, the final value of the resource may depend on the order in which the modifications are applied.")]),e._v(" "),s("p",[e._v("To avoid this pattern, we can use atomic operations that guarantee that the read-modify-write sequence is executed atomically, without any other process or thread intervening. For example, in Java, we can use the "),s("code",[e._v("synchronized")]),e._v(" keyword or the "),s("code",[e._v("java.util.concurrent.atomic")]),e._v(" package to ensure atomicity.")]),e._v(" "),s("h3",{attrs:{id:"locking-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#locking-2"}},[e._v("#")]),e._v(" Locking")]),e._v(" "),s("p",[e._v("Locking is another common pattern for avoiding race conditions in distributed systems. It involves acquiring a lock on a shared resource before accessing it and releasing the lock after the access is complete. If two or more processes attempt to acquire the same lock concurrently, one of them will block until the lock is released.")]),e._v(" "),s("p",[e._v("To avoid deadlocks, we should use a consistent ordering of locks across all processes or threads. For example, we can use a global ordering of locks based on the identity of the resources being locked.")]),e._v(" "),s("h3",{attrs:{id:"message-passing-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#message-passing-2"}},[e._v("#")]),e._v(" Message Passing")]),e._v(" "),s("p",[e._v("Message passing is a pattern for avoiding race conditions in distributed systems by using asynchronous communication between processes or threads. Instead of accessing shared resources directly, processes or threads send messages to each other to request access or to notify each other of changes.")]),e._v(" "),s("p",[e._v("To avoid race conditions, we should use a consistent ordering of messages across all processes or threads. For example, we can use a global ordering of messages based on the identity of the sender and the receiver.")]),e._v(" "),s("h3",{attrs:{id:"versioning"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#versioning"}},[e._v("#")]),e._v(" Versioning")]),e._v(" "),s("p",[e._v("Versioning is a pattern for avoiding race conditions in distributed systems by using version numbers to track changes to shared resources. Each process or thread maintains a local copy of the resource and updates its version number when it modifies the resource. When a process or thread reads the resource, it checks the version number to ensure that it has the latest version.")]),e._v(" "),s("p",[e._v("To avoid conflicts, we should use a consistent ordering of updates across all processes or threads. For example, we can use a global ordering of updates based on the version number of the resource.")]),e._v(" "),s("h2",{attrs:{id:"ðŸ’Ž-locking-patterns"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ðŸ’Ž-locking-patterns"}},[e._v("#")]),e._v(" ðŸ’Ž Locking Patterns")]),e._v(" "),s("h3",{attrs:{id:"_1-centralized-locking"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-centralized-locking"}},[e._v("#")]),e._v(" 1. Centralized Locking")]),e._v(" "),s("p",[e._v("Centralized locking is a simple and effective pattern for locking in distributed systems. In this pattern, a single node is responsible for managing the locks for all the resources in the system. When a process needs to access a resource, it requests a lock from the centralized lock manager. The lock manager grants the lock if it is available, and the process can access the resource. Once the process is done, it releases the lock, and the lock manager makes it available for other processes.")]),e._v(" "),s("p",[e._v("The main advantage of centralized locking is its simplicity. It is easy to implement and does not require complex coordination between nodes. However, it can become a bottleneck if the lock manager becomes overloaded or fails.")]),e._v(" "),s("h3",{attrs:{id:"_2-distributed-locking"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-distributed-locking"}},[e._v("#")]),e._v(" 2. Distributed Locking")]),e._v(" "),s("p",[e._v("Distributed locking is a more complex pattern that distributes the lock management across multiple nodes. In this pattern, each node is responsible for managing the locks for the resources it owns. When a process needs to access a resource, it requests a lock from the node that owns the resource. The node grants the lock if it is available, and the process can access the resource. Once the process is done, it releases the lock, and the node makes it available for other processes.")]),e._v(" "),s("p",[e._v("The main advantage of distributed locking is its scalability. It can handle a large number of resources and processes without becoming a bottleneck. However, it requires more complex coordination between nodes and can be challenging to implement correctly.")]),e._v(" "),s("h3",{attrs:{id:"_3-optimistic-locking"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-optimistic-locking"}},[e._v("#")]),e._v(" 3. Optimistic Locking")]),e._v(" "),s("p",[e._v("Optimistic locking is a pattern that assumes that conflicts between processes are rare and allows multiple processes to access the same resource simultaneously. In this pattern, each process reads the resource's current state and stores it locally. When the process updates the resource, it checks if the resource's state has changed since it last read it. If the state has not changed, the process updates the resource and releases the lock. If the state has changed, the process retries the operation with the new state.")]),e._v(" "),s("p",[e._v("The main advantage of optimistic locking is its high concurrency. It allows multiple processes to access the same resource simultaneously, reducing contention and improving performance. However, it requires careful handling of conflicts and can be challenging to implement correctly.")]),e._v(" "),s("h3",{attrs:{id:"_4-pessimistic-locking"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-pessimistic-locking"}},[e._v("#")]),e._v(" 4. Pessimistic Locking")]),e._v(" "),s("p",[e._v("Pessimistic locking is a pattern that assumes that conflicts between processes are common and prevents multiple processes from accessing the same resource simultaneously. In this pattern, each process requests a lock on the resource before accessing it. If the lock is granted, the process can access the resource. If the lock is not granted, the process waits until the lock becomes available.")]),e._v(" "),s("p",[e._v("The main advantage of pessimistic locking is its simplicity and reliability. It ensures that conflicts between processes are avoided, and the resource is accessed by only one process at a time. However, it can become a bottleneck if the lock is held for a long time, and it can reduce concurrency and performance.")]),e._v(" "),s("p",[e._v("In conclusion, locking is a critical aspect of distributed systems, and choosing the right locking pattern depends on the specific requirements of the system. Centralized locking is simple and effective but can become a bottleneck. Distributed locking is scalable but requires more complex coordination. Optimistic locking allows high concurrency but requires careful handling of conflicts. Pessimistic locking is simple and reliable but can reduce concurrency and performance.")]),e._v(" "),s("h2",{attrs:{id:"ðŸ’Ž-distributed-transaction-patterns"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ðŸ’Ž-distributed-transaction-patterns"}},[e._v("#")]),e._v(" ðŸ’Ž Distributed transaction patterns")]),e._v(" "),s("h3",{attrs:{id:"two-phase-commit-2pc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#two-phase-commit-2pc"}},[e._v("#")]),e._v(" Two-Phase Commit (2PC):")]),e._v(" "),s("p",[s("RouterLink",{attrs:{to:"/architect/2pc/"}},[e._v("Read here")])],1),e._v(" "),s("h3",{attrs:{id:"saga-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#saga-2"}},[e._v("#")]),e._v(" Saga:")]),e._v(" "),s("p",[e._v("A saga is a sequence of local transactions, each executed within a single service, that together form a distributed transaction. Each local transaction updates the data within its own service and publishes events to trigger subsequent local transactions in other services. If a local transaction fails, compensating actions are executed to undo the changes made by previous transactions. Sagas are more flexible than 2PC but require careful design to handle failures and ensure eventual consistency.")]),e._v(" "),s("h3",{attrs:{id:"eventual-consistency"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#eventual-consistency"}},[e._v("#")]),e._v(" Eventual Consistency:")]),e._v(" "),s("p",[e._v("Instead of enforcing immediate consistency, this pattern allows services to operate independently and asynchronously replicate data changes. Services publish events when they make changes to their data, and other services subscribe to these events to update their own data. While this pattern simplifies the transaction management, it introduces the challenge of handling eventual consistency and resolving conflicts.")]),e._v(" "),s("h3",{attrs:{id:"compensating-transaction"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#compensating-transaction"}},[e._v("#")]),e._v(" Compensating Transaction:")]),e._v(" "),s("p",[e._v("This pattern is used when a transaction needs to be rolled back due to a failure or error. A compensating transaction is designed to undo the changes made by the original transaction. For example, if a payment transaction fails, a compensating transaction can be triggered to reverse the payment. This pattern requires careful design to ensure that compensating transactions are idempotent and can be executed safely.")]),e._v(" "),s("h3",{attrs:{id:"idempotent-retry"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#idempotent-retry"}},[e._v("#")]),e._v(" Idempotent Retry:")]),e._v(" "),s("p",[e._v("In this pattern, a failed transaction can be retried without causing any side effects. Each transaction is designed to be idempotent, meaning that executing it multiple times produces the same result as executing it once. By retrying the transaction, eventual consistency can be achieved even in the presence of failures.")]),e._v(" "),s("h2",{attrs:{id:"ðŸ’Ž-patterns-for-ensuring-data-consistency"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ðŸ’Ž-patterns-for-ensuring-data-consistency"}},[e._v("#")]),e._v(" ðŸ’Ž Patterns for Ensuring Data Consistency")]),e._v(" "),s("h3",{attrs:{id:"_1-two-phase-commit-2pc"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-two-phase-commit-2pc"}},[e._v("#")]),e._v(" 1. Two-Phase Commit (2PC)")]),e._v(" "),s("p",[s("RouterLink",{attrs:{to:"/architect/2pc/"}},[e._v("Read here")])],1),e._v(" "),s("h3",{attrs:{id:"_2-saga-pattern"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-saga-pattern"}},[e._v("#")]),e._v(" 2. Saga Pattern")]),e._v(" "),s("p",[e._v("The Saga pattern is another pattern that can be used to ensure data consistency in distributed systems. In this pattern, a long-running transaction is broken down into a series of smaller transactions, each of which is executed by a separate node. Each transaction updates the state of the system and publishes an event to notify other nodes of the change. If a transaction fails, the Saga pattern uses compensating transactions to undo the changes made by the failed transaction and restore the system to its previous state.")]),e._v(" "),s("h3",{attrs:{id:"_3-eventual-consistency"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-eventual-consistency"}},[e._v("#")]),e._v(" 3. Eventual Consistency")]),e._v(" "),s("p",[e._v("Eventual consistency is a pattern that allows for data consistency to be achieved over time, rather than immediately. In this pattern, updates to the system are propagated asynchronously to all nodes in the system. While this approach may result in temporary inconsistencies, the system eventually converges to a consistent state. This pattern is often used in systems where high availability is more important than immediate consistency.")]),e._v(" "),s("h3",{attrs:{id:"_4-conflict-free-replicated-data-types-crdts"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-conflict-free-replicated-data-types-crdts"}},[e._v("#")]),e._v(" 4. Conflict-Free Replicated Data Types (CRDTs)")]),e._v(" "),s("p",[e._v("Conflict-Free Replicated Data Types (CRDTs) are a family of data structures that can be used to ensure data consistency in distributed systems. CRDTs are designed to be replicated across multiple nodes in a system, and they ensure that updates to the data structure are conflict-free. This means that updates can be applied in any order, and the data structure will always converge to a consistent state.")]),e._v(" "),s("h2",{attrs:{id:"ðŸ’Ž-consistency-patterns"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#ðŸ’Ž-consistency-patterns"}},[e._v("#")]),e._v(" ðŸ’Ž Consistency patterns")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("#")]),e._v(" "),s("th",[e._v("Name")]),e._v(" "),s("th",[e._v("Stategy")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("1")]),e._v(" "),s("td",[e._v("Compensating action")]),e._v(" "),s("td",[e._v("Perform an action that undoes prior action(s)")])]),e._v(" "),s("tr",[s("td",[e._v("2")]),e._v(" "),s("td",[e._v("Retry")]),e._v(" "),s("td",[e._v("Retry until success or timeout")])]),e._v(" "),s("tr",[s("td",[e._v("3")]),e._v(" "),s("td",[e._v("Ignore")]),e._v(" "),s("td",[e._v("Do nothing in the event of errors")])]),e._v(" "),s("tr",[s("td",[e._v("4")]),e._v(" "),s("td",[e._v("Restart")]),e._v(" "),s("td",[e._v("Reset to the original state & start again")])]),e._v(" "),s("tr",[s("td",[e._v("5")]),e._v(" "),s("td",[e._v("Tentative operation")]),e._v(" "),s("td",[e._v("Perform a tentative operation and confirm (or cancel) later")])])])]),e._v(" "),s("h3",{attrs:{id:"logging-for-keep-consistent"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#logging-for-keep-consistent"}},[e._v("#")]),e._v(" Logging for keep consistent:")]),e._v(" "),s("ul",[s("li",[s("strong",[e._v("Receiver-based message logging")]),e._v(" (RBML): involves sync writing every received message to stable storage before any actIon is taken on it.")]),e._v(" "),s("li",[s("strong",[e._v("Sender-based message logging")]),e._v(" (SBML): involves writing the message before it is sent.")]),e._v(" "),s("li",[s("strong",[e._v("Hybrid message logging")]),e._v(" (HML)")])]),e._v(" "),s("h2",{attrs:{id:"refs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#refs"}},[e._v("#")]),e._v(" Refs")]),e._v(" "),s("p",[e._v("https://martinfowler.com/articles/patterns-of-distributed-systems/")]),e._v(" "),s("p",[e._v("https://www.youtube.com/watch?v=nH4qjmP2KEE")])])}),[],!1,null,null,null);t.default=n.exports}}]);