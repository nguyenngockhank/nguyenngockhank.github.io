(window.webpackJsonp=window.webpackJsonp||[]).push([[189],{1304:function(e,t,a){"use strict";a.r(t);var r=a(7),s=Object(r.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"fault-tolerance-resilience-patterns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fault-tolerance-resilience-patterns"}},[e._v("#")]),e._v(" Fault Tolerance / Resilience Patterns")]),e._v(" "),a("TagLinks"),e._v(" "),a("p",[e._v("The "),a("strong",[e._v("Fault Tolerant")]),e._v(" means the ability of an architecture to survive (tolerate) when an environment misbehaves by taking corrective actions, e.g, surviving a server crash or preventing a misbehaving API from bringing down the whole system, etc.")]),e._v(" "),a("p",[e._v("The "),a("strong",[e._v("Fault Resilience")]),e._v(" is probably the capacity to recover from these type of scenarios quickly.")]),e._v(" "),a("p",[e._v("After further reading of Netflix blogs and wikis, it seemed the terms Fault Resilience and Fault Tolerant were used interchangeably.")]),e._v(" "),a("h2",{attrs:{id:"pattern-list"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pattern-list"}},[e._v("#")]),e._v(" Pattern List")]),e._v(" "),a("p",[e._v("There are various resilience patterns that can be applied to microservices, categorized by their impact on downstream and upstream components. Let's explore some of these patterns in detail.")]),e._v(" "),a("p",[a("img",{attrs:{src:"https://pbs.twimg.com/media/Fci8m7HaMAA9UTx?format=jpg&name=large",alt:"patterns"}})]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Pattern")]),e._v(" "),a("th",[e._v("Impact on")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[a("RouterLink",{attrs:{to:"/architect/patterns/retry.html"}},[e._v("Retry")]),e._v(" (exponential backoff, retry amplification)")],1),e._v(" "),a("td",[e._v("Downstream / Upstream")])]),e._v(" "),a("tr",[a("td",[a("RouterLink",{attrs:{to:"/architect/patterns/bulkhead.html"}},[e._v("Bulkhead")])],1),e._v(" "),a("td",[e._v("Downstream")])]),e._v(" "),a("tr",[a("td",[a("RouterLink",{attrs:{to:"/architect/patterns/circuit-breaker.html"}},[e._v("Circuit Breaker")])],1),e._v(" "),a("td",[e._v("Downstream")])]),e._v(" "),a("tr",[a("td",[e._v("Timeout")]),e._v(" "),a("td",[e._v("Downstream")])]),e._v(" "),a("tr",[a("td",[a("RouterLink",{attrs:{to:"/architect/patterns/rate-limiter.html"}},[e._v("Rate limiting")])],1),e._v(" "),a("td",[e._v("Upstream")])]),e._v(" "),a("tr",[a("td",[e._v("Load leveling")]),e._v(" "),a("td",[e._v("Upstream")])]),e._v(" "),a("tr",[a("td",[e._v("Load shedding")]),e._v(" "),a("td",[e._v("Upstream")])]),e._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#fallback"}},[e._v("Fallback")])]),e._v(" "),a("td",[e._v("Upstream")])]),e._v(" "),a("tr",[a("td",[e._v("Failover")]),e._v(" "),a("td",[e._v("Upstream")])]),e._v(" "),a("tr",[a("td",[a("a",{attrs:{href:"#stateless-services"}},[e._v("Stateless")])]),e._v(" "),a("td")])])]),e._v(" "),a("p",[e._v("These patterns are usually not used alone. To apply them effectively, we need to understand why we need them, how they work, and their limitations.")]),e._v(" "),a("h2",{attrs:{id:"fallback"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#fallback"}},[e._v("#")]),e._v(" Fallback")]),e._v(" "),a("p",[e._v("When the the service request fails after retry, we need an alternative response to the request. Fallback provides an alternative solution during a service request failure. When the circuit breaker trips and the circuit is open, a fallback logic can be started instead. The fallback logic typically does little or no processing, and return value. Fallback logic must have little chance of failing, because it is running as a result of a failure to begin with.")]),e._v(" "),a("p",[e._v("In this approach, the client process performs fallback logic when a request fails, such as returning cached data or a default value. This is an approach suitable for queries, and is more complex for updates or commands.")]),e._v(" "),a("h2",{attrs:{id:"deadlines-distributed-timeouts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#deadlines-distributed-timeouts"}},[e._v("#")]),e._v(" Deadlines / distributed timeouts")]),e._v(" "),a("p",[e._v("// TODO")]),e._v(" "),a("h2",{attrs:{id:"asynchronous-communication"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#asynchronous-communication"}},[e._v("#")]),e._v(" Asynchronous communication")]),e._v(" "),a("p",[e._v("Use Asynchronous communication (for example, "),a("RouterLink",{attrs:{to:"/architect/messaging.html#broker-based-messaging"}},[e._v("message-based communication")]),e._v(") across internal microservices")],1),e._v(" "),a("h2",{attrs:{id:"stateless-services"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#stateless-services"}},[e._v("#")]),e._v(" Stateless Services")]),e._v(" "),a("p",[e._v("To make sure our services are scalable, we need to make sure we build them in a stateless manner. By stateless, we mean that the service does not retain any state from the previous calls and treats every request as a fresh, new one. The advantage this approach gives us is that we can easily create replicas of the same service and make sure it does not matter which service instance is handling the request.")]),e._v(" "),a("p",[a("RouterLink",{attrs:{to:"/architect/patterns/stateless.html"}},[e._v("Read more")])],1),e._v(" "),a("h2",{attrs:{id:"correlation-id"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#correlation-id"}},[e._v("#")]),e._v(" Correlation ID")]),e._v(" "),a("p",[e._v("In a typical microservices-based application, several services span different systems, possibly separated by large geographical distances. This means each service must log useful and meaningful data that specifies what it has been doing and details any failures. This requires a third microservices resiliency pattern geared towards service tracking.")]),e._v(" "),a("p",[e._v("A correlation ID pattern creates an identifier for each individual request. This can help you track the complete flow of each HTTP request through all communication channels. You can set the correlation ID as part of the HTTP request header and include it in every log message, which will help you to quickly find errors, warnings and relevant debug messages.")]),e._v(" "),a("p",[e._v("While a correlation ID will illustrate the flow of a request from the source to the destination, a log aggregator pulls together the logs from all your microservices for easier search and analysis.")]),e._v(" "),a("p",[e._v("Detail: "),a("a",{attrs:{href:"https://www.techtarget.com/searchapparchitecture/tip/3-microservices-resiliency-patterns-for-better-reliability",target:"_blank",rel:"noopener noreferrer"}},[e._v("3 microservices resiliency patterns for better reliability"),a("OutboundLink")],1)]),e._v(" "),a("h2",{attrs:{id:"refs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#refs"}},[e._v("#")]),e._v(" Refs")]),e._v(" "),a("ul",[a("li",[a("a",{attrs:{href:"https://itnext.io/5-patterns-to-make-your-microservice-fault-tolerant-f3a1c73547b3",target:"_blank",rel:"noopener noreferrer"}},[e._v("5 patterns to make your microservice fault-tolerant"),a("OutboundLink")],1)]),e._v(" "),a("li",[a("a",{attrs:{href:"https://www.jrebel.com/blog/microservices-resilience-patterns",target:"_blank",rel:"noopener noreferrer"}},[e._v("Guide to Microservices Resilience Patterns"),a("OutboundLink")],1),e._v("\nhttps://newsletter.grokking.org/p/172-mo-hinh-vach-ngan-bulkhead-pattern-trong-thi-t-k-microservice-617401")])])],1)}),[],!1,null,null,null);t.default=s.exports}}]);