(window.webpackJsonp=window.webpackJsonp||[]).push([[4],{1592:function(e,t,a){"use strict";a.r(t);var s=a(7),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"digital-wallet"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#digital-wallet"}},[e._v("#")]),e._v(" Digital Wallet")]),e._v(" "),s("p",[e._v("Payment platforms usually provide a digital wallet service to clients, so they can store money in the wallet and spend it later. For example, you can add money to your digital wallet from your bank card and when you buy products online, you are given the option to pay using the money in your wallet. Figure 1 shows this process.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(806),alt:"img"}}),e._v(" "),s("em",[e._v("Figure 1 Digital wallet")])]),e._v(" "),s("p",[e._v("Spending money is not the only feature that the digital wallet provides. For a payment platform like PayPal, we can\ndirectly transfer money to somebody else’s wallet on the same payment platform. Compared with the bank-to-bank\ntransfer, direct transfer between digital wallets is faster, and most importantly, it usually does not charge an extra\nfee. Figure 2 shows a cross-wallet balance transfer operation.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(807),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 2 Cross-wallet balance transfer")])]),e._v(" "),s("p",[e._v("Suppose we are asked to design the backend of a digital wallet application that supports the cross-wallet balance\ntransfer operation. At the beginning of the interview, we will ask clarification questions to nail down the\nrequirements.")]),e._v(" "),s("h2",{attrs:{id:"step-1-understand-the-problem-and-establish-design-scope"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#step-1-understand-the-problem-and-establish-design-scope"}},[e._v("#")]),e._v(" Step 1 - Understand the Problem and Establish Design Scope")]),e._v(" "),s("p",[s("strong",[e._v("Candidate")]),e._v(": Should we only focus on balance transfer operations between two digital wallets? Do we need to worry\nabout other features?"),s("br"),e._v(" "),s("strong",[e._v("Interviewer")]),e._v(": Let's focus on balance transfer operations only.")]),e._v(" "),s("p",[s("strong",[e._v("Candidate")]),e._v(": How many transactions per second (TPS) does the system need to support?"),s("br"),e._v(" "),s("strong",[e._v("Interviewer")]),e._v(": Let's assume 1,000,000 TPS.")]),e._v(" "),s("p",[s("strong",[e._v("Candidate")]),e._v(": A digital wallet has strict requirements for correctness. Can we assume transactional guarantees [1] are\nsufficient?"),s("br"),e._v(" "),s("strong",[e._v("Interviewer")]),e._v(": That sounds good.")]),e._v(" "),s("p",[s("strong",[e._v("Candidate")]),e._v(": Do we need to prove correctness?"),s("br"),e._v(" "),s("strong",[e._v("Interviewer")]),e._v(": This is a good question. Correctness is usually only verifiable after a transaction is complete. One way to verify is to compare our internal records with statements from banks. The limitation of reconciliation is that it only shows discrepancies and cannot tell how a difference was generated. Therefore, we would like to design a system with reproducibility, meaning we could always reconstruct historical balance by replaying the data from the very beginning.")]),e._v(" "),s("p",[s("strong",[e._v("Candidate")]),e._v(": Can we assume the availability requirement is 99.99%"),s("br"),e._v(" "),s("strong",[e._v("Interviewer")]),e._v(": Sounds good,")]),e._v(" "),s("p",[s("strong",[e._v("Candidate")]),e._v(": Do we need to take foreign exchange into consideration?"),s("br"),e._v(" "),s("strong",[e._v("Interviewer")]),e._v(": No, it's out of scope.")]),e._v(" "),s("p",[e._v("In summary, our digital wallet needs to support the following:")]),e._v(" "),s("ul",[s("li",[e._v("Support 1,000,000 TPS.")]),e._v(" "),s("li",[e._v("Reliability is at least 99.99%.")]),e._v(" "),s("li",[e._v("Support transactions.")]),e._v(" "),s("li",[e._v("Support reproducibility.")])]),e._v(" "),s("h3",{attrs:{id:"back-of-the-envelope-estimation"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#back-of-the-envelope-estimation"}},[e._v("#")]),e._v(" Back-of-the-envelope estimation")]),e._v(" "),s("p",[e._v("When we talk about TPS, we imply a transactional database will be used. Today, a relational database running on a\ntypical data center node can support a few thousand transactions per second. For example, reference [2] contains\nthe performance benchmark of some of the popular transactional database servers. Let's assume a database node\ncan support 1,000 TPS. In order to reach 1 million TPS, we need 1,000 database nodes.")]),e._v(" "),s("p",[e._v("However, this calculation is slightly inaccurate. Each transfer command requires two operations: deducting money\nfrom one account and depositing money to the other account. To support 1 million transfers per second, the\nsystem actually needs to handle up to 2 million TPS, which means we need 2,000 nodes.")]),e._v(" "),s("p",[e._v('Table 1 shows the total number of nodes required when the “per-node TPS" (the TPS a single node can handle)\nchanges. Assuming hardware remains the same, the more transactions a single node can handle per second, the\nlower the total number of nodes required, indicating lower hardware cost. So one of our design goals is to increase\nthe number of transactions a single node can handle.')]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Per-node TPS")]),e._v(" "),s("th",[e._v("Node Number")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("100")]),e._v(" "),s("td",[e._v("20,000")])]),e._v(" "),s("tr",[s("td",[e._v("1,000")]),e._v(" "),s("td",[e._v("2,000")])]),e._v(" "),s("tr",[s("td",[e._v("10,000")]),e._v(" "),s("td",[e._v("200")])])])]),e._v(" "),s("p",[s("em",[e._v("Table 1 Mapping between pre-node TPS and node number")])]),e._v(" "),s("h2",{attrs:{id:"step-2-propose-high-level-design-and-get-buy-in"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#step-2-propose-high-level-design-and-get-buy-in"}},[e._v("#")]),e._v(" Step 2 - Propose High-Level Design and Get Buy-In")]),e._v(" "),s("p",[e._v("In this section, we will discuss the following:")]),e._v(" "),s("ul",[s("li",[e._v("API design")]),e._v(" "),s("li",[e._v("Three high-level designs\n"),s("ol",[s("li",[e._v("Simple in-memory solution")]),e._v(" "),s("li",[e._v("Database-based distributed transaction solution")]),e._v(" "),s("li",[e._v("Event sourcing solution with reproducibility")])])])]),e._v(" "),s("h3",{attrs:{id:"api-design"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#api-design"}},[e._v("#")]),e._v(" API Design")]),e._v(" "),s("p",[e._v("We will use the RESTful API convention. For this interview, we only need to support one API:")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("API")]),e._v(" "),s("th",[e._v("Detail")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("POST /v1/wallet/balance_transfer")]),e._v(" "),s("td",[e._v("Transfer balance from one wallet to another")])])])]),e._v(" "),s("p",[e._v("Request parameters are:")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Field")]),e._v(" "),s("th",[e._v("Description")]),e._v(" "),s("th",[e._v("Type")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("from_account")]),e._v(" "),s("td",[e._v("The debit account")]),e._v(" "),s("td",[e._v("string")])]),e._v(" "),s("tr",[s("td",[e._v("to_account")]),e._v(" "),s("td",[e._v("The credit account")]),e._v(" "),s("td",[e._v("string")])]),e._v(" "),s("tr",[s("td",[e._v("amount")]),e._v(" "),s("td",[e._v("The amount of money")]),e._v(" "),s("td",[e._v("string")])]),e._v(" "),s("tr",[s("td",[e._v("currency")]),e._v(" "),s("td",[e._v("The currency type")]),e._v(" "),s("td",[e._v("string (1SO 4217 [3])")])]),e._v(" "),s("tr",[s("td",[e._v("transaction_id")]),e._v(" "),s("td",[e._v("ID used for deduplication")]),e._v(" "),s("td",[e._v("uuid")])])])]),e._v(" "),s("p",[e._v("Sample response body:")]),e._v(" "),s("div",{staticClass:"language-json extra-class"},[s("pre",{pre:!0,attrs:{class:"language-json"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"Status"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"success"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"Transaction_id"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"@1589980-2664-1lec-9621-0242ac130002"')]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),s("p",[e._v("One thing worth mentioning is that the data type of the “amount” field is “string,” rather than “double”. We\nexplained the reasoning in the Payment System chapter.")]),e._v(" "),s("p",[e._v("In practice, many people still choose float or double representation of numbers because it is supported by almost\nevery programming language and database. It is a proper choice as long as we understand the potential risk of\nlosing precision.")]),e._v(" "),s("h3",{attrs:{id:"in-memory-sharding-solution"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#in-memory-sharding-solution"}},[e._v("#")]),e._v(" In-memory sharding solution")]),e._v(" "),s("p",[e._v("The wallet application maintains an account balance for every user account. A good data structure to represent this\n"),s("code",[e._v("<user, balance>")]),e._v(" relationship is a map, which is also called a hash table (map) or key-value store.")]),e._v(" "),s("p",[e._v("For in-memory stores, one popular choice is Redis. One Redis node is not enough to handle 1 million TPS. We need\nto set up a cluster of Redis nodes and evenly distribute user accounts among them. This process is called\npartitioning or sharding.")]),e._v(" "),s("p",[e._v("To distribute the key-value data among N partitions, we could calculate the hash value of the key and divide it by N.\nThe remainder is the destination of the partition. The pseudocode below shows the sharding process:")]),e._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("String")]),e._v(" accountID "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"A"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Int")]),e._v(" partitionNumber "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("7")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Int")]),e._v(" myPartition "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" accountID"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("hashCode")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("%")]),e._v(" partitionNumber"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),s("p",[e._v("The number of partitions and addresses of all Redis nodes can be stored in a centralized place. We could use\nZookeeper [4] as a highly-available configuration storage solution.\nThe final component of this solution is a service that handles the transfer commands. We call it the wallet service\nand it has several key responsibilities.")]),e._v(" "),s("ol",[s("li",[e._v("Receives the transfer command")]),e._v(" "),s("li",[e._v("Validates the transfer command")]),e._v(" "),s("li",[e._v("If the command is valid, it updates the account balances for the two users involved in the transfer. In a cluster,the account balances are likely to be in different Redis nodes")])]),e._v(" "),s("p",[e._v("The wallet service is stateless. It is easy to scale horizontally. Figure 3 shows the in-memory solution.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(808),alt:"img"}}),e._v(" "),s("em",[e._v("Figure 3 In-memory solution")])]),e._v(" "),s("p",[e._v("In this example, we have 3 Redis nodes. There are three clients, A, 8, and C. Their account balances are evenly\nspread across these three Redis nodes. There are two wallet service nodes in this example that handle the balance\ntransfer requests. When one of the wallet service nodes receives the transfer command which is to move $1 from\nclient A to client B, it issues two commands to two Redis nodes. For the Redis node that contains client A's account,\nthe wallet service deducts $1 from the account. For client B, the wallet service adds $1 to the account.")]),e._v(" "),s("p",[s("strong",[e._v("Candidate")]),e._v(": In this design, account balances are spread across multiple Redis nodes. Zookeeper is used to maintain\nthe sharding information. The stateless wallet service uses the sharding information to locate the Redis nodes for\nthe clients and updates the account balances accordingly.")]),e._v(" "),s("p",[s("strong",[e._v("Interviewer")]),e._v(": This design works, but it does not meet our correctness requirement. The wallet service updates two\nRedis nodes for each transfer. There is no guarantee that both updates would succeed. If, for example, the wallet\nservice node crashes after the first update has gone through but before the second update s done, it would result\nin an incomplete transfer. The two updates need to be in a single atomic transaction.")]),e._v(" "),s("h3",{attrs:{id:"distributed-transactions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#distributed-transactions"}},[e._v("#")]),e._v(" Distributed transactions")]),e._v(" "),s("h4",{attrs:{id:"database-sharding"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#database-sharding"}},[e._v("#")]),e._v(" Database sharding")]),e._v(" "),s("p",[e._v("How do we make the updates to two different storage nodes atomic? The first step is to replace each Redis node\nwith a transactional relational database node. Figure 4 shows the architecture. This time, clients A, 8, and C are\npartitioned into 3 relational databases, rather than in 3 Redis nodes.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(809),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 4 Relational database")])]),e._v(" "),s("p",[e._v("Using transactional databases only solves part of the problem. As mentioned in the last section, it is very likely that\none transfer command will need to update two accounts in two different databases. There is no guarantee that two\nupdate operations will be handled at exactly the same time. If the wallet service restarted right after it updated the\nfirst account balance, how can we make sure the second account will be updated as well?")]),e._v(" "),s("h4",{attrs:{id:"distributed-transaction-two-phase-commit"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#distributed-transaction-two-phase-commit"}},[e._v("#")]),e._v(" Distributed transaction: two-phase commit")]),e._v(" "),s("p",[e._v("In a distributed system, a transaction may involve multiple processes on multiple nodes. To make a transaction\natomic, the distributed transaction might be the answer. There are two ways to implement a distributed transaction:\nalow-level solution and a high-level solution. We will examine each of them.")]),e._v(" "),s("p",[e._v("The low-level solution relies on the database itself. The most commonly used algorithm is called two-phase commit\n(2PC). As the name implies, it has two phases, as in Figure 5.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(810),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 5 Two-phase commit")])]),e._v(" "),s("ol",[s("li",[e._v("The coordinator, which in our case is the wallet service, performs read and write operations on multiple\ndatabases as normal. As shown in Figure 5, both databases A and C are locked.")]),e._v(" "),s("li",[e._v("When the application is about to commit the transaction, the coordinator asks all databases to prepare the\ntransaction.")]),e._v(" "),s("li",[e._v("In the second phase, the coordinator collects replies from il databases and performs the following:\n"),s("ol",[s("li",[e._v('If all databases reply with a “yes", the coordinator asks all databases to commit the transaction they have received')]),e._v(" "),s("li",[e._v("If any database replies with a “no”, the coordinator asks all databases to abort the transaction.")])])])]),e._v(" "),s("p",[e._v("It is a low-level solution because the prepare step requires a special modification to the database transaction. For\nexample, there is an X/Open XA [6] standard that coordinates heterogeneous databases to achieve 2PC. The\nbiggest problem with 2PC is that it's not performant, as locks can be held for a very long time while waiting for a\nmessage from the other nodes. Another issue with 2PC is that the coordinator can be a single point of failure, as\nshown in Figure 6.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(811),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 6 Coordinator crashes")])]),e._v(" "),s("h4",{attrs:{id:"distributed-transaction-try-confirm-cancel-tc-c"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#distributed-transaction-try-confirm-cancel-tc-c"}},[e._v("#")]),e._v(" Distributed transaction: Try-Confirm/Cancel (TC/C)")]),e._v(" "),s("p",[e._v("TC/C is a type of compensating transaction [7] that has two steps:")]),e._v(" "),s("ol",[s("li",[e._v("In the first phase, the coordinator asks all databases to reserve resources for the transaction.")]),e._v(" "),s("li",[e._v("In the second phase, the coordinator collects replies from all databases:\n"),s("ol",[s("li",[e._v("If all databases reply with “yes”, the coordinator asks all databases to confirm the operation, which is the Try-Confirm process.")]),e._v(" "),s("li",[e._v("If any database replies with “no’, the coordinator asks all databases to cancel the operation, which is the Try-Cancel process.")])])])]),e._v(" "),s("p",[e._v("It's important to note that the two phases in 2PC are wrapped in the same transaction, but in TC/C each phase is a\nseparate transaction.")]),e._v(" "),s("p",[s("strong",[e._v("TC/C example")]),s("br"),e._v("\nIt would be much easier to explain how TC/C works with a real-world example. Suppose we want to transfer $1 from account A to account C. Table 2 gives a summary of how TC/C is executed in each phase.")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Phase")]),e._v(" "),s("th",[e._v("Operation")]),e._v(" "),s("th",[e._v("A")]),e._v(" "),s("th",[e._v("C")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("1")]),e._v(" "),s("td",[e._v("Try")]),e._v(" "),s("td",[e._v("Balance change: -$1")]),e._v(" "),s("td",[e._v("Do nothing")])]),e._v(" "),s("tr",[s("td",[e._v("2")]),e._v(" "),s("td",[e._v("Confirm")]),e._v(" "),s("td",[e._v("Do nothing")]),e._v(" "),s("td",[e._v("Balance change: +$1")])]),e._v(" "),s("tr",[s("td",[e._v("Cancel")]),e._v(" "),s("td",[e._v("Balance change: +$1")]),e._v(" "),s("td",[e._v("Do Nothing")]),e._v(" "),s("td")])])]),e._v(" "),s("p",[s("em",[e._v("Table 2 TC/C example")])]),e._v(" "),s("p",[e._v("Let's assume the wallet service is the coordinator of the TC/C. At the beginning of the distributed transaction account A has $1 its balance, and account C has $0")]),e._v(" "),s("p",[s("strong",[e._v("First phase: Try")]),s("br"),e._v("\nIn the Try phase, the wallet service, which acts as the coordinator, sends two transaction commands to two databases:")]),e._v(" "),s("ol",[s("li",[e._v("For the database that contains account A, the coordinator starts a local transaction that reduces the balance of\nA by $1")]),e._v(" "),s("li",[e._v("For the database that contains account C, the coordinator gives it a NOP (no operation.) To make the example adaptable for other scenarios, let's assume the coordinator sends to this database a NOP command. The database does nothing for NOP commands and always replies to the coordinator with a success message.")])]),e._v(" "),s("p",[e._v("The Try phase is shown in Figure 7. The thick line indicates that a lock is held by the transaction.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(812),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 7 Try phase")])]),e._v(" "),s("p",[s("strong",[e._v("Second phase: Confirm")]),s("br"),e._v("\nIf both databases reply “yes, the wallet service starts the next Confirm phase.")]),e._v(" "),s("p",[e._v("Account A's balance has already been updated in the first phase. The wallet service does not need to change its\nbalance. However, account C has not yet received its $1 from account A in the first phase. In the Confirm phase, the\nwallet service has to add $1 to account C's balance.")]),e._v(" "),s("p",[e._v("The Confirm process is shown in Figure 8.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(813),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 8 Confirm phas")]),e._v("e")]),e._v(" "),s("p",[s("strong",[e._v("Second phase: Cancel")]),s("br"),e._v("\nWhat if the first Try phase fails? In the example above we have assumed the NOP operation on account C always\nsucceeds, although in practice it may fail. For example, account C might be an illegal account, and the regulator has\nmandated that no money can flow into or out of this account. In this case, the distributed transaction must be\ncanceled and we have to clean up,")]),e._v(" "),s("p",[e._v("Because the balance of account A has already been updated in the transaction in the Try phase, it is impossible for\nthe wallet service to cancel a completed transaction. What it can do is to start another transaction that reverts the\neffect of the transaction in the Try phase, which is to add $1 back to account A.")]),e._v(" "),s("p",[e._v("Because account C was not updated in the Try phase, the wallet service just needs to send a NOP operation to\naccount C's database.")]),e._v(" "),s("p",[e._v("The Cancel process is shown in Figure 9.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(814),alt:"img"}}),e._v(" "),s("em",[e._v("Figure 9 Cancel phase")])]),e._v(" "),s("p",[s("strong",[e._v("Comparison between 2PC and TC/C")]),s("br"),e._v("\nTable 3 shows that there are many similarities between 2PC and TC/C, but there are also differences. In 2PC, all local\ntransactions are not done (still locked) when the second phase starts, while in TC/C, all local transactions are done\n(unlocked) when the second phase starts. In other words, the second phase of 2PC is about completing an\nunfinished transaction, such as an abort or commit, while in TC/C, the second phase is about using a reverse\noperation to offset the previous transaction result when an error occurs. The following table summarizes their\ndifferences.")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v(".")]),e._v(" "),s("th",[e._v("First Phase")]),e._v(" "),s("th",[e._v("Second Phase: success")]),e._v(" "),s("th",[e._v("Second Phase: fail")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("2PC")]),e._v(" "),s("td",[e._v("Local transactions are not done yet")]),e._v(" "),s("td",[e._v("Commit all local transactions "),s("br"),e._v(" Cancel all local transactions.")]),e._v(" "),s("td",[e._v("Cancel all local transactions")])]),e._v(" "),s("tr",[s("td",[e._v("TC/C")]),e._v(" "),s("td",[e._v("All local transactions are completed, either committed or canceled")]),e._v(" "),s("td",[e._v("Execute new local transactions if needed")]),e._v(" "),s("td",[e._v('Reverse the side effect of the already committed transaction, or called "undo"')])])])]),e._v(" "),s("p",[s("em",[e._v("Table 3 2PC vs TC/C")])]),e._v(" "),s("p",[e._v("TC/C s also called a distributed transaction by compensation. It is a high-level solution because the compensation,\nalso called the “undo,” is implemented in the business logic. The advantage of this approach is that it is database-\nagnostic. As long as a database supports transactions, TC/C will work. The disadvantage is that we have to manage\nthe details and handle the complexity of the distributed transactions in the business logic at the application layer.")]),e._v(" "),s("p",[s("strong",[e._v("Phase status table")])]),e._v(" "),s("p",[e._v("We still have not yet answered the question asked earlier; what if the wallet service restarts in the middle of TC/C?\nWhen it restarts, all previous operation history might be lost, and the system may not know how to recover.")]),e._v(" "),s("p",[e._v("The solution is simple. We can store the progress of a TC/C as phase status in a transactional database. The phase\nstatus includes at least the following information.")]),e._v(" "),s("ul",[s("li",[e._v("The ID and content of a distributed transaction.")]),e._v(" "),s("li",[e._v("The status of the Try phase for each database. The status could be “not sent yet', “has been sent’, and “response received\".")]),e._v(" "),s("li",[e._v('The name of the second phase. It could be “Confirm" or “Cancel.” It could be calculated using the result of the Try phase.')]),e._v(" "),s("li",[e._v("The status of the second phase.")]),e._v(" "),s("li",[e._v("An out-of-order flag (explained soon in the section “Out-of-Order Execution”),")])]),e._v(" "),s("p",[e._v("Where should we put the phase status tables? Usually, we store the phase status in the database that contains the\nwallet account from which money is deducted. The updated architecture diagram is shown in Figure 10.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(815),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 10 Phase status table")])]),e._v(" "),s("p",[s("strong",[e._v("Unbalanced state")])]),e._v(" "),s("p",[e._v("Have you noticed that by the end of the Try phase, $1 is missing (Figure 11)?")]),e._v(" "),s("p",[e._v("Assuming everything goes well, by the end of the Try phase, $1 is deducted from account A and account C remains\nunchanged. The sum of account balances in A and C will be $O, which is less than at the beginning of the TC/C. It\nviolates a fundamental rule of accounting that the sum should remain the same after a transaction.")]),e._v(" "),s("p",[e._v("The good news is that the transactional guarantee is still maintained by TC/C. TC/C comprises several independent\nlocal transactions. Because TC/C is driven by application, the application itself s able to see the intermediate result\nbetween these local transactions. On the other hand, the database transaction or 2PC version of the distributed\ntransaction was maintained by databases that are invisible to high-level applications.")]),e._v(" "),s("p",[e._v("There are always data discrepancies during the execution of distributed transactions. The discrepancies might be\ntransparent to us because lower-level systems such as databases already fixed the discrepancies. If not, we have to\nhandle it ourselves (for example, TC/C).")]),e._v(" "),s("p",[e._v("The unbalanced state is shown in Figure 11")]),e._v(" "),s("p",[s("img",{attrs:{src:a(816),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 11 Unbalanced state")])]),e._v(" "),s("p",[s("strong",[e._v("Valid operation orders")])]),e._v(" "),s("p",[e._v("There are three choices for the Try phase:")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v("Try phase choices")]),e._v(" "),s("th",[e._v("Account A")]),e._v(" "),s("th",[e._v("Account C")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("Choice 1")]),e._v(" "),s("td",[e._v("-$1")]),e._v(" "),s("td",[e._v("NOP")])]),e._v(" "),s("tr",[s("td",[e._v("Choice 2")]),e._v(" "),s("td",[e._v("NOP")]),e._v(" "),s("td",[e._v("+$1")])]),e._v(" "),s("tr",[s("td",[e._v("Choice 3")]),e._v(" "),s("td",[e._v("-$1")]),e._v(" "),s("td",[e._v("+$1")])])])]),e._v(" "),s("p",[s("em",[e._v("Table 4 Try phase choices")])]),e._v(" "),s("p",[e._v("All three choices look plausible, but some are not valid.")]),e._v(" "),s("p",[e._v("For choice 2, if the Try phase on account C is successful, but has failed on account A (NOP), the wallet service needs\nto enter the Cancel phase. There is a chance that somebody else may jump in and move the $1 away from account\nC. Later when the wallet service tries to deduct $1 from account C, it finds nothing is left, which violates the\ntransactional guarantee of a distributed transaction.")]),e._v(" "),s("p",[e._v("For choice 3, if $1 is deducted from account A and added to account C concurrently, it introduces lots of\ncomplications. For example, $1 is added to account C, but it fails to deduct the money from account A. What should\nwe do in this case?")]),e._v(" "),s("p",[e._v("Therefore, choice 2 and choice 3 are flawed choices and only choice 1 is valid.")]),e._v(" "),s("p",[s("strong",[e._v("Out-of-order execution")])]),e._v(" "),s("p",[e._v("One side effect of TC/C is the out-of-order execution. It will be much easier to explain using an example.")]),e._v(" "),s("p",[e._v("We reuse the above example which transfers $1 from account A to account C. As Figure 12 shows, in the Try phase,\nthe operation against account A fails and it retums a failure to the wallet service, which then enters the Cancel\nphase and sends the cancel operation to both account A and account C.")]),e._v(" "),s("p",[e._v("Let's assume that the database that handles account C has some network issues and it receives the Cancel\ninstruction before the Try instruction. In this case, there is nothing to cancel.\nThe out-of-order execution is shown in Figure 12.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(817),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 12 Out-of-order execution")])]),e._v(" "),s("p",[e._v("To handle out-of-order operations, each node is allowed to Cancel a TC/C without receiving a Try instruction, by\nenhancing the existing logic with the following updates")]),e._v(" "),s("ul",[s("li",[e._v("The out-of-order Cancel operation leaves a flag in the database indicating that it has seen a Cancel operation, but it has not seen a Try operation yet")]),e._v(" "),s("li",[e._v("The Try operation is enhanced so it always checks whether there is an out-of-order flag, and it returns a failure if there is.")])]),e._v(" "),s("p",[e._v('This is why we added an out-of-order flag to the phase status table in the "Phase Status Table” section,')]),e._v(" "),s("h3",{attrs:{id:"distributed-transaction-saga"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#distributed-transaction-saga"}},[e._v("#")]),e._v(" Distributed transaction: Saga")]),e._v(" "),s("p",[s("strong",[e._v("Linear order execution")])]),e._v(" "),s("p",[e._v("There is another popular distributed transaction solution called Saga [8]. Saga is the de-facto standard in a\nmicroservice architecture. The idea of Saga is simple:")]),e._v(" "),s("ol",[s("li",[e._v("All operations are ordered in a sequence. Each operation is an independent transaction on its own database.")]),e._v(" "),s("li",[e._v("Operations are evecuted from the first to the last. When one operation has finished, the next operation is triggered.")]),e._v(" "),s("li",[e._v("When an operation has failed, the entire process starts to roll back from the current operation to the first operation in reverse order, using compensating transactions. So if a distributed transaction has n operations,\nwe need to prepare 2n operations: n for the normal case and another n for the compensating transaction during rollback.")])]),e._v(" "),s("p",[e._v('It is easier to understand this by using an example. Figure 13 shows the Saga workflow to transfer $1 from account\nA to account C. The top horizontal line shows the normal order of execution. The two vertical lines show what the\nsystem should do when there is an error. When it encounters an error, the transfer operations are rolled back and\nthe client receives an error message. As we mentioned in the "Valid operation orders” section, we have to put the\ndeduction operation before the addition operation.')]),e._v(" "),s("p",[s("img",{attrs:{src:a(818),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 13 Saga workflow")])]),e._v(" "),s("p",[e._v("How do we coordinate the operations? There are two ways to do it:")]),e._v(" "),s("ol",[s("li",[e._v("Choreography. In a microservice architecture, all the services involved in the Saga distributed transaction do their jobs by subscribing to other services’ events. So it is fully decentralized coordination.")]),e._v(" "),s("li",[e._v("Orchestration. A single coordinator instructs il services to do their jobs in the correct order.")])]),e._v(" "),s("p",[e._v("The choice of which coordination model to use is determined by the business needs and goals. The challenge of\nthe choreography solution is that services communicate in a fully asynchronous way, so each service has to\nmaintain an internal state machine in order to understand what to do when other services emit an event. It can\nbecome hard to manage when there are many services. The orchestration solution handles complexity well, so it is\nusually the preferred solution in a digital wallet system.")]),e._v(" "),s("p",[s("strong",[e._v("Comparison between TC/C and Saga")])]),e._v(" "),s("p",[e._v("TC/C and Saga are both application-level distributed transactions. Table 5 summarizes their similarities and\ndifferences.")]),e._v(" "),s("table",[s("thead",[s("tr",[s("th",[e._v(".")]),e._v(" "),s("th",[e._v("TC/C")]),e._v(" "),s("th",[e._v("Saga")])])]),e._v(" "),s("tbody",[s("tr",[s("td",[e._v("Compensating action")]),e._v(" "),s("td",[e._v("In Cancel phase")]),e._v(" "),s("td",[e._v("In rollback phase")])]),e._v(" "),s("tr",[s("td",[e._v("Central coordination")]),e._v(" "),s("td",[e._v("Yes")]),e._v(" "),s("td",[e._v("Yes (orchestration mode)")])]),e._v(" "),s("tr",[s("td",[e._v("Operation execution order")]),e._v(" "),s("td",[e._v("any")]),e._v(" "),s("td",[e._v("linear")])]),e._v(" "),s("tr",[s("td",[e._v("Parallel execution possibility")]),e._v(" "),s("td",[e._v("Yes")]),e._v(" "),s("td",[e._v("No (linear execution)")])]),e._v(" "),s("tr",[s("td",[e._v("Could see the partial inconsistent status")]),e._v(" "),s("td",[e._v("Yes")]),e._v(" "),s("td",[e._v("Yes")])]),e._v(" "),s("tr",[s("td",[e._v("Application or database logic")]),e._v(" "),s("td",[e._v("Application")]),e._v(" "),s("td",[e._v("Application")])])])]),e._v(" "),s("p",[s("em",[e._v("Table 5 TC/C vs Saga")])]),e._v(" "),s("p",[e._v("Which one should we use in practice? The answer depends on the latency requirement. As Table 5 shows,\noperations in Saga have to be executed in linear order, but it is possible to execute them in parallel in TC/C. So the\ndecision depends on a few factors:")]),e._v(" "),s("ol",[s("li",[e._v("If there is no latency requirement, or there are very few services, such as our money transfer example, we can choose either of them. If we want to go with the trend in microservice architecture, choose Saga.")]),e._v(" "),s("li",[e._v("If the system is latency-sensitive and contains many services/operations, TC/C might be a better option.")])]),e._v(" "),s("p",[s("strong",[e._v("Candidate")]),e._v(": To make the balance transfer transactional, we replace Redis with a relational database, and use TC/C or\nSaga to implement distributed transactions.")]),e._v(" "),s("p",[s("strong",[e._v("Interviewer")]),e._v(": Great work! The distributed transaction solution works, but there might be cases where it doesn't work\nwell. For example, users might enter the wrong operations at the application level. In this case, the money we\nspecified might be incorrect. We need a way to trace back the root cause of the issue and audit all account\noperations. How can we do this?")]),e._v(" "),s("h3",{attrs:{id:"event-sourcing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#event-sourcing"}},[e._v("#")]),e._v(" Event sourcing")]),e._v(" "),s("h4",{attrs:{id:"background"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#background"}},[e._v("#")]),e._v(" Background")]),e._v(" "),s("p",[e._v("In real life, a digital wallet provider may be audited. These external auditors might ask some challenging questions,\nfor example:")]),e._v(" "),s("ol",[s("li",[e._v("Do we know the account balance at any given time?")]),e._v(" "),s("li",[e._v("How do we know the historical and current account balances are correct?")]),e._v(" "),s("li",[e._v("How do we prove that the system logic is correct after a code change?")])]),e._v(" "),s("p",[e._v("One design philosophy that systematically answers those questions is event sourcing, which is a technique developed in Domain-Driven Design (DDD) [9].")]),e._v(" "),s("h4",{attrs:{id:"definition"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#definition"}},[e._v("#")]),e._v(" Definition")]),e._v(" "),s("p",[e._v("There are four important terms in event sourcing.")]),e._v(" "),s("ol",[s("li",[e._v("Command")]),e._v(" "),s("li",[e._v("Event")]),e._v(" "),s("li",[e._v("State")]),e._v(" "),s("li",[e._v("State machine")])]),e._v(" "),s("p",[s("strong",[e._v("Command")]),s("br"),e._v("\nA command is the intended action from the outside world. For example, if we want to transfer $1 from client A to\nclient C, this money transfer request is a command.")]),e._v(" "),s("p",[e._v("In event sourcing, it is very important that everything has an order. So commands are usually put into a FIFO (first\nin, first out) queue.")]),e._v(" "),s("p",[s("strong",[e._v("Event")]),s("br"),e._v("\nCommand is an intention and not a fact because some commands may be invalid and cannot be fulfilled. For\nexample, the transfer operation will fail if the account balance becomes negative after the transfer.")]),e._v(" "),s("p",[e._v("A command must be validated before we do anything about it. Once the command passes the validation, it is valid\nand must be fulfilled. The result of the fulfillment is called an event.")]),e._v(" "),s("p",[e._v("There are two major differences between command and event.")]),e._v(" "),s("ol",[s("li",[e._v('Events must be executed because they represent a validated fact. In practice, we usually use the past tense for an event. If the command is “transfer $1 from A to ", the corresponding event would be “transferr'),s("strong",[e._v("ed")]),e._v(' $1 from A to C".')]),e._v(" "),s("li",[e._v("Commands may contain randomness or I/O, but events must be deterministic. Events represent historical facts.")])]),e._v(" "),s("p",[e._v("There are two important properties of the event generation process.")]),e._v(" "),s("ol",[s("li",[e._v("One command may generate any number of events. It could generate zero or more events.")]),e._v(" "),s("li",[e._v("Event generation may contain randomness, meaning it is not guaranteed that a command always generates the same event(s). The event generation may contain exteral I/O or random numbers. We will revisit this property in more detail near the end of the chapter.")])]),e._v(" "),s("p",[e._v("The order of events must follow the order of commands. So events are stored in a FIFO queue, as well,")]),e._v(" "),s("p",[s("strong",[e._v("State")]),s("br"),e._v("\nState is what will be changed when an event is applied. In the wallet system, state is the balances of all client\naccounts, which can be represented with a map data structure. The key is the account name or ID, and the value is\nthe account balance. Key-value stores are usually used to store the map data structure. The relational database can\nalso be viewed as a key-value store, where keys are primary keys and values are table rows.")]),e._v(" "),s("p",[s("em",[s("strong",[e._v("State machine")])]),e._v("\nA state machine drives the event sourcing process. It has two major functions.")]),e._v(" "),s("ol",[s("li",[e._v("Validate commands and generate events.")]),e._v(" "),s("li",[e._v("Apply event to update state.")])]),e._v(" "),s("p",[e._v("Event sourcing requires the behavior of the state machine to be deterministic. Therefore, the state machine itself\nshould never contain any randomness. For example, it should never read anything random from the outside using\nI/O, or use any random numbers. When it applies an event to a state, it should always generate the same result.")]),e._v(" "),s("p",[e._v("Figure 14 shows the static view of event sourcing architecture. The state machine is responsible for converting the\ncommand to an event and for applying the event. Because state machine has two primary functions, we usually\ndraw two state machines, one for validating commands and the other for applying events.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(819),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 14 Static view of event sourcing")])]),e._v(" "),s("p",[e._v("If we add the time dimension, Figure 15 shows the dynamic view of event sourcing. The system keeps receiving\ncommands and processing them, one by one.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(820),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 15 Dynamic view of event sourcing")])]),e._v(" "),s("h4",{attrs:{id:"wallet-service-example"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#wallet-service-example"}},[e._v("#")]),e._v(" Wallet service example")]),e._v(" "),s("p",[e._v("For the wallet service, the commands are balance transfer requests. These commands are put into a FIFO queue.\nOne popular choice for the command queue is Kafka [10]. The command queue is shown in Figure 16.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(821),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 16 Command queue")])]),e._v(" "),s("p",[e._v('Let us assume the state (the account balance) is stored in a relational database. The state machine examines each command one by one in FIFO order. For each command, it checks whether the account has a sufficient balance. If\nyes, the state machine generates an event for each account. For example, if the command is “A->$1->C", the state\nmachine generates two events: "A:-$1" and *C:+$1"')]),e._v(" "),s("p",[e._v("Figure 17 shows how the state machine works in 5 steps.")]),e._v(" "),s("ol",[s("li",[e._v("Read commands from the command queue.")]),e._v(" "),s("li",[e._v("Read balance state from the database.")]),e._v(" "),s("li",[e._v("Validate the command. If it is valid, generate two events for each of the accounts,")]),e._v(" "),s("li",[e._v("Read the next Event.")]),e._v(" "),s("li",[e._v("Apply the Event by updating the balance in the database.")])]),e._v(" "),s("p",[s("img",{attrs:{src:a(822),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 17 How state machine works")])]),e._v(" "),s("h4",{attrs:{id:"reproducibility"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reproducibility"}},[e._v("#")]),e._v(" Reproducibility")]),e._v(" "),s("p",[e._v("The most important advantage that event sourcing has over other architectures is reproducibility.")]),e._v(" "),s("p",[e._v("In the distributed transaction solutions mentioned earlier, a wallet service saves the updated account balance (the\nstate) into the database. It is difficult to know why the account balance was changed. Meanwhile, historical balance\ninformation is lost during the update operation. In the event sourcing design, all changes are saved first as\nimmutable history. The database is only used as an updated view of what balance looks like at any given point in\ntime.")]),e._v(" "),s("p",[e._v("We could always reconstruct historical balance states by replaying the events from the very beginning. Because the\nevent list is immutable and the state machine logic is deterministic, it is guaranteed that the historical states\ngenerated from each replay are the same.")]),e._v(" "),s("p",[e._v("Figure 18 shows how to reproduce the states of the wallet service by replaying the events.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(823),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 18 Reproduce states")])]),e._v(" "),s("p",[e._v("Reproducibility helps us answer the difficult questions that the auditors ask at the beginning of the section. We\nrepeat the questions here.")]),e._v(" "),s("ol",[s("li",[e._v("Do we know the account balance at any given time?")]),e._v(" "),s("li",[e._v("How do we know the historical and current account balances are correct?")]),e._v(" "),s("li",[e._v("How do we prove the system logic is correct after a code change?")])]),e._v(" "),s("p",[e._v("For the first question, we could answer it by replaying events from the start, up to the point in time where we would\nlike to know the account balance.")]),e._v(" "),s("p",[e._v("For the second question, we could verify the correctness of the account balance by recalculating it from the event\nlist.")]),e._v(" "),s("p",[e._v("For the third question, we can run different versions of the code against the events and verify that their results are\nidentical.")]),e._v(" "),s("p",[e._v("Because of the audit capability, event sourcing is often chosen as the de facto solution for the wallet service.")]),e._v(" "),s("h3",{attrs:{id:"command-query-responsibility-segregation-cqrs"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#command-query-responsibility-segregation-cqrs"}},[e._v("#")]),e._v(" Command-query responsibility segregation (CQRS)")]),e._v(" "),s("p",[e._v("So far, we have designed the wallet service to move money from one account to another efficiently. However, the\nclient still does not know what the account balance is. There needs to be a way to publish state (balance\ninformation) so the client, which is outside of the event sourcing framework, can know what the state is.")]),e._v(" "),s("p",[e._v("Intuitively, we can create a read-only copy of the database (historical state) and share it with the outside world.\nEvent sourcing answers this question in a slightly different way.")]),e._v(" "),s("p",[e._v("Rather than publishing the state (balance information), event sourcing publishes all the events. The external world\ncould rebuild any customized state itself. This design philosophy is called CQRS [11].")]),e._v(" "),s("p",[e._v("In CQRS, there is one state machine responsible for the write part of the state, but there can be many read-only\nstate machines, which are responsible for building views of the states. Those views could be used for queries.")]),e._v(" "),s("p",[e._v("These read-only state machines can derive different state representations from the event queue. For example,\nclients may want to know their balances and a read-only state machine could save state in a database to serve the\nbalance query. Another state machine could build state for a specific time period to help investigate issues like\npossible double charges. The state information is an audit trail that could help to reconcile the financial records.")]),e._v(" "),s("p",[e._v("The read-only state machines lag behind to some extent, but will always catch up. The architecture design is\neventually consistent.")]),e._v(" "),s("p",[e._v("Figure 19 shows a classic CQRS architecture.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(824),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 19 CQRS architecture")])]),e._v(" "),s("p",[s("strong",[e._v("Candidate")]),e._v(": In this design, we use event sourcing architecture to make the whole system reproducible. Al valid\nbusiness records are saved in an immutable Event queue which could be used for correctness verification.")]),e._v(" "),s("p",[s("strong",[e._v("Interviewer")]),e._v(": That's great. But the event sourcing architecture you proposed only handles one event at a time and it\nneeds to communicate with several external systems. Can we make it faster?")]),e._v(" "),s("h2",{attrs:{id:"step-3-design-deep-dive"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#step-3-design-deep-dive"}},[e._v("#")]),e._v(" Step 3 - Design Deep Dive")]),e._v(" "),s("p",[e._v("In this section, we dive deep into techniques for achieving high performance, reliability, and scalability.")]),e._v(" "),s("h3",{attrs:{id:"high-performance-event-sourcing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#high-performance-event-sourcing"}},[e._v("#")]),e._v(" High-performance event sourcing")]),e._v(" "),s("p",[e._v("In the earlier example, we used Kafka as the command and event store, and the database as a state store. Let's\nexplore some optimizations.")]),e._v(" "),s("h4",{attrs:{id:"file-based-command-and-event-list"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#file-based-command-and-event-list"}},[e._v("#")]),e._v(" File-based command and event list")]),e._v(" "),s("p",[e._v("The first optimization is to save commands and events to a local disk, rather than to a remote store like Kafka. This\navoids transit time across the network. The event list uses an append-only data structure. Appending is a sequential\nwrite operation, which is generally very fast. It works well even for magnetic hard drives because the operating\nsystem is heavily optimized for sequential reads and writes. According to this ACM Queue article [12], sequential\ndisk access can be faster than random memory access in some cases.")]),e._v(" "),s("p",[e._v("The second optimization is to cache recent commands and events in memory. As we explained before, we process\ncommands and events right after they are persisted. We may cache them in memory to save the time of loading\nthem back from the local disk.")]),e._v(" "),s("p",[e._v("We are going to explore some implementation details. A technique called mmap [13] is great for implementing the\noptimizations mentioned previously. Mmap can write to a local disk and cache recent content in memory at the\nsame time. It maps a disk file to memory as an array. The operating system caches certain sections of the file in\nmemory to accelerate the read and write operations. For append-only file operations, it is almost guaranteed that\nall data are saved in memory, which is very fast.")]),e._v(" "),s("p",[e._v("Figure 20 shows the file-based command and event storage.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(825),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 20 File-based command and event storage")])]),e._v(" "),s("h4",{attrs:{id:"file-based-state"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#file-based-state"}},[e._v("#")]),e._v(" File-based state")]),e._v(" "),s("p",[e._v("In the previous design, state (balance information) is stored in a relational database. In a production environment, a\ndatabase usually runs in a stand-alone server that can only be accessed through networks. Similar to the\noptimizations we did for command and event, state information can be saved to the local disk, as well.")]),e._v(" "),s("p",[e._v("More specifically, we can use SQLite [14], which is a file-based local relational database or use RocksDB [15], which\nis a local file-based key-value store.")]),e._v(" "),s("p",[e._v("RocksDB is chosen because it uses a log-structured merge-tree (LSM), which is optimized for write operations. To\nimprove read performance, the most recent data is cached.")]),e._v(" "),s("p",[e._v("Figure 21 shows the file-based solution for command, event, and state.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(826),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 21 File-based solution for command, event, and state")])]),e._v(" "),s("h4",{attrs:{id:"snapshot"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#snapshot"}},[e._v("#")]),e._v(" Snapshot")]),e._v(" "),s("p",[e._v("Once everything is file-based, let us consider how to accelerate the reproducibility process. When we first\nintroduced reproducibility, the state machine had to process events from the very beginning, every time. What we\ncould optimize is to periodically stop the state machine and save the current state into a file. This is called a\nsnapshot.")]),e._v(" "),s("p",[e._v("A snapshot is an immutable view of a historical state. Once a snapshot is saved, the state machine does not have to\nrestart from the very beginning anymore. It can read data from a snapshot, verify where it left off, and resume\nprocessing from there.")]),e._v(" "),s("p",[e._v("For financial applications such as wallet service, the finance team often requires a snapshot to be taken at 00:00 so\nthey can verify all transactions that happened during that day. When we first introduced CQRS of event sourcing,\nthe solution was to set up a read-only state machine that reads from the beginning until the specified time is met.\nWith snapshots, a read-only state machine only needs to load one snapshot that contains the data.")]),e._v(" "),s("p",[e._v("A snapshot i a giant binary file and a common solution is to save it in an object storage solution, such as HDFS\n[16].")]),e._v(" "),s("p",[e._v("Figure 22 shows the file-based event sourcing architecture. When everything is file-based, the system can fully\nutilize the maximum I/O throughput of the computer hardware.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(827),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 22 Snapshot")])]),e._v(" "),s("p",[s("strong",[e._v("Candidate")]),e._v(": We could refactor the design of event sourcing so the command list, event list, state, and snapshot are\nall saved in files. Event sourcing architecture processes the event list in a linear manner, which fits well into the\ndesign of hard disks and operating system cache.")]),e._v(" "),s("p",[s("strong",[e._v("Interviewer")]),e._v(": The performance of the local file-based solution is better than the system that requires accessing data\nfrom remote Kafka and databases. However, there is another problem: because data is saved on a local disk, a\nserver is now stateful and becomes a single point of failure. How do we improve the reliability of the system?")]),e._v(" "),s("h3",{attrs:{id:"reliable-high-performance-event-sourcing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reliable-high-performance-event-sourcing"}},[e._v("#")]),e._v(" Reliable high-performance event sourcing")]),e._v(" "),s("p",[e._v("Before we explain the solution, let’s examine the parts of the system that need the reliability guarantee.")]),e._v(" "),s("h4",{attrs:{id:"reliability-analysis"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reliability-analysis"}},[e._v("#")]),e._v(" Reliability analysis")]),e._v(" "),s("p",[e._v("Conceptually, everything a node does is around two concepts; data and computation. As long as data is durable, it's\neasy to recover the computational result by running the same code on another node. This means we only need to\nworry about the reliability of data because if data is lost, it is lost forever. The reliability of the system is mostly\nabout the reliability of the data.")]),e._v(" "),s("p",[e._v("There are four types of data in our system.")]),e._v(" "),s("ol",[s("li",[e._v("File-based command")]),e._v(" "),s("li",[e._v("File-based event")]),e._v(" "),s("li",[e._v("File-based state")]),e._v(" "),s("li",[e._v("State snapshot")])]),e._v(" "),s("p",[e._v("Let us take a close look at how to ensure the reliability of each type of data.")]),e._v(" "),s("p",[e._v("State and snapshot can always be regenerated by replaying the event list. To improve the reliability of state and\nsnapshot, we just need to ensure the event list has strong reliability.")]),e._v(" "),s("p",[e._v("Now let us examine command. On the face of it, event is generated from command. We might think providing a\nstrong reliability guarantee for command should be sufficient. This seems to be correct at first glance, but it misses\nsomething important. Event generation is not guaranteed to be deterministic, and also it may contain random\nfactors such as random numbers, external 1/O, etc. So command cannot guarantee reproducibility of events.")]),e._v(" "),s("p",[e._v("Now it's time to take a close look at event. Event represents historical facts that introduce changes to the state\n(account balance) Event is immutable and can be used to rebuild the state.")]),e._v(" "),s("p",[e._v("From this analysis, we conclude that event data is the only one that requires a high-reliability guarantee. We will\nexplain how to achieve this in the next section.")]),e._v(" "),s("h4",{attrs:{id:"consensus"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#consensus"}},[e._v("#")]),e._v(" Consensus")]),e._v(" "),s("p",[e._v("To provide high reliability, we need to replicate the event list across multiple nodes. During the replication process,\nwe have to guarantee the following properties.")]),e._v(" "),s("ol",[s("li",[e._v("No data loss.")]),e._v(" "),s("li",[e._v("The relative order of data within a log file remains the same across nodes.")])]),e._v(" "),s("p",[e._v("To achieve those guarantees, consensus-based replication is A good fit. The consensus algorithm makes sure that\nmultiple nodes reach a consensus on what the event list is. Let's use the Raft [17] consensus algorithm as an\nexample.")]),e._v(" "),s("p",[e._v("The Raft algorithm guarantees that as long as more than half of the nodes are online, the append-only lists on\nthem have the same data. For example, if we have 5 nodes and use the Raft algorithm to synchronize their data, as\nlong as at least 3 (more than half) of the nodes are up as Figure 23 shows, the system can still work properly as a\nwhole:")]),e._v(" "),s("p",[s("img",{attrs:{src:a(828),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 23 Raft")])]),e._v(" "),s("p",[e._v("Anode can have three different roles in the Raft algorithm.")]),e._v(" "),s("ol",[s("li",[e._v("Leader")]),e._v(" "),s("li",[e._v("Candidate")]),e._v(" "),s("li",[e._v("Follower")])]),e._v(" "),s("p",[e._v("We can find the implementation of the Raft algorithm in the Raft paper. We will only cover the high level concepts\nhere and not go into detail. In Raft, at most one node is the leader of the cluster and the remaining nodes are\nfollowers. The leader is responsible for receiving external commands and replicating data reliably across nodes in\nthe cluster.")]),e._v(" "),s("p",[e._v("With the Raft algorithm, the system is reliable as long as the majority of the nodes are operational. For example, if\nthere are 3 nodes in the cluster, it could tolerate the failure of 1 node, and if there are 5 nodes, it can tolerate the\nfailure of 2 nodes")]),e._v(" "),s("h4",{attrs:{id:"reliable-solution"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#reliable-solution"}},[e._v("#")]),e._v(" Reliable solution")]),e._v(" "),s("p",[e._v("With replication, there won't be single point of failure in our file-based event sourcing architecture. Let's take a\nlook at the implementation details. Figure 24 shows the event sourcing architecture with the reliability guarantee.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(829),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 24 Raft node group")])]),e._v(" "),s("p",[e._v("In Figure 24, we set up 3 event sourcing nodes. These nodes use the Raft algorithm to synchronize the event list\nreliably.")]),e._v(" "),s("p",[e._v("The leader takes incoming command requests from external users, converts them into events, and appends events\ninto the local event list. The Raft algorithm replicates newly added events to the followers.")]),e._v(" "),s("p",[e._v("All nodes, including the followers, process the event list and update the state. The Raft algorithm ensures the leader\nand followers have the same event lists, while event sourcing guarantees all states are the same, as long as the\nevent lists are the same.")]),e._v(" "),s("p",[e._v("A reliable system needs to handie failures gracefully, so let's explore how node crashes are handied.\nIf the leader crashes, the Raft algorithm automatically selects a new leader from the remaining healthy nodes. This\nnewly elected leader takes responsibility for accepting commands from external users. It is guaranteed that the\ncluster as a whole can provide continued service when a node goes down.")]),e._v(" "),s("p",[e._v("When the leader crashes, it is possible that the crash happens before the command list is converted to events. In\nthis case, the client would notice the issue either by a timeout or by receiving an error response. The client needs to\nresend the same command to the newly elected leader.")]),e._v(" "),s("p",[e._v("In contrast, follower crashes are much easier to handle. If a follower crashes, requests sent to it will fail. Raft handles failures by retrying indefinitely until the crashed node is restarted or a new one replaces it.")]),e._v(" "),s("p",[s("strong",[e._v("Candidate")]),e._v(": In this design, we use the Raft consensus algorithm to replicate the event list across multiple nodes. The leader receives commands and replicates events to other nodes.")]),e._v(" "),s("p",[s("strong",[e._v("Interviewer")]),e._v(": Yes, the system is more reliable and fault-tolerant. However, in order to handle 1 million TPS, one\nserver is not enough. How can we make the system more scalable?")]),e._v(" "),s("h3",{attrs:{id:"distributed-event-sourcing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#distributed-event-sourcing"}},[e._v("#")]),e._v(" Distributed event sourcing")]),e._v(" "),s("p",[e._v("In the previous section, we explained how to implement a reliable high-performance event sourcing architecture. It\nsolves the reliability issue, but it has two limitations.")]),e._v(" "),s("ol",[s("li",[e._v("When a digital wallet is updated, we want to receive the updated result immediately. But in the CQRS design,\nthe request/response flow can be slow. This is because a client doesn't know exactly when a digital wallet is\nupdated and the client may need to rely on periodic polling.")]),e._v(" "),s("li",[e._v("The capacity of a single Raft group is limited. At a certain scale, we need to shard the data and implement\ndistributed transactions.")])]),e._v(" "),s("p",[e._v("Let's take a look at how those two problems are solved.")]),e._v(" "),s("h4",{attrs:{id:"pull-vs-push"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#pull-vs-push"}},[e._v("#")]),e._v(" Pull vs push")]),e._v(" "),s("p",[e._v("In the pull model, an external user periodically polls execution status from the read-only state machine. This model\nis not real-time and may overload the wallet service if the polling frequency is set too high. Figure 25 shows the\npulling model.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(830),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 25 Periodical pulling")])]),e._v(" "),s("p",[e._v("The naive pull model can be improved by adding a reverse proxy [18] between the extemal user and the event\nsourcing node. In this design, the external user sends a command to the reverse proxy, which forwards the\ncommand to event sourcing nodes and periodically polls the execution status. This design simplifies the client logic,\nbut the communication is still not real-time.")]),e._v(" "),s("p",[e._v("Figure 26 shows the pull model with a reverse proxy added,")]),e._v(" "),s("p",[s("img",{attrs:{src:a(831),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 26 Pull model with reverse proxy")])]),e._v(" "),s("p",[e._v("Once we have the reverse proxy, we could make the response faster by modifying the read-only state machine. As\nwe mentioned earlier, the read-only state machine could have its own behavior. For example, one behavior could\nbe that the read-only state machine pushes execution status back to the reverse proxy, as soon as it receives the\nevent. This will give the ser a feeling of real-time response.")]),e._v(" "),s("p",[e._v("Figure 27 shows the push-based model")]),e._v(" "),s("p",[s("img",{attrs:{src:a(832),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 27 Push model")])]),e._v(" "),s("h4",{attrs:{id:"distributed-transaction"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#distributed-transaction"}},[e._v("#")]),e._v(" Distributed transaction")]),e._v(" "),s("p",[e._v("Once synchronous execution is adopted for every event sourcing node group, we can reuse the distributed\ntransaction solution, TC/C or Saga. Assume we partition the data by dividing the hash value of keys by 2.")]),e._v(" "),s("p",[e._v("Figure 28 shows the updated design.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(833),alt:"img"}}),s("br"),e._v(" "),s("em",[e._v("Figure 28 Final design")])]),e._v(" "),s("p",[e._v("Let's take a look at how the money transfer works in the final distributed event sourcing architecture. To make it\neasier to understand, we use the Saga distributed transaction model and only explain the happy path without any\nrollback.")]),e._v(" "),s("p",[e._v("The money transfer operation contains 2 distributed operations: A-$1 and C+$1. The Saga coordinator coordinates\nthe execution s shown in Figure 29:")]),e._v(" "),s("ol",[s("li",[e._v("User A sends a distributed transaction to the Saga coordinator. It contains two operations: A-$1 and C+$1")]),e._v(" "),s("li",[e._v("Saga coordinator creates a record in the phase status table to trace the status of a transaction.")]),e._v(" "),s("li",[e._v("Saga coordinator examines the order of operations and determines that it needs to handle A-$1 first. The coordinator sends A-$1 as a command to Partition 1, which contains account A's information.")]),e._v(" "),s("li",[e._v("Partition 1's Raft leader receives the A-$1 command and stores it in the command list. It then validates the command. If it is valid, it is converted into an event. The Raft consensus algorithm is used to synchronize data across different nodes. The event (deducting $1 from A's account balance) is executed after synchronization is complete.")]),e._v(" "),s("li",[e._v("After the event is synchronized, the event sourcing framework of Partition 1 synchronizes the data to the read path using CQRS. The read path reconstructs the state and the status of execution.")]),e._v(" "),s("li",[e._v("The read path of Partition 1 pushes the status back to the caller of the event sourcing framework, which is the Saga coordinator.")]),e._v(" "),s("li",[e._v("Saga coordinator receives the success status from Partition 1")]),e._v(" "),s("li",[e._v("The Saga coordinator creates a record, indicating the operation in Partition 1 is successful, in the phase status table.")]),e._v(" "),s("li",[e._v("Because the first operation succeeds, the Saga coordinator executes the second operation, which is C+$1. The coordinator sends C+$1 as a command to Partition 2 which contains account C's information")]),e._v(" "),s("li",[e._v("Partition 2's Raft leader receives the C+$1 command and saves it to the command list. If it is valid, it is converted into an event. The Raft consensus algorithm is used to synchronize data across different nodes. The event (add $1 to C's account ) is executed after synchronization is complete.")]),e._v(" "),s("li",[e._v("After the event is synchronized, the event sourcing framework of Partition 2 synchronizes the data to the read\npath using CQRS. The read path reconstructs the state and the status of execution.")]),e._v(" "),s("li",[e._v("The read path of Partition 2 pushes the status back to the caller of the event sourcing framework, which is the Saga coordinator.")]),e._v(" "),s("li",[e._v("The Saga coordinator receives the success status from Partition 2.")]),e._v(" "),s("li",[e._v("The Saga coordinator creates a record, indicating the operation in Partition 2 is successful in the phase status table.")]),e._v(" "),s("li",[e._v("At this time, all operations succeed and the distributed transaction is completed. The Saga coordinator responds to its caller with the result.")])]),e._v(" "),s("p",[s("img",{attrs:{src:a(834),alt:"img"}})]),e._v(" "),s("h2",{attrs:{id:"step-4-wrap-up"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#step-4-wrap-up"}},[e._v("#")]),e._v(" Step 4 - Wrap Up")]),e._v(" "),s("p",[e._v("In this chapter, we designed a wallet service that is capable of processing over 1 million payment commands per\nsecond. After a back-of-the-envelope estimation, we concluded that a few thousand nodes are required to support\nsuch a load.")]),e._v(" "),s("p",[e._v("In the first design, a solution using in-memory key-value stores like Redis is proposed. The problem with this design\nis that data isn't durable.")]),e._v(" "),s("p",[e._v("In the second design, the in-memory cache is replaced by transactional databases. To support multiple nodes,\ndifferent transactional protocols such as 2PC, TC/C, and Saga are proposed. The main issue with transaction-based\nsolutions is that we cannot conduct a data audit easily.")]),e._v(" "),s("p",[e._v("Next, event sourcing is introduced. We first implemented event sourcing using an external database and queue, but\nii's not performant. We improved performance by storing command, event, and state in a local node.")]),e._v(" "),s("p",[e._v("Asingle node means a single point of failure. To increase the system reliability, we use the Raft consensus algorithm\nto replicate the event list onto multiple nodes.")]),e._v(" "),s("p",[e._v("The last enhancement we made was to adopt the CQRS feature of event sourcing. We added a reverse proxy to\nchange the asynchronous event sourcing framework to a synchronous one for external users. The TC/C or Saga\nprotocol is used to coordinate Command executions across multiple node groups.")])])}),[],!1,null,null,null);t.default=n.exports},806:function(e,t,a){e.exports=a.p+"assets/img/f1.a04bf255.png"},807:function(e,t,a){e.exports=a.p+"assets/img/f2.3601d9f5.png"},808:function(e,t,a){e.exports=a.p+"assets/img/f3.2cc1bebe.png"},809:function(e,t,a){e.exports=a.p+"assets/img/f4.d6abcc9a.png"},810:function(e,t,a){e.exports=a.p+"assets/img/f5.78011d48.png"},811:function(e,t,a){e.exports=a.p+"assets/img/f6.b37518f8.png"},812:function(e,t,a){e.exports=a.p+"assets/img/f7.76d90854.png"},813:function(e,t,a){e.exports=a.p+"assets/img/f8.07d02c10.png"},814:function(e,t,a){e.exports=a.p+"assets/img/f9.fed29166.png"},815:function(e,t,a){e.exports=a.p+"assets/img/f10.6af1e2be.png"},816:function(e,t,a){e.exports=a.p+"assets/img/f11.b2b06aa6.png"},817:function(e,t,a){e.exports=a.p+"assets/img/f12.d7559d37.png"},818:function(e,t,a){e.exports=a.p+"assets/img/f13.409ecfda.png"},819:function(e,t,a){e.exports=a.p+"assets/img/f14.5cedca1c.png"},820:function(e,t,a){e.exports=a.p+"assets/img/f15.b05ac467.png"},821:function(e,t,a){e.exports=a.p+"assets/img/f16.fad8e53e.png"},822:function(e,t,a){e.exports=a.p+"assets/img/f17.0d64016c.png"},823:function(e,t,a){e.exports=a.p+"assets/img/f18.0e41b45f.png"},824:function(e,t,a){e.exports=a.p+"assets/img/f19.42c24efa.png"},825:function(e,t,a){e.exports=a.p+"assets/img/f20.223e24df.png"},826:function(e,t,a){e.exports=a.p+"assets/img/f21.80a3131d.png"},827:function(e,t,a){e.exports=a.p+"assets/img/f22.e2f19b2d.png"},828:function(e,t,a){e.exports=a.p+"assets/img/f23.a6dd89be.png"},829:function(e,t,a){e.exports=a.p+"assets/img/f24.af54bd25.png"},830:function(e,t,a){e.exports=a.p+"assets/img/f25.7e1fba08.png"},831:function(e,t,a){e.exports=a.p+"assets/img/f26.ba5a78ba.png"},832:function(e,t,a){e.exports=a.p+"assets/img/f27.8d017dc9.png"},833:function(e,t,a){e.exports=a.p+"assets/img/f28.dff39eec.png"},834:function(e,t,a){e.exports=a.p+"assets/img/f29.035fa064.png"}}]);