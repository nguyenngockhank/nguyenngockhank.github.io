(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{567:function(e,t,a){e.exports=a.p+"assets/img/image--058.367e78e6.jpg"},568:function(e,t,a){e.exports=a.p+"assets/img/image--059.e81720bd.jpg"},569:function(e,t,a){e.exports=a.p+"assets/img/image--060.260f4be5.jpg"},906:function(e,t,a){"use strict";a.r(t);var s=a(7),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"chapter-14-beyond-nosql"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#chapter-14-beyond-nosql"}},[e._v("#")]),e._v(" Chapter 14. Beyond NoSQL")]),e._v(" "),s("p",[e._v("The appearance of NoSQL databases has done a great deal to shake up and open up the world of\ndatabases, but we think the kind of NoSQL databases we have discussed here is only part of the\npicture of polyglot persistence. So it makes sense to spend some time discussing solutions that don’t\neasily fit into the NoSQL bucket.")]),e._v(" "),s("h2",{attrs:{id:"_14-1-file-systems"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-file-systems"}},[e._v("#")]),e._v(" 14.1. File Systems")]),e._v(" "),s("p",[e._v("Databases are very common, but file systems are almost ubiquitous. In the last couple of decades\nthey’ve been widely used for personal productivity documents, but not for enterprise applications.\nThey don’t advertise any internal structure, so they are more like key-value stores with a hierarchic\nkey. They also provide little control over concurrency other than simple file locking—which itself is\nsimilar to the way NoSQL only provides locking within a single aggregate.")]),e._v(" "),s("p",[e._v("File systems have the advantage of being simple and widely implemented. They cope well with\nvery large entities, such as video and audio. Often, databases are used to index media assets stored in\nfiles. Files also work very well for sequential access, such as streaming, which can be handy for data\nwhich is append-only.")]),e._v(" "),s("p",[e._v("Recent attention to clustered environments has seen a rise of distributed file systems. Technologies\nlike the Google File System and Hadoop [Hadoop] provide support for replication of files. Much of\nthe discussion of map-reduce is about manipulating large files on cluster systems, with tools for\nautomatic splitting of large files into segments to be processed on multiple nodes. Indeed a common\nentry path into NoSQL is from organizations that have been using Hadoop.")]),e._v(" "),s("p",[e._v("File systems work best for a relatively small number of large files that can be processed in big\nchunks, preferably in a streaming style. Large numbers of small files generally perform badly—this is\nwhere a data store becomes more efficient. Files also provide no support for queries without\nadditional indexing tools such as Solr [Solr].")]),e._v(" "),s("h2",{attrs:{id:"_14-2-event-sourcing"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-event-sourcing"}},[e._v("#")]),e._v(" 14.2. Event Sourcing")]),e._v(" "),s("p",[e._v("Event sourcing is an approach to persistence that concentrates on persisting all the changes to a\npersistent state, rather than persisting the current application state itself. It’s an architectural pattern\nthat works quite well with most persistence technologies, including relational databases. We mention\nit here because it also underpins some of the more unusual ways of thinking about persistence.")]),e._v(" "),s("p",[e._v("Consider an example of a system that keeps a log of the location of ships (Figure 14.1). It has a\nsimple ship record that keeps the name of the ship and its current location. In the usual way of\nthinking, when we hear that the ship "),s("em",[e._v("King Roy")]),e._v(" has arrived in San Francisco, we change the value of\n"),s("em",[e._v("King Roy")]),e._v(" ’s location field to San Francisco. Later on, we hear it’s departed, so we change it to at\nsea, changing it again once we know it’s arrived in Hong Kong.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(567),alt:"img"}})]),e._v(" "),s("p",[s("strong",[e._v("Figure 14.1. In a typical system, notice of a change causes an update to the application’s state.")])]),e._v(" "),s("p",[e._v("With an event-sourced system, the first step is to construct an event object that captures the\ninformation about the change (Figure 14.2). This event object is stored in a durable event log. Finally,\nwe process the event in order to update the application’s state.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(568),alt:"img"}})]),e._v(" "),s("p",[s("strong",[e._v("Figure 14.2. With event sourcing, the system stores each event, together with the derived application state.")])]),e._v(" "),s("p",[e._v("As a consequence, in an event-sourced system we store every event that’s caused a state change of\nthe system in the event log, and the application’s state is entirely derivable from this event log. At any\ntime, we can safely throw away the application state and rebuild it from the event log.")]),e._v(" "),s("p",[e._v("In theory, event logs are all you need because you can always recreate the application state\nwhenever you need it by replaying the event log. In practice, this may be too slow. As a result, it’s\nusually best to provide the ability to store and recreate the application state in a snapshot. A "),s("strong",[e._v("snapshot")]),e._v(" is designed to persist the memory image optimized for rapid recovery of the state. It is an\noptimization aid, so it should never take precedence over the event log for authority on the data.")]),e._v(" "),s("p",[e._v("How frequently you take a snapshot depends on your uptime needs. The snapshot doesn’t need to\nbe completely up to date, as you can rebuild memory by loading the latest snapshot and then replaying\nall events processed since that snapshot was taken. An example approach would be to take a snapshot\nevery night; should the system go down during the day, you’d reload last night’s snapshot followed by\ntoday’s events. If you can do that quickly enough, all will be fine.")]),e._v(" "),s("p",[e._v("To get a full record of every change in your application state, you need to keep the event log going\nback to the beginning of time for your application. But in many cases such a long-lived record isn’t\nnecessary, as you can fold older events into a snapshot and only use the event log after the date of the\nsnapshot.")]),e._v(" "),s("p",[e._v("Using event sourcing has a number of advantages. You can broadcast events to multiple systems,\neach of which can build a different application state for different purposes (Figure 14.3). For read-\nintensive systems, you can provide multiple read nodes, with potentially different schemas, while\nconcentrating the writes on a different processing system (an approach broadly known as CQRS\n[CQRS]).")]),e._v(" "),s("p",[s("img",{attrs:{src:a(569),alt:"img"}})]),e._v(" "),s("p",[s("strong",[e._v("Figure 14.3. Events can be broadcast to multiple display systems.")])]),e._v(" "),s("p",[e._v("Event sourcing is also an effective platform for analyzing historic information, since you can\nreplicate any past state in the event log. You can also easily investigate alternative scenarios by")]),e._v(" "),s("p",[e._v("introducing hypothetical events into an analysis processor.")]),e._v(" "),s("p",[e._v("Event sourcing does add some complexity—most notably, you have to ensure that all state changes\nare captured and stored as events. Some architectures and tools can make that inconvenient. Any\ncollaboration with external systems needs to take the event sourcing into account; you’ll need to be\ncareful of external side effects when replaying events to rebuild an application state.")]),e._v(" "),s("h2",{attrs:{id:"_14-3-memory-image"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-3-memory-image"}},[e._v("#")]),e._v(" 14.3. Memory Image")]),e._v(" "),s("p",[e._v("One the consequences of event sourcing is that the event log becomes the definitive persistent record\n—but it is not necessary for the application state to be persistent. This opens up the option of keeping\nthe application state in memory using only in-memory data structures. Keeping all your working data\nin memory provides a performance advantage, since there’s no disk I/O to deal with when an event is\nprocessed. It also simplifies programming since there is no need to perform mapping between disk\nand in-memory data structures.")]),e._v(" "),s("p",[e._v("The obvious limitation here is that you must be able to store all the data you’ll need to access in\nmemory. This is an increasingly viable option—we can remember disk sizes that were considerably\nless than the current memory sizes. You also need to ensure that you can recover quickly enough from\na system crash—either by reloading events from the event log or by running a duplicate system and\ncutting over.")]),e._v(" "),s("p",[e._v("You’ll need some explicit mechanism to deal with concurrency. One route is a transactional\nmemory system, such as the one that comes with the Clojure language. Another route is to do all input\nprocessing on a single thread. Designed carefully, a single-threaded event processor can achieve\nimpressive throughput at low latency [Fowler lmax].")]),e._v(" "),s("p",[e._v("Breaking the separation between in-memory and persistent data also affects how you handle errors.\nA common approach is to update a model and roll back any changes should an error occur. With a\nmemory image, you’ll usually not have an automated rollback facility; you either have to write your\nown (complicated) or ensure that you do thorough validation before you begin to apply any changes.")]),e._v(" "),s("h2",{attrs:{id:"_14-4-version-control"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-4-version-control"}},[e._v("#")]),e._v(" 14.4. Version Control")]),e._v(" "),s("p",[e._v("For most software developers, their most common experience of an event-sourced system is a version\ncontrol system. Version control allows many people on a team to coordinate their modifications of a\ncomplex interconnected system, with the ability to explore past states of that system and alternative\nrealities through branching.")]),e._v(" "),s("p",[e._v("When we think of data storage, we tend to think of a single-point-of-time worldview, which is very\nlimiting compared to the complexity supported by a version control system. It’s therefore surprising\nthat data storage tools haven’t borrowed some of the ideas from version control systems. After all,\nmany situations require historic queries and support for multiple views of the world.")]),e._v(" "),s("p",[e._v("Version control systems are built on top of file systems, and thus have many of the same limitations\nfor data storage as a file system. They are not designed for application data storage, so are awkward\nto use in that context. However, they are worth considering for scenarios where their timeline\ncapabilities are useful.")]),e._v(" "),s("h2",{attrs:{id:"_14-5-xml-databases"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-5-xml-databases"}},[e._v("#")]),e._v(" 14.5. XML Databases")]),e._v(" "),s("p",[e._v("Around the turn of the millennium, people seemed to want to use XML for everything, and there was a flurry of interest in databases specifically designed to store and query XML documents. While that\nflurry had as little impact on the relational dominance as previous blusters, XML databases are still\naround.")]),e._v(" "),s("p",[e._v("We think of XML databases as document databases where the documents are stored in a data\nmodel compatible with XML, and where various XML technologies are used to manipulate the\ndocument. You can use various forms of XML schema definitions (DTDs, XML Schema, RelaxNG)\nto check document formats, run queries with XPath and XQuery, and perform transformations with\nXSLT.")]),e._v(" "),s("p",[e._v("Relational databases took on XML and blended these XML capabilities with relational ones,\nusually by embedding XML documents as a column type and allowing some way to blend SQL and\nXML query languages.")]),e._v(" "),s("p",[e._v("Of course there’s no reason why you can’t use XML as a structuring mechanism within a key-value\nstore. XML is less fashionable these days than JSON, but is equally capable of storing complex\naggregates, and XML’s schema and query capabilities are greater than what you can typically get for\nJSON. Using an XML database means that the database itself is able to take advantage of the XML\nstructure and not just treat the value as a blob, but that advantage needs to be weighed with the other\ndatabase characteristics.")]),e._v(" "),s("h2",{attrs:{id:"_14-6-object-databases"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-6-object-databases"}},[e._v("#")]),e._v(" 14.6. Object Databases")]),e._v(" "),s("p",[e._v("When object-oriented programming started its rise in popularity, there was a flurry of interest in\nobject-oriented databases. The focus here was the complexity of mapping from in-memory data\nstructures to relational tables. The idea of an object-oriented database is that you avoid this\ncomplexity—the database would automatically manage the storage of in-memory structures onto disk.\nYou could think of it as a persistent virtual memory system, allowing you to program with persistence\nyet without taking any notice of a database at all.")]),e._v(" "),s("p",[e._v("Object databases didn’t take off. One reason was that the benefit of the close integration with the\napplication meant you couldn’t easily access data other than with that application. A shift from\nintegration databases to application databases could well make object databases more viable in the\nfuture.")]),e._v(" "),s("p",[e._v("An important issue with object databases is how to deal with migration as the data structures\nchange. Here, the close linkage between the persistent storage and in-memory structures can become a\nproblem. Some object databases include the ability to add migration functions to object definitions.")]),e._v(" "),s("h2",{attrs:{id:"_14-7-key-points"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_14-7-key-points"}},[e._v("#")]),e._v(" 14.7. Key Points")]),e._v(" "),s("ul",[s("li",[e._v("NoSQL is just one set of data storage technologies. As they increase comfort with polyglot persistence, we should consider other data storage technologies whether or not they bear the NoSQL label.")])])])}),[],!1,null,null,null);t.default=n.exports}}]);