(window.webpackJsonp=window.webpackJsonp||[]).push([[249],{1405:function(e,t,r){"use strict";r.r(t);var a=r(7),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"concurrency"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#concurrency"}},[e._v("#")]),e._v(" Concurrency")]),e._v(" "),r("h2",{attrs:{id:"terms"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#terms"}},[e._v("#")]),e._v(" Terms")]),e._v(" "),r("h3",{attrs:{id:"race-condition"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#race-condition"}},[e._v("#")]),e._v(" Race condition")]),e._v(" "),r("p",[e._v("Race conditions occur when multiple threads or processes access shared data concurrently, and the outcome depends on the unpredictable order of execution. Locking mechanisms are fundamental tools to prevent these issues.")]),e._v(" "),r("h3",{attrs:{id:"critical-section"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#critical-section"}},[e._v("#")]),e._v(" Critical section")]),e._v(" "),r("p",[e._v("A critical section is a part of a program where shared resources are accessed, and concurrent execution can lead to conflicts or inconsistencies.")]),e._v(" "),r("p",[r("strong",[e._v("Why Critical Sections are Important")])]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("Preventing race conditions")]),e._v(": Ensures data integrity and consistency.")]),e._v(" "),r("li",[r("strong",[e._v("Protecting shared resources")]),e._v(": Avoids conflicts when multiple threads or processes access the same data.")]),e._v(" "),r("li",[r("strong",[e._v("Guaranteeing correct program execution")]),e._v(": Ensures that operations on shared data are performed atomically")])]),e._v(" "),r("p",[e._v("E.g: Bank account")]),e._v(" "),r("h3",{attrs:{id:"deadlock"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#deadlock"}},[e._v("#")]),e._v(" Deadlock")]),e._v(" "),r("p",[e._v("A deadlock is a situation in concurrent programming where two or more processes or threads are blocked, each waiting for the other to release a resource. This creates a circular dependency, preventing any process from proceeding.")]),e._v(" "),r("p",[r("strong",[e._v("Conditions for Deadlock")])]),e._v(" "),r("p",[e._v("To occur, four conditions must be present simultaneously:")]),e._v(" "),r("ol",[r("li",[r("strong",[e._v("Mutual exclusion")]),e._v(": Resources are held exclusively by one process at a time.")]),e._v(" "),r("li",[r("strong",[e._v("Hold and wait")]),e._v(": A process holds at least one resource and is waiting for additional resources.")]),e._v(" "),r("li",[r("strong",[e._v("No preemption")]),e._v(": Resources cannot be forcibly taken away from a process; they must be released voluntarily.")]),e._v(" "),r("li",[r("strong",[e._v("Circular wait")]),e._v(": A chain of processes exists, where each process is waiting for a resource held by the next process in the chain.")])]),e._v(" "),r("p",[r("strong",[e._v("Mitigate the risk of deadlocks")])]),e._v(" "),r("ul",[r("li",[e._v("The "),r("strong",[e._v("timeout pattern")]),e._v(" is a strategy to mitigate the risk of deadlocks by imposing a time limit on resource acquisition attempts.")])]),e._v(" "),r("p",[r("strong",[e._v("Preventing Deadlock")])]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("Deadlock prevention")]),e._v(": Avoiding all four conditions simultaneously.")]),e._v(" "),r("li",[r("strong",[e._v("Deadlock avoidance")]),e._v(": Dynamically allocating resources to prevent deadlock.")]),e._v(" "),r("li",[r("strong",[e._v("Deadlock detection and recovery")]),e._v(": Allowing deadlocks to occur but detecting and resolving them.")])]),e._v(" "),r("h3",{attrs:{id:"atomicity"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#atomicity"}},[e._v("#")]),e._v(" Atomicity")]),e._v(" "),r("p",[e._v("Atomicity is a fundamental property in concurrent programming and database systems that guarantees that a sequence of operations is executed as a single, indivisible unit. This means that either all operations within the unit are completed successfully, or none of them are. There is no partial completion.")]),e._v(" "),r("h3",{attrs:{id:"thread-safe"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#thread-safe"}},[e._v("#")]),e._v(" Thread safe")]),e._v(" "),r("p",[e._v("Thread safety is a property of code that guarantees correct behavior when accessed by multiple threads concurrently. In simpler terms, it means that a piece of code can be executed by multiple threads without causing unexpected results, data corruption, or race conditions")]),e._v(" "),r("p",[r("strong",[e._v("Pure Functions - A Cornerstone of Thread Safety")])]),e._v(" "),r("p",[e._v("Pure functions are a powerful tool in achieving thread safety. They are functions that:")]),e._v(" "),r("ul",[r("li",[e._v("Always producethe same output for the same input.")]),e._v(" "),r("li",[e._v("Have no side effects (i.e., they don't modify any external state).")])]),e._v(" "),r("p",[r("strong",[e._v("Why are pure functions inherently thread-safe?")])]),e._v(" "),r("ul",[r("li",[r("strong",[e._v("No shared state")]),e._v(": Since pure functions don't rely on or modify external state, there's no possibility of race conditions.")]),e._v(" "),r("li",[r("strong",[e._v("Deterministic")]),e._v(": Given the same inputs, a pure function will always produce the same output, regardless of the execution context or thread.")]),e._v(" "),r("li",[r("strong",[e._v("Composable")]),e._v(": Pure functions can be easily combined and reused without worrying about unintended consequences.")])]),e._v(" "),r("h3",{attrs:{id:"pessimistic-locking"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#pessimistic-locking"}},[e._v("#")]),e._v(" Pessimistic Locking")]),e._v(" "),r("p",[e._v("Pessimistic locking is a concurrency control mechanism that operates under the premise that data conflicts or inconsistencies are probable when multiple users or processes access the same resource simultaneously.")]),e._v(" "),r("p",[r("strong",[e._v("Patterns")])]),e._v(" "),r("ul",[r("li",[e._v("Mutex (Mutual Exclusion)")]),e._v(" "),r("li",[e._v("Semaphore")]),e._v(" "),r("li",[e._v("Read-Write Locks")]),e._v(" "),r("li",[e._v("Database-Level Locking")])]),e._v(" "),r("h3",{attrs:{id:"optimistic-locking"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#optimistic-locking"}},[e._v("#")]),e._v(" Optimistic Locking")]),e._v(" "),r("p",[e._v("Optimistic locking is a concurrency control mechanism used in computer systems, particularly in databases, to manage concurrent access to shared resources with an optimistic assumption that conflicts are infrequent or less likely to occur.")]),e._v(" "),r("p",[r("strong",[e._v("Patterns")])]),e._v(" "),r("ul",[r("li",[e._v("Version Numbering")]),e._v(" "),r("li",[e._v("Timestamping")]),e._v(" "),r("li",[e._v("Check-and-Set (CAS)\n"),r("ul",[r("li",[e._v("A compare-and-swap atomic operation is used to update a value conditionally.")]),e._v(" "),r("li",[e._v("The operation compares the expected value with the current value.")]),e._v(" "),r("li",[e._v("If they match, the new value is set atomically.")]),e._v(" "),r("li",[e._v("If they don't match, the operation fails, indicating a conflict.")])])])]),e._v(" "),r("h3",{attrs:{id:"pessimistic-vs-optimistic"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#pessimistic-vs-optimistic"}},[e._v("#")]),e._v(" Pessimistic vs Optimistic")]),e._v(" "),r("p",[r("img",{attrs:{src:"https://i.pinimg.com/originals/64/a5/98/64a598fe190fb7675a80180d73fd7b5c.png",alt:"Pessimistic vs Optimistic"}})]),e._v(" "),r("p",[r("img",{attrs:{src:"https://i.pinimg.com/originals/d7/11/c1/d711c1351f7aaf035bcc9130e000ed98.jpg",alt:"Pessimistic Locking vs Optimistic Locking"}})]),e._v(" "),r("h2",{attrs:{id:"increasing-concurrency"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#increasing-concurrency"}},[e._v("#")]),e._v(" Increasing Concurrency")]),e._v(" "),r("p",[r("strong",[e._v("Thread Pool")]),e._v(": A thread pool is a collection of pre-initialized threads that are ready to perform tasks. Instead of creating a new thread for each task, a thread pool allows for the reuse of threads, reducing the overhead of thread creation. This pattern is particularly useful when dealing with a large number of short-lived tasks.")]),e._v(" "),r("p",[r("strong",[e._v("Asynchronous Programming")]),e._v(": Asynchronous programming allows tasks to be executed concurrently without blocking the main thread. By utilizing callbacks, promises, or async/await syntax, tasks can be initiated and executed in the background while the main thread continues with other operations. This pattern is especially effective when dealing with I/O-bound operations, such as network requests or file operations.")]),e._v(" "),r("p",[r("strong",[e._v("Parallel Processing")]),e._v(": Parallel processing involves dividing a task into smaller subtasks that can be executed simultaneously on multiple processing units. This pattern is commonly used in scenarios where a single task can be divided into independent parts that can be processed concurrently. Parallel processing can be achieved using multi-threading or distributed computing frameworks.")]),e._v(" "),r("p",[r("strong",[e._v("Event-driven Architecture")]),e._v(": In an event-driven architecture, components of a system communicate through events. When an event occurs, it triggers the execution of associated event handlers. This pattern allows for loose coupling between components and enables concurrent execution of tasks based on events. Event-driven architectures are commonly used in systems that require high scalability and responsiveness.")]),e._v(" "),r("p",[r("strong",[e._v("Caching")]),e._v(": Caching is a technique that stores frequently accessed data in memory to reduce the need for expensive computations or I/O operations. By caching data, multiple requests can be served concurrently without the need to access the underlying data source. Caching can significantly improve the performance and concurrency of a system, especially in scenarios where data access is a bottleneck.")]),e._v(" "),r("h2",{attrs:{id:"avoid-deadlocks"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#avoid-deadlocks"}},[e._v("#")]),e._v(" Avoid Deadlocks")]),e._v(" "),r("p",[r("strong",[e._v("Resource Ordering")]),e._v(":  establish a strict ordering of resources. By ensuring that all threads or processes request resources in the same order, the possibility of circular wait conditions, which can lead to deadlocks, is eliminated. This technique requires careful analysis and planning to determine the appropriate resource ordering.")]),e._v(" "),r("p",[r("strong",[e._v("Resource Allocation")]),e._v(": can detect and prevent deadlocks. For example, the Banker's algorithm is a well-known algorithm that can be used to allocate resources in a way that avoids deadlocks. It works by considering the available resources, the maximum resources each process can request, and the resources currently allocated to each process.")]),e._v(" "),r("p",[r("strong",[e._v("Locking and Synchronization")]),e._v(": Proper use of locks and synchronization mechanisms can help prevent deadlocks. By ensuring that resources are properly locked and released in a consistent manner, the chances of deadlocks occurring can be reduced. Techniques such as "),r("strong",[e._v("lock ordering")]),e._v(" and "),r("strong",[e._v("lock timeouts")]),e._v(" can be used to further enhance deadlock prevention.")]),e._v(" "),r("p",[r("strong",[e._v("Avoidance of Circular Wait")]),e._v(': Circular wait is a condition where each process is waiting for a resource held by another process in a circular chain. To avoid circular wait, a technique called "'),r("strong",[e._v("resource hierarchy")]),e._v('" can be used. In this technique, resources are assigned a unique identifier, and processes are required to acquire resources in increasing order of their identifiers. This ensures that circular wait conditions cannot occur.')]),e._v(" "),r("p",[r("strong",[e._v("Resource Preemption")]),e._v(": Preemptive resource allocation is a technique where a resource can be forcibly taken away from a process if it is needed by another process. By preempting resources, the possibility of deadlocks can be reduced. However, this technique should be used with caution, as it can introduce its own set of challenges and complexities.")]),e._v(" "),r("p",[r("strong",[e._v("Proper Error Handling")]),e._v(": Proper error handling and recovery mechanisms can also help prevent deadlocks. By detecting and handling errors related to resource allocation and deallocation, the system can avoid situations that can lead to deadlocks.")]),e._v(" "),r("h2",{attrs:{id:"problems-in-concurrency"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#problems-in-concurrency"}},[e._v("#")]),e._v(" Problems in Concurrency")]),e._v(" "),r("p",[r("strong",[e._v("Race Conditions")]),e._v(": A race condition occurs when multiple threads or processes access shared resources simultaneously, leading to unpredictable and incorrect results. For example, if two threads try to update the same variable concurrently, the final value may depend on the order of execution, leading to inconsistent or incorrect results.")]),e._v(" "),r("p",[r("strong",[e._v("Deadlocks")]),e._v(": A deadlock is a situation where two or more threads are blocked indefinitely, waiting for each other to release resources. Deadlocks can occur when multiple threads acquire resources in different orders, creating a circular dependency. This can result in a system freeze or unresponsiveness.")]),e._v(" "),r("p",[r("strong",[e._v("Starvation")]),e._v(": Starvation happens when a thread is unable to access a shared resource indefinitely due to resource contention. This can occur if a high-priority thread continuously acquires a resource, preventing lower-priority threads from accessing it. Starvation can lead to reduced system performance and fairness.")]),e._v(" "),r("p",[r("strong",[e._v("Thread Synchronization")]),e._v(": Synchronizing threads is essential to ensure data consistency and prevent race conditions. However, improper synchronization can introduce problems such as deadlocks or performance bottlenecks. It requires careful design and implementation to achieve the right balance between synchronization and performance.")]),e._v(" "),r("p",[r("strong",[e._v("Performance Bottlenecks")]),e._v(": Concurrency can introduce performance bottlenecks due to increased overhead in managing multiple threads or processes. Excessive context switching, contention for shared resources, or inefficient synchronization can degrade system performance.")]),e._v(" "),r("p",[r("strong",[e._v("Ordering and Visibility")]),e._v(": In concurrent systems, the order of execution and visibility of shared data can be challenging to manage. Inconsistent ordering or visibility can lead to unexpected behavior and bugs. Proper synchronization mechanisms, such as locks or atomic operations, are required to ensure correct ordering and visibility.")]),e._v(" "),r("p",[r("strong",[e._v("Testing and Debugging")]),e._v(": Concurrency-related bugs can be difficult to reproduce and debug due to their non-deterministic nature. Testing and debugging concurrent systems require specialized techniques and tools to identify and fix issues effectively.")]),e._v(" "),r("h2",{attrs:{id:"lamport-s-bakery-algorithm"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#lamport-s-bakery-algorithm"}},[e._v("#")]),e._v(" Lamport's bakery algorithm")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("Lamport's bakery algorithm")]),e._v(" "),r("p",[e._v("Lamport's bakery algorithm is a computer algorithm devised by computer scientist Leslie Lamport, as part of his long study of the formal correctness of concurrent systems, which is intended to improve the safety in the usage of shared resources among multiple threads by means of mutual exclusion.")])]),e._v(" "),r("h2",{attrs:{id:"references"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://medium.com/@lvhan/concurrent-programming-v%C3%A0-gcd-part-1-c701cf180de6",target:"_blank",rel:"noopener noreferrer"}},[e._v("Concurrent Programming và GCD (Part 1)"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://viblo.asia/p/concurrency-programming-guide-63vKjpYdl2R",target:"_blank",rel:"noopener noreferrer"}},[e._v("Concurrency Programming Guide"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://viblo.asia/p/parallel-processing-concurrency-va-async-programming-OeVKBdj0lkW",target:"_blank",rel:"noopener noreferrer"}},[e._v("Parallel Processing, Concurrency, và Async Programming"),r("OutboundLink")],1)])]),e._v(" "),r("p",[r("a",{attrs:{href:"https://en.wikipedia.org/wiki/Concurrency_pattern",target:"_blank",rel:"noopener noreferrer"}},[e._v("Concurrency Patterns"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=s.exports}}]);