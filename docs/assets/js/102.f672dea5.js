(window.webpackJsonp=window.webpackJsonp||[]).push([[102],{1168:function(e,t,a){"use strict";a.r(t);var n=a(7),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_5-information-hiding-and-leakage"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-information-hiding-and-leakage"}},[e._v("#")]),e._v(" 5.  Information Hiding (and Leakage)")]),e._v(" "),n("p",[e._v("Chapter 4 argued that modules should be deep. This chapter, and the next\nfew that follow, discuss techniques for creating deep modules.")]),e._v(" "),n("h2",{attrs:{id:"_5-1-information-hiding"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-1-information-hiding"}},[e._v("#")]),e._v(" 5.1    Information hiding")]),e._v(" "),n("p",[e._v("The most important technique for achieving deep modules is information")]),e._v(" "),n("p",[e._v("hiding. This technique was first described by David Parnas^1. The basic\nidea is that each module should encapsulate a few pieces of knowledge,\nwhich represent design decisions. The knowledge is embedded in the\nmodule’s implementation but does not appear in its interface, so it is not\nvisible to other modules.")]),e._v(" "),n("p",[e._v("The information hidden within a module usually consists of details\nabout how to implement some mechanism. Here are some examples of\ninformation that might be hidden within a module:\nHow to store information in a B-tree, and how to access it efficiently.\nHow to identify the physical disk block corresponding to each logical\nblock within a file.\nHow to implement the TCP network protocol.\nHow to schedule threads on a multi-core processor.\nHow to parse JSON documents.")]),e._v(" "),n("p",[e._v("The hidden information includes data structures and algorithms related to\nthe mechanism. It can also include lower-level details such as the size of a\npage, and it can include higher-level concepts that are more abstract, such\nas an assumption that most files are small.")]),e._v(" "),n("p",[e._v("Information hiding reduces complexity in two ways. First, it simplifies\nthe interface to a module. The interface reflects a simpler, more abstract\nview of the module’s functionality and hides the details; this reduces the")]),e._v(" "),n("p",[e._v("cognitive load on developers who use the module. For instance, a\ndeveloper using a B-tree class need not worry about the ideal fanout for\nnodes in the tree or how to keep the tree balanced. Second, information\nhiding makes it easier to evolve the system. If a piece of information is\nhidden, there are no dependencies on that information outside the module\ncontaining the information, so a design change related to that information\nwill affect only the one module. For example, if the TCP protocol changes\n(to introduce a new mechanism for congestion control, for instance), the\nprotocol’s implementation will have to be modified, but no changes should\nbe needed in higher-level code that uses TCP to send and receive data.")]),e._v(" "),n("p",[e._v("When designing a new module, you should think carefully about what\ninformation can be hidden in that module. If you can hide more\ninformation, you should also be able to simplify the module’s interface,\nand this makes the module deeper.")]),e._v(" "),n("p",[e._v("Note: hiding variables and methods in a class by declaring them\nprivate isn’t the same thing as information hiding. Private elements can")]),e._v(" "),n("p",[e._v("help with information hiding, since they make it impossible for the items\nto be accessed directly from outside the class. However, information about\nthe private items can still be exposed through public methods such as\ngetter and setter methods. When this happens the nature and usage of the\nvariables are just as exposed as if the variables were public.")]),e._v(" "),n("p",[e._v("The best form of information hiding is when information is totally\nhidden within a module, so that it is irrelevant and invisible to users of the\nmodule. However, partial information hiding also has value. For example,\nif a particular feature or piece of information is only needed by a few of a\nclass’s users, and it is accessed through separate methods so that it isn’t\nvisible in the most common use cases, then that information is mostly\nhidden. Such information will create fewer dependencies than information\nthat is visible to every user of the class.")]),e._v(" "),n("h2",{attrs:{id:"_5-2-information-leakage"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-2-information-leakage"}},[e._v("#")]),e._v(" 5.2    Information leakage")]),e._v(" "),n("p",[e._v("The opposite of information hiding is information leakage. Information\nleakage occurs when a design decision is reflected in multiple modules.\nThis creates a dependency between the modules: any change to that design")]),e._v(" "),n("p",[e._v("decision will require changes to all of the involved modules. If a piece of\ninformation is reflected in the interface for a module, then by definition it\nhas been leaked; thus, simpler interfaces tend to correlate with better\ninformation hiding. However, information can be leaked even if it doesn’t\nappear in a module’s interface. Suppose two classes both have knowledge\nof a particular file format (perhaps one class reads files in that format and\nthe other class writes them). Even if neither class exposes that information\nin its interface, they both depend on the file format: if the format changes,\nboth classes will need to be modified. Back-door leakage like this is more\npernicious than leakage through an interface, because it isn’t obvious.")]),e._v(" "),n("p",[e._v("Information leakage is one of the most important red flags in software\ndesign. One of the best skills you can learn as a software designer is a high\nlevel of sensitivity to information leakage. If you encounter information\nleakage between classes, ask yourself “How can I reorganize these classes\nso that this particular piece of knowledge only affects a single class?” If\nthe affected classes are relatively small and closely tied to the leaked\ninformation, it may make sense to merge them into a single class. Another\npossible approach is to pull the information out of all of the affected\nclasses and create a new class that encapsulates just that information.\nHowever, this approach will be effective only if you can find a simple\ninterface that abstracts away from the details; if the new class exposes\nmost of the knowledge through its interface, then it won’t provide much\nvalue (you’ve simply replaced back-door leakage with leakage through an\ninterface).")]),e._v(" "),n("div",{staticClass:"custom-block danger"},[n("p",{staticClass:"custom-block-title"},[e._v("Information Leakage")]),e._v(" "),n("p",[e._v("Information leakage occurs when the same knowledge is used in multiple places, such as two different classes that both understand the format of a particular type of file.")])]),e._v(" "),n("h2",{attrs:{id:"_5-3-temporal-decomposition"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-3-temporal-decomposition"}},[e._v("#")]),e._v(" 5.3    Temporal decomposition")]),e._v(" "),n("p",[e._v("One common cause of information leakage is a design style I call temporal\ndecomposition. In temporal decomposition, the structure of a system\ncorresponds to the time order in which operations will occur. Consider an\napplication that reads a file in a particular format, modifies the contents of\nthe file, and then writes the file out again. With temporal decomposition,\nthis application might be broken into three classes: one to read the file,\nanother to perform the modifications, and a third to write out the new\nversion. Both the file reading and file writing steps have knowledge about\nthe file format, which results in information leakage. The solution is to\ncombine the core mechanisms for reading and writing files into a single\nclass. This class will get used during both the reading and writing phases\nof the application. It’s easy to fall into the trap of temporal decomposition,\nbecause the order in which operations must occur is often on your mind\nwhen you code. However, most design decisions manifest themselves at\nseveral different times over the life of the application; as a result, temporal\ndecomposition often results in information leakage.")]),e._v(" "),n("p",[e._v("Order usually does matter, so it will be reflected somewhere in the\napplication. However, it shouldn’t be reflected in the module structure\nunless that structure is consistent with information hiding (perhaps the\ndifferent stages use totally different information). When designing\nmodules, focus on the knowledge that’s needed to perform each task,\nnot the order in which tasks occur.")]),e._v(" "),n("div",{staticClass:"custom-block danger"},[n("p",{staticClass:"custom-block-title"},[e._v("Temporal Decomposition")]),e._v(" "),n("p",[e._v("In temporal decomposition, execution order is reflected in the code structure: operations that happen at different times are in different methods or classes. If the same knowledge is used at different points in execution, it gets encoded in multiple places, resulting in information leakage.")])]),e._v(" "),n("h2",{attrs:{id:"_5-4-example-http-server"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-4-example-http-server"}},[e._v("#")]),e._v(" 5.4    Example: HTTP server")]),e._v(" "),n("p",[e._v("To illustrate the issues in information hiding, let’s consider the design\ndecisions made by students implementing the HTTP protocol in a software\ndesign course. It’s useful to see both the things they did well and they\nareas where they had problems.")]),e._v(" "),n("p",[e._v("HTTP is a mechanism used by Web browsers to communicate with\nWeb servers. When a user clicks on a link in a Web browser or submits a\nform, the browser uses HTTP to send a request over the network to a Web\nserver. Once the server has processed the request, it sends a response back\nto the browser; the response normally contains a new Web page to display.\nThe HTTP protocol specifies the format of requests and responses, both of\nwhich are represented textually. Figure 5.1 shows a sample HTTP request\ndescribing a form submission. The students in the course were asked to\nimplement one or more classes to make it easy for Web servers to receive\nincoming HTTP requests and send responses.")]),e._v(" "),n("p",[n("img",{attrs:{src:a(751),alt:"image--011.png"}})]),e._v(" "),n("p",[n("strong",[e._v("Figure 5.1")]),e._v(": "),n("em",[e._v("A POST request in the HTTP protocol consists of text sent over a TCP socket. Each request contains an initial line, a collection of headers terminated by an empty line, and an optional body. The initial line contains the request type (POST is used for submitting form data), a URL indicating an operation (/comments/create) and optional parameters (photo_id has the value 246), and the HTTP protocol version used by the sender. Each header line consists of a name such as Content-Length followed by its value. For this request, the body contains additional parameters (comment and priority).")])]),e._v(" "),n("h2",{attrs:{id:"_5-5-example-too-many-classes"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-5-example-too-many-classes"}},[e._v("#")]),e._v(" 5.5    Example: too many classes")]),e._v(" "),n("p",[e._v("The most common mistake made by students was to divide their code into\na large number of shallow classes, which led to information leakage\nbetween the classes. One team used two different classes for receiving\nHTTP requests; the first class read the request from the network\nconnection into a string, and the second class parsed the string. This is an\nexample of a temporal decomposition (“first we read the request, then we")]),e._v(" "),n("p",[e._v("parse it”). Information leakage occurred because an HTTP request can’t be\nread without parsing much of the message; for example, the Content-")]),e._v(" "),n("p",[e._v("Length header specifies the length of the request body, so the headers must\nbe parsed in order to compute the total request length. As a result, both\nclasses needed to understand most of the structure of HTTP requests, and\nparsing code was duplicated in both classes. This approach also created\nextra complexity for callers, who had to invoke two methods in different\nclasses, in a particular order, to receive a request.")]),e._v(" "),n("p",[e._v("Because the classes shared so much information, it would have been\nbetter to merge them into a single class that handles both request reading\nand parsing. This provides better information hiding, since it isolates all\nknowledge of the request format in one class, and it also provides a\nsimpler interface to callers (just one method to invoke).")]),e._v(" "),n("p",[e._v("This example illustrates a general theme in software design:\ninformation hiding can often be improved by making a class slightly\nlarger. One reason for doing this is to bring together all of the code\nrelated to a particular capability (such as parsing an HTTP request), so that\nthe resulting class contains everything related to that capability. A second\nreason for increasing the size of a class is to raise the level of the\ninterface; for example, rather than having separate methods for each of\nthree steps of a computation, have a single method that performs the entire\ncomputation. This can result in a simpler interface. Both of these benefits\napply in the example of the previous paragraph: combining the classes\nbrings together all of the code related to parsing an HTTP request, and it\nreplaces two externally-visible methods with one. The combined class is\ndeeper than the original classes.")]),e._v(" "),n("p",[e._v("Of course, it is possible to take the notion of larger classes too far\n(such as a single class for the entire application). Chapter 9 will discuss\nconditions under which it makes sense to separate code into multiple\nsmaller classes.")]),e._v(" "),n("h2",{attrs:{id:"_5-6-example-http-parameter-handling"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-6-example-http-parameter-handling"}},[e._v("#")]),e._v(" 5.6    Example: HTTP parameter handling")]),e._v(" "),n("p",[e._v("After an HTTP request has been received by a server, the server needs to\naccess some of the information from the request. The code that handles the")]),e._v(" "),n("p",[e._v("request in Figure 5.1 might need to know the value of the photo_id")]),e._v(" "),n("p",[e._v("parameter. Parameters can be specified in the first line of the request\n(photo_id in Figure 5.1) or, sometimes, in the body (comment and priority\nin Figure 5.1). Each parameter has a name and a value. The values of\nparameters use a special encoding called URL encoding; for example, in\nthe value for comment in Figure 5.1, “+” is used to represent a space")]),e._v(" "),n("p",[e._v("character, and “%21” is used instead of “!”. In order to process a request,\nthe server will need the values for some of the parameters, and it will want\nthem in unencoded form.")]),e._v(" "),n("p",[e._v("Most of the student projects made two good choices with respect to\nparameter handling. First, they recognized that server applications don’t\ncare whether a parameter is specified in the header line or the body of the\nrequest, so they hid this distinction from callers and merged the\nparameters from both locations together. Second, they hid knowledge of\nURL encoding: the HTTP parser decodes parameter values before\nreturning them to the Web server, so that the value of the comment\nparameter in Figure 5.1 will be returned as “What a cute baby!”, not\n“What+a+cute+baby%21”). In both of these cases, information hiding\nresulted in simpler APIs for the code using the HTTP module.")]),e._v(" "),n("p",[e._v("However, most of the students used an interface for returning\nparameters that was too shallow, and this resulted in lost opportunities for\ninformation hiding. Most projects used an object of type HTTPRequest to")]),e._v(" "),n("p",[e._v("hold the parsed HTTP request, and the HTTPRequest class had a single\nmethod like the following one to return parameters:\npublic Map<String, String> getParams() {\nreturn this.params;\n}")]),e._v(" "),n("p",[e._v("Rather than returning a single parameter, the method returns a reference to\nthe Map used internally to store all of the parameters. This method is\nshallow, and it exposes the internal representation used by the HTTPRequest")]),e._v(" "),n("p",[e._v("class to store parameters. Any change to that representation will result in a\nchange to the interface, which will require modifications to all callers.\nWhen implementations are modified, the changes often involve changes in\nthe representation of key data structures (to improve performance, for")]),e._v(" "),n("p",[e._v("example). Thus, it’s important to avoid exposing internal data structures as\nmuch as possible. This approach also makes more work for callers: a\ncaller must first invoke getParams, then it must call another method to")]),e._v(" "),n("p",[e._v("retrieve a specific parameter from the Map. Finally, callers must realize that\nthey should not modify the Map returned by getParams, since that will")]),e._v(" "),n("p",[e._v("affect the internal state of the HTTPRequest.")]),e._v(" "),n("p",[e._v("Here is a better interface for retrieving parameter values:\npublic String getParameter(String name) { ... }\npublic int getIntParameter(String name) { ... }")]),e._v(" "),n("p",[e._v("getParameter returns a parameter value as a string. It provides a slightly")]),e._v(" "),n("p",[e._v("deeper interface than getParams above; more importantly, it hides the\ninternal representation of parameters. getIntParameter converts the value")]),e._v(" "),n("p",[e._v("of a parameter from its string form in the HTTP request to an integer (e.g.,\nthe photo_id parameter in Figure 5.1). This saves the caller from having to\nrequest string-to-integer conversion separately, and hides that mechanism\nfrom the caller. Additional methods for other data types, such as\ngetDoubleParameter, could be defined if needed. (All of these methods will")]),e._v(" "),n("p",[e._v("throw exceptions if the desired parameter doesn’t exist, or if it can’t be\nconverted to the requested type; the exception declarations have been\nomitted in the code above).")]),e._v(" "),n("h2",{attrs:{id:"_5-7-example-defaults-in-http-responses"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-7-example-defaults-in-http-responses"}},[e._v("#")]),e._v(" 5.7    Example: defaults in HTTP responses")]),e._v(" "),n("p",[e._v("The HTTP projects also had to provide support for generating HTTP\nresponses. The most common mistake students made in this area was\ninadequate defaults. Each HTTP response must specify an HTTP protocol\nversion; one team required callers to specify this version explicitly when\ncreating a response object. However, the response version must correspond\nto that in the request object, and the request must already be passed as an\nargument when sending the response (it indicates where to send the\nresponse). Thus, it makes more sense for the HTTP classes to provide the\nresponse version automatically. The caller is unlikely to know what\nversion to specify, and if the caller does specify a value, it probably results\nin information leakage between the HTTP library and the caller. HTTP\nresponses also include a Date header specifying the time when the")]),e._v(" "),n("p",[e._v("response was sent; the HTTP library should provide a sensible default for\nthis as well.")]),e._v(" "),n("p",[e._v("Defaults illustrate the principle that interfaces should be designed to\nmake the common case as simple as possible. They are also an example of\npartial information hiding: in the normal case, the caller need not be aware\nof the existence of the defaulted item. In the rare cases where a caller\nneeds to override a default, it will have to know about the value, and it can\ninvoke a special method to modify it.")]),e._v(" "),n("p",[e._v("Whenever possible, classes should “do the right thing” without being\nexplicitly asked. Defaults are an example of this. The Java I/O example on\npage 26 illustrates this point in a negative way. Buffering in file I/O is so\nuniversally desirable that noone should ever have to ask explicitly for it, or\neven be aware of its existence; the I/O classes should do the right thing and\nprovide it automatically. The best features are the ones you get without\neven knowing they exist.")]),e._v(" "),n("div",{staticClass:"custom-block danger"},[n("p",{staticClass:"custom-block-title"},[e._v("Overexposure")]),e._v(" "),n("p",[e._v("If the API for a commonly used feature forces users to learn about other\nfeatures that are rarely used, this increases the cognitive load on users\nwho don’t need the rarely used features.")])]),e._v(" "),n("h2",{attrs:{id:"_5-8-information-hiding-within-a-class"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-8-information-hiding-within-a-class"}},[e._v("#")]),e._v(" 5.8    Information hiding within a class")]),e._v(" "),n("p",[e._v("The examples in this chapter focused on information hiding as it relates to\nthe externally visible APIs for classes, but information hiding can also be\napplied at other levels in the system, such as within a class. Try to design\nthe private methods within a class so that each method encapsulates some\ninformation or capability and hides it from the rest of the class. In\naddition, try to minimize the number of places where each instance\nvariable is used. Some variables may need to be accessed widely across\nthe class, but others may be needed in only a few places; if you can reduce\nthe number of places where a variable is used, you will eliminate\ndependencies within the class and reduce its complexity.")]),e._v(" "),n("h2",{attrs:{id:"_5-9-taking-it-too-far"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-9-taking-it-too-far"}},[e._v("#")]),e._v(" 5.9    Taking it too far")]),e._v(" "),n("p",[e._v("Information hiding only makes sense when the information being hidden\nis not needed outside its module. If the information is needed outside the\nmodule, then you must not hide it. Suppose that the performance of a\nmodule is affected by certain configuration parameters, and that different\nuses of the module will require different settings of the parameters. In this\ncase it is important that the parameters are exposed in the interface of the\nmodule, so that they can be turned appropriately. As a software designer,\nyour goal should be to minimize the amount of information needed outside\na module; for example, if a module can automatically adjust its\nconfiguration, that is better than exposing configuration parameters. But,\nit’s important to recognize which information is needed outside a module\nand make sure it is exposed.")]),e._v(" "),n("h2",{attrs:{id:"_5-10-conclusion"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_5-10-conclusion"}},[e._v("#")]),e._v(" 5.10     Conclusion")]),e._v(" "),n("p",[e._v("Information hiding and deep modules are closely related. If a module\nhides a lot of information, that tends to increase the amount of\nfunctionality provided by the module while also reducing its interface.\nThis makes the module deeper. Conversely, if a module doesn’t hide much\ninformation, then either it doesn’t have much functionality, or it has a\ncomplex interface; either way, the module is shallow.")]),e._v(" "),n("p",[e._v("When decomposing a system into modules, try not to be influenced by\nthe order in which operations will occur at runtime; that will lead you\ndown the path of temporal decomposition, which will result in information\nleakage and shallow modules. Instead, think about the different pieces of\nknowledge that are needed to carry out the tasks of your application, and\ndesign each module to encapsulate one or a few of those pieces of\nknowledge. This will produce a clean and simple design with deep\nmodules.")]),e._v(" "),n("p",[e._v("(^1) David Parnas, “On the Criteria to be Used in Decomposing Systems into Modules,”\nCommunications of the ACM, December 1972.")])])}),[],!1,null,null,null);t.default=s.exports},751:function(e,t,a){e.exports=a.p+"assets/img/image--011.980c080f.png"}}]);