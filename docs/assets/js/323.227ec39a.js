(window.webpackJsonp=window.webpackJsonp||[]).push([[323],{949:function(e,t,a){"use strict";a.r(t);var n=a(7),s=Object(n.a)({},(function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"_14-choosing-names"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-choosing-names"}},[e._v("#")]),e._v(" 14. Choosing Names")]),e._v(" "),a("p",[e._v("Selecting names for variables, methods, and other entities is one of the most underrated aspects of software design. Good names are a form of documentation: they make code easier to understand. They reduce the need for other documentation and make it easier to detect errors. Conversely, poor name choices increase the complexity of code and create ambiguities and misunderstandings that can result in bugs. Name choice is an example of the principle that complexity is incremental. Choosing a mediocre name for a particular variable, as opposed to the best possible name, probably won’t have much impact on the overall complexity of a system. However, software systems have thousands of variables; choosing good names for all of these will have a significant impact on complexity and manageability.")]),e._v(" "),a("h2",{attrs:{id:"_14-1-example-bad-names-cause-bugs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-1-example-bad-names-cause-bugs"}},[e._v("#")]),e._v(" 14.1  Example: bad names cause bugs")]),e._v(" "),a("p",[e._v("Sometimes even a single poorly named variable can have severe consequences. The most challenging bug I ever fixed came about because of a poor name choice. In the late 1980’s and early 1990’s my graduate\nstudents and I created a distributed operating system called Sprite. At some point we noticed that files would occasionally lose data: one of the data blocks suddenly became all zeroes, even though the file had not been modified by a user. The problem didn’t happen very often, so it was exceptionally difficult to track down. A few of the graduate students tried to find the bug, but they were unable to make progress and eventually gave up. However, I consider any unsolved bug to be an intolerable personal insult, so I decided to track it down.")]),e._v(" "),a("p",[e._v("It took six months, but I eventually found and fixed the bug. The problem was actually quite simple (as are most bugs, once you figure them out). The file system code used the variable name block for two different purposes. In some situations, block referred to a physical block number on disk; in other situations, block referred to a logical block number within a file. Unfortunately, at one point in the code there was a block variable containing a logical block number, but it was accidentally used in a context where a physical block number was needed; as a result, an unrelated block on disk got overwritten with zeroes.")]),e._v(" "),a("p",[e._v("While tracking down the bug, several people, including myself, read over the faulty code, but we never noticed the problem. When we saw the variable block used as a physical block number, we reflexively assumed that it really held a physical block number. It took a long process of\ninstrumentation, which eventually showed that the corruption must be\nhappening in a particular statement, before I was able to get past the\nmental block created by the name and check to see exactly where its value\ncame from. If different variable names had been used for the different\nkinds of blocks, such as "),a("code",[e._v("fileBlock")]),e._v(" and "),a("code",[e._v("diskBlock")]),e._v(", it’s unlikely that the\nerror would have happened; the programmer would have known that\n"),a("code",[e._v("fileBlock")]),e._v(" couldn’t be used in that situation.")]),e._v(" "),a("p",[e._v("Unfortunately, most developers don’t spend much time thinking about\nnames. They tend to use the first name that comes to mind, as long as it’s\nreasonably close to matching the thing it names. For example, block is a\npretty close match for both a physical block on disk and a logical block\nwithin a file; it’s certainly not a horrible name. Even so, it resulted in a\nhuge expenditure of time to track down a subtle bug. Thus, you shouldn’t\nsettle for names that are just “reasonably close”. Take a bit of extra time to\nchoose great names, which are precise, unambiguous, and intuitive. The\nextra attention will pay for itself quickly, and over time you’ll learn to\nchoose good names quickly.")]),e._v(" "),a("h2",{attrs:{id:"_14-2-create-an-image"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-2-create-an-image"}},[e._v("#")]),e._v(" 14.2  Create an image")]),e._v(" "),a("p",[e._v("When choosing a name, the goal is to create an image in the mind of the\nreader about the nature of the thing being named. A good name conveys a\nlot of information about what the underlying entity is, and, just as\nimportant, what it is not. When considering a particular name, ask")]),e._v(" "),a("p",[e._v("yourself: “If someone sees this name in isolation, without seeing its\ndeclaration, its documentation, or any code that uses the name, how\nclosely will they be able to guess what the name refers to? Is there some\nother name that will paint a clearer picture?” Of course, there is a limit to\nhow much information you can put in a single name; names become\nunwieldy if they contain more than two or three words. Thus, the challenge\nis to find just a few words that capture the most important aspects of the\nentity.")]),e._v(" "),a("p",[e._v("Names are a form of abstraction: they provide a simplified way of\nthinking about a more complex underlying entity. Like other forms of\nabstraction, the best names are those that focus attention on what is most\nimportant about the underlying entity while omitting details that are less\nimportant.")]),e._v(" "),a("h2",{attrs:{id:"_14-3-names-should-be-precise"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-3-names-should-be-precise"}},[e._v("#")]),e._v(" 14.3  Names should be precise")]),e._v(" "),a("p",[e._v("Good names have two properties: precision and consistency. Let’s start with precision. The most common problem with names is that they are too generic or vague; as a result, it’s hard for readers to tell what the name refers to; the reader may assume that the name refers to something different from reality, as in the block bug above. Consider the following method declaration:")]),e._v(" "),a("div",{staticClass:"language-cpp extra-class"},[a("pre",{pre:!0,attrs:{class:"language-cpp"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("/**\n* Returns the total number of indexlets this object is managing.\n*/")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("int")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("IndexletManager")]),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("::")]),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("getCount")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("The term “count” is too generic: count of what? If someone sees an invocation of this method, they are unlikely to know what it does unless they read its documentation. A more precise name like getActiveIndexlets or numIndexlets would be better: with one of these names, readers will probably be able to guess what the method returns without having to look at its documentation.")]),e._v(" "),a("p",[e._v("Here are some other examples of names that aren’t precise enough, taken from various student projects:")]),e._v(" "),a("p",[e._v("A project building a GUI text editor used the names x and y to refer to\nthe position of a character in the file. These names are too generic.\nThey could mean many things; for example, they might also represent\nthe coordinates (in pixels) of a character on the screen. Someone\nseeing the name x in isolation is unlikely to think that it refers to the\nposition of a character within a line of text. The code would be\nclearer if it used names such as charIndex and lineIndex, which\nreflect the specific abstractions that the code implements.\nAnother editor project contained the following code:")]),e._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Blink state: true when cursor visible.")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("private")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("boolean")]),e._v(" blinkStatus "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("p",[e._v("The name "),a("code",[e._v("blinkStatus")]),e._v(" doesn’t convey enough information. The word “status” is too vague for a boolean value: it gives no clue about what a "),a("code",[e._v("true")]),e._v(" or "),a("code",[e._v("false")]),e._v(" value means. The word “blink” is also vague, since it doesn’t indicate what is blinking. The following alternative is better:")]),e._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Controls cursor blinking: true means the cursor is visible,")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// false means the cursor is not displayed.")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("private")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("boolean")]),e._v(" cursorVisible "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("true")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("p",[e._v("The name cursorVisible conveys more information; for example, it allows readers to guess what a true value means (as a general rule, names of boolean variables should always be predicates). The word\n“blink” is no longer in the name, so readers will have to consult the documentation if they want to know why the cursor isn’t always visible; this information is less important.")]),e._v(" "),a("p",[e._v("A project implementing a consensus protocol contained the following code:")]),e._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// Value representing that the server has not voted (yet) for")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[e._v("// anyone for the current election term.")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("private")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("static")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("final")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("String")]),e._v(" VOTED_FOR_SENTINEL_VALUE "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[e._v('"null"')]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),a("p",[e._v("The name for this value indicates that it’s special but it doesn’t say what the special meaning is. A more specific name such as "),a("code",[e._v("NOT_YET_VOTED")]),e._v(" would be better.")]),e._v(" "),a("p",[e._v("A variable named result was used in a method with no return value.\nThis name has multiple problems. First, it creates the misleading impression that it will be the return value of the method. Second, it provides essentially no information about what it actually holds,\nexcept that it is some computed value. The name should provide information about what the result actually is, such as mergedLine or totalChars. In methods that do actually have return values, then using\nthe name result is reasonable. This name is still a bit generic, but readers can look at the method documentation to see its meaning, and it’s helpful to know that the value will eventually become the return value.")]),e._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[e._v("Vague Name")]),e._v(" "),a("p",[e._v("If a variable or method name is broad enough to refer to many different\nthings, then it doesn’t convey much information to the developer and the\nunderlying entity is more likely to be misused.")])]),e._v(" "),a("p",[e._v("Like all rules, the rule about choosing precise names has a few\nexceptions. For example, it’s fine to use generic names like i and j as loop\niteration variables, as long as the loops only span a few lines of code. If\nyou can see the entire range of usage of a variable, then the meaning of the\nvariable will probably be obvious from the code so you don’t need a long\nname. For example, consider the following code:")]),e._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("for")]),e._v("  "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("i "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v(" numLines"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v(" i"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("++")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),e._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("It’s clear from this code that i is being used to iterate over each of the\nlines in some entity. If the loop gets so long that you can’t see it all at\nonce, or if the meaning of the iteration variable is harder to figure out\nfrom the code, then a more descriptive name is in order.")]),e._v(" "),a("p",[e._v("It’s also possible for a name to be too specific, such as in this\ndeclaration for a method that deletes a range of text:")]),e._v(" "),a("div",{staticClass:"language-java extra-class"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("void")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("delete")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Range")]),e._v(" selection"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("The argument name selection is too specific, since it suggests that the text being deleted is always selected in the user interface. However, this method can be invoked on any range of text, selected or not. Thus, the argument name should be more generic, such as range.")]),e._v(" "),a("p",[e._v("If you find it difficult to come up with a name for a particular variable that is precise, intuitive, and not too long, this is a red flag. It suggests that the variable may not have a clear definition or purpose. When this happens, consider alternative factorings. For example, perhaps you are trying to use a single variable to represent several things; if so, separating the representation into multiple variables may result in a simpler definition for each variable. The process of choosing good names can\nimprove your design by identifying weaknesses.")]),e._v(" "),a("div",{staticClass:"custom-block danger"},[a("p",{staticClass:"custom-block-title"},[e._v("Hard to Pick Name")]),e._v(" "),a("p",[e._v("If it’s hard to find a simple name for a variable or method that creates a\nclear image of the underlying object, that’s a hint that the underlying\nobject may not have a clean design.")])]),e._v(" "),a("h2",{attrs:{id:"_14-4-use-names-consistently"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-4-use-names-consistently"}},[e._v("#")]),e._v(" 14.4 Use names consistently")]),e._v(" "),a("p",[e._v("The second important property of good names is consistency. In any\nprogram there are certain variables that are used over and over again. For\nexample, a file system manipulates block numbers repeatedly. For each of\nthese common usages, pick a name to use for that purpose, and use the\nsame name everywhere. For example, a file system might always use\nfileBlock to hold the index of a block within a file. Consistent naming")]),e._v(" "),a("p",[e._v("reduces cognitive load in much the same way as reusing a common class:\nonce the reader has seen the name in one context, they can reuse their\nknowledge and instantly make assumptions when they see the name in a\ndifferent context.")]),e._v(" "),a("p",[e._v("Consistency has three requirements: first, always use the common\nname for the given purpose; second, never use the common name for\nanything other than the given purpose; third, make sure that the purpose is\nnarrow enough that all variables with the name have the same behavior.\nThis third requirement was violated in the file system bug at the beginning of the chapter. The file system used block for variables with two different behaviors (file blocks and disk blocks); this led to a false assumption about the meaning of a variable, which in turn resulted in a bug.")]),e._v(" "),a("p",[e._v("Sometimes you will need multiple variables that refer to the same general sort of thing. For example, a method that copies file data will need two block numbers, one for the source and one for the destination. When this happens, use the common name for each variable but add a distinguishing prefix, such as "),a("code",[e._v("srcFileBlock")]),e._v(" and "),a("code",[e._v("dstFileBlock")]),e._v(".")]),e._v(" "),a("p",[e._v("Loops are another area where consistent naming can help. If you use names such as i and j for loop variables, always use "),a("code",[e._v("i")]),e._v(" in outermost loops and "),a("code",[e._v("j")]),e._v(" for nested loops. This allows readers to make instant (safe) assumptions about what’s happening in the code when they see a given name.")]),e._v(" "),a("h2",{attrs:{id:"_14-5-a-dierent-opinion-go-style-guide"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-5-a-dierent-opinion-go-style-guide"}},[e._v("#")]),e._v(" 14.5  A dierent opinion: Go style guide")]),e._v(" "),a("p",[e._v("Not everyone shares my views about naming. Some of the developers of the Go language argue that names should be very short, often only a single character. In a presentation on name choice for Go, Andrew Gerrand states that “long names obscure what the code does.”^1 He presents this code\nsample, which uses single-letter variable names:")]),e._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("func")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("RuneCount")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("b "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("int")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" n "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("for")]),e._v(" i "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("len")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v(" RuneSelf "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n            i"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("++")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("else")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n            "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("_")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" size "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("DecodeRune")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("b"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("i"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n            i "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+=")]),e._v(" size\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n        n"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("++")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" n\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("and argues that it is more readable than the following version, which uses longer names:")]),e._v(" "),a("div",{staticClass:"language-go extra-class"},[a("pre",{pre:!0,attrs:{class:"language-go"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("func")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("RuneCount")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("buffer "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("byte")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token builtin"}},[e._v("int")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" count "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("\n\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("for")]),e._v(" index "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("len")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("buffer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("if")]),e._v(" buffer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("<")]),e._v(" RuneSelf "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n            index"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("++")]),e._v("\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("else")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n            "),a("span",{pre:!0,attrs:{class:"token boolean"}},[e._v("_")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" size "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":=")]),e._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[e._v("DecodeRune")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("buffer"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("index"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n            index "),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("+=")]),e._v(" size\n        "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n        count"),a("span",{pre:!0,attrs:{class:"token operator"}},[e._v("++")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n    "),a("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("return")]),e._v(" count\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),a("p",[e._v("Personally, I don’t find the second version any more difficult to read than the first. If anything, the name count gives a slightly better clue to the behavior of the variable than n. With the first version I ended up reading through the code trying to figure out what n means, whereas I didn’t feel\nthat need with the second version. But, if n is used consistently throughout the system to refer to counts (and nothing else), then the short name will probably be clear to other developers.")]),e._v(" "),a("p",[e._v("The Go culture encourages the use of the same short name for multiple different things: ch for character or channel, d for data, difference, or distance, and so on. To me, ambiguous names like these are likely to result in confusion and error, just as in the block example.")]),e._v(" "),a("p",[e._v("Overall, I would argue that readability must be determined by readers, not writers. If you write code with short variable names and the people who read it find it easy to understand, then that’s fine. If you start getting complaints that your code is cryptic, then you should consider using longer names (a Web search for “go language short names” will identify several such complaints). Similarly, if I start getting complaints that long variable names make my code harder to read, then I’ll consider using shorter ones.")]),e._v(" "),a("p",[e._v("Gerrand makes one comment that I agree with: “The greater the distance between a name’s declaration and its uses, the longer the name should be.” The earlier discussion about using loop variables named "),a("code",[e._v("i")]),e._v(" and "),a("code",[e._v("j")]),e._v(" is an example of this rule.")]),e._v(" "),a("h2",{attrs:{id:"_14-6-conclusion"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-6-conclusion"}},[e._v("#")]),e._v(" 14.6  Conclusion")]),e._v(" "),a("p",[e._v("Well chosen names help to make code more obvious; when someone encounters the variable for the first time, their first guess about its behavior, made without much thought, will be correct. Choosing good\nnames is an example of the investment mindset discussed in Chapter 3: if you take a little extra time up front to select good names, it will be easier for you to work on the code in the future. In addition, you will be less likely to introduce bugs. Developing a skill for naming is also an investment. When you first decide to stop settling for mediocre names, you may find it frustrating and time-consuming to come up with good names. However, as you get more experience you’ll find that it becomes easier; eventually, you’ll get to the point where it takes almost no extra time to choose good names, so you will get the benefits almost for free.")]),e._v(" "),a("p",[e._v("(^1) "),a("a",{attrs:{href:"https://talks.golang.org/2014/names.slide#1",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://talks.golang.org/2014/names.slide#1"),a("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=s.exports}}]);