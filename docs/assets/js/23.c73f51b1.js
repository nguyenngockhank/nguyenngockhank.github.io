(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{406:function(e,t,a){e.exports=a.p+"assets/img/image--033.e1a6c8eb.jpg"},570:function(e,t,a){e.exports=a.p+"assets/img/image--034.4cb90d7b.jpg"},571:function(e,t,a){e.exports=a.p+"assets/img/image--035.ddccddb8.jpg"},859:function(e,t,a){"use strict";a.r(t);var s=a(7),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"chapter-8-key-value-databases"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#chapter-8-key-value-databases"}},[e._v("#")]),e._v(" Chapter 8. Key-Value Databases")]),e._v(" "),s("p",[e._v("A key-value store is a simple hash table, primarily used when all access to the database is via\nprimary key. Think of a table in a traditional RDBMS with two columns, such as ID and NAME, the ID\ncolumn being the key and NAME column storing the value. In an RDBMS, the NAME column is restricted\nto storing data of type String. The application can provide an ID and VALUE and persist the pair; if\nthe ID already exists the current value is overwritten, otherwise a new entry is created. Let’s look at\nhow terminology compares in Oracle and Riak.")]),e._v(" "),s("p",[s("img",{attrs:{src:a(406),alt:"img"}})]),e._v(" "),s("h2",{attrs:{id:"_8-1-what-is-a-key-value-store"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-1-what-is-a-key-value-store"}},[e._v("#")]),e._v(" 8.1. What Is a Key-Value Store")]),e._v(" "),s("p",[e._v("Key-value stores are the simplest NoSQL data stores to use from an API perspective. The client can\neither get the value for the key, put a value for a key, or delete a key from the data store. The value is\na blob that the data store just stores, without caring or knowing what’s inside; it’s the responsibility\nof the application to understand what was stored. Since key-value stores always use primary-key\naccess, they generally have great performance and can be easily scaled.")]),e._v(" "),s("p",[e._v("Some of the popular key-value databases are "),s("a",{attrs:{href:"https://riak.com/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Riak"),s("OutboundLink")],1),e._v(", Redis (often referred to as Data\nStructure server) "),s("a",{attrs:{href:"https://redis.io/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Redis"),s("OutboundLink")],1),e._v(", Memcached DB and its flavors "),s("a",{attrs:{href:"https://memcached.org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Memcached"),s("OutboundLink")],1),e._v(", Berkeley DB "),s("a",{attrs:{href:"https://www.oracle.com/database/technologies/related/berkeleydb-downloads.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Berkeley DB"),s("OutboundLink")],1),e._v(", HamsterDB (especially suited for embedded use) "),s("a",{attrs:{href:"https://github.com/GerHobbelt/hamsterdb",target:"_blank",rel:"noopener noreferrer"}},[e._v("HamsterDB"),s("OutboundLink")],1),e._v(", "),s("a",{attrs:{href:"https://aws.amazon.com/dynamodb/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Amazon Dynamo"),s("OutboundLink")],1),e._v(" (not open-source), and  "),s("a",{attrs:{href:"https://www.project-voldemort.com/voldemort/",target:"_blank",rel:"noopener noreferrer"}},[e._v("Project Voldemort"),s("OutboundLink")],1),e._v(" (an open-source\nimplementation of Amazon DynamoDB).")]),e._v(" "),s("p",[e._v("In some key-value stores, such as Redis, the aggregate being stored does not have to be a domain\nobject—it could be any data structure. Redis supports storing lists, sets, hashes and can do range,\ndiff, union, and intersection operations. These features allow Redis to be used in more different ways\nthan a standard key-value store.")]),e._v(" "),s("p",[e._v("There are many more key-value databases and many new ones are being worked on at this time.\nFor the sake of keeping discussions in this book easier we will focus mostly on Riak. Riak lets us\nstore keys into buckets, which are just a way to segment the keys—think of buckets as flat namespaces\nfor the keys.")]),e._v(" "),s("p",[e._v("If we wanted to store user session data, shopping cart information, and user preferences in Riak,\nwe could just store all of them in the same bucket with a single key and single value for all of these\nobjects. In this scenario, we would have a single object that stores all the data and is put into a single bucket (Figure 8.1).")]),e._v(" "),s("p",[s("img",{attrs:{src:a(570),alt:"img"}})]),e._v(" "),s("p",[s("strong",[e._v("Figure 8.1. Storing all the data in a single bucket")])]),e._v(" "),s("p",[e._v("The downside of storing all the different objects (aggregates) in the single bucket would be that one\nbucket would store different types of aggregates, increasing the chance of key conflicts. An alternate\napproach would be to append the name of the object to the key, such as\n288790b8a421_userProfile, so that we can get to individual objects as they are needed (Figure\n8.2).")]),e._v(" "),s("p",[s("img",{attrs:{src:a(571),alt:"img"}})]),e._v(" "),s("p",[s("strong",[e._v("Figure 8.2. Change the key design to segment the data in a single bucket.")])]),e._v(" "),s("p",[e._v("We could also create buckets which store specific data. In Riak, they are known as "),s("strong",[e._v("domain buckets")]),e._v(" allowing the serialization and deserialization to be handled by the client driver.")]),e._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Bucket")]),e._v(" bucket "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" client"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("fetchBucket")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("bucketName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("execute")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("DomainBucket")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("<")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("UserProfile")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(">")])]),e._v(" profileBucket "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("DomainBucket")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("builder")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("bucket"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("UserProfile")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("class")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("build")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),s("p",[e._v("Using domain buckets or different buckets for different objects (such as UserProfile and\nShoppingCart) segments the data across different buckets allowing you to read only the object you\nneed without having to change key design.")]),e._v(" "),s("p",[e._v("Key-value stores such as Redis also support storing random data structures, which can be sets,\nhashes, strings, and so on. This feature can be used to store lists of things, like states or")]),e._v(" "),s("p",[e._v("addressTypes, or an array of user’s visits.")]),e._v(" "),s("h2",{attrs:{id:"_8-2-key-value-store-features"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-key-value-store-features"}},[e._v("#")]),e._v(" 8.2. Key-Value Store Features")]),e._v(" "),s("p",[e._v("While using any NoSQL data stores, there is an inevitable need to understand how the features\ncompare to the standard RDBMS data stores that we are so used to. The primary reason is to\nunderstand what features are missing and how does the application architecture need to change to\nbetter use the features of a key-value data store. Some of the features we will discuss for all the\nNoSQL data stores are consistency, transactions, query features, structure of the data, and scaling.")]),e._v(" "),s("h3",{attrs:{id:"_8-2-1-consistency"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-1-consistency"}},[e._v("#")]),e._v(" "),s("strong",[e._v("8.2.1. Consistency")])]),e._v(" "),s("p",[e._v("Consistency is applicable only for operations on a single key, since these operations are either a get,\nput, or delete on a single key. Optimistic writes can be performed, but are very expensive to\nimplement, because a change in value cannot be determined by the data store.")]),e._v(" "),s("p",[e._v("In distributed key-value store implementations like Riak, the "),s("em",[e._v("eventually consistent")]),e._v(" (p. 50 ) model\nof consistency is implemented. Since the value may have already been replicated to other nodes, Riak\nhas two ways of resolving update conflicts: either the newest write wins and older writes loose, or\nboth (all) values are returned allowing the client to resolve the conflict.")]),e._v(" "),s("p",[e._v("In Riak, these options can be set up during the bucket creation. Buckets are just a way to namespace\nkeys so that key collisions can be reduced—for example, all customer keys may reside in the\ncustomer bucket. When creating a bucket, default values for consistency can be provided, for\nexample that a write is considered good only when the data is consistent across all the nodes where\nthe data is stored.")]),e._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Bucket")]),e._v(" bucket "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" connection\n                    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("createBucket")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("bucketName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n                    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("withRetrier")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("attempts")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n                    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("allowSiblings")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("siblingsAllowed"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n                    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("nVal")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("numberOfReplicasOfTheData"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n                    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("w")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("numberOfNodesToRespondToWrite"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n                    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("r")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("numberOfNodesToRespondToRead"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),e._v("\n                    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("execute")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),s("p",[e._v("If we need data in every node to be consistent, we can increase the "),s("em",[e._v("numberOfNodesToRespondToWrite")]),e._v(" set by w to be the same as nVal. Of course doing that will decrease the write performance of the cluster. To improve on write or read conflicts, we can change the allowSiblings flag during bucket creation: If it is set to false, we let the last write to win and not create siblings.")]),e._v(" "),s("h3",{attrs:{id:"_8-2-2-transactions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-2-transactions"}},[e._v("#")]),e._v(" "),s("strong",[e._v("8.2.2. Transactions")])]),e._v(" "),s("p",[e._v("Different products of the key-value store kind have different specifications of transactions. Generally\nspeaking, there are no guarantees on the writes. Many data stores do implement transactions in\ndifferent ways. Riak uses the concept of quorum (“Quorums,” p. 57 ) implemented by using the W value\n—replication factor—during the write API call.")]),e._v(" "),s("p",[e._v("Assume we have a Riak cluster with a replication factor of 5 and we supply the W value of 3. When\nwriting, the write is reported as successful only when it is written and reported as a success on at\nleast three of the nodes. This allows Riak to have write tolerance; in our example, with N equal to 5")]),e._v(" "),s("p",[e._v("and with a W value of 3 , the cluster can tolerate N - W = 2 nodes being down for write operations,\nthough we would still have lost some data on those nodes for read.")]),e._v(" "),s("h3",{attrs:{id:"_8-2-3-query-features"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-3-query-features"}},[e._v("#")]),e._v(" "),s("strong",[e._v("8.2.3. Query Features")])]),e._v(" "),s("p",[e._v("All key-value stores can query by the key—and that’s about it. If you have requirements to query by\nusing some attribute of the value column, it’s not possible to use the database: Your application needs\nto read the value to figure out if the attribute meets the conditions.")]),e._v(" "),s("p",[e._v("Query by key also has an interesting side effect. What if we don’t know the key, especially during\nad-hoc querying during debugging? Most of the data stores will not give you a list of all the primary\nkeys; even if they did, retrieving lists of keys and then querying for the value would be very\ncumbersome. Some key-value databases get around this by providing the ability to search inside the\nvalue, such as "),s("strong",[e._v("Riak Search")]),e._v(" that allows you to query the data just like you would query it using\nLucene indexes.")]),e._v(" "),s("p",[e._v("While using key-value stores, lots of thought has to be given to the design of the key. Can the key be\ngenerated using some algorithm? Can the key be provided by the user (user ID, email, etc.)? Or\nderived from timestamps or other data that can be derived outside of the database?")]),e._v(" "),s("p",[e._v("These query characteristics make key-value stores likely candidates for storing session data (with\nthe session ID as the key), shopping cart data, user profiles, and so on. The expiry_secs property\ncan be used to expire keys after a certain time interval, especially for session/shopping cart objects.")]),e._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Bucket")]),e._v(" bucket "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("getBucket")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("bucketName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("IRiakObject")]),e._v(" riakObject "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" bucket"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("store")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v(" value"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("execute")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),s("p",[e._v("When writing to the Riak bucket using the store API, the object is stored for the key provided.\nSimilarly, we can get the value stored for the key using the fetch API.")]),e._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("Bucket")]),e._v(" bucket "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("getBucket")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("bucketName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("IRiakObject")]),e._v(" riakObject "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" bucket"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("fetch")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("key"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("execute")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("byte")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v(" bytes "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" riakObject"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("getValue")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("String")]),e._v(" value "),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[e._v("new")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[e._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("(")]),e._v("bytes"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n")])])]),s("p",[e._v("Riak provides an HTTP-based interface, so that all operations can be performed from the web\nbrowser or on the command line using curl. Let’s save this data to Riak:")]),e._v(" "),s("div",{staticClass:"language-json extra-class"},[s("pre",{pre:!0,attrs:{class:"language-json"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"lastVisit"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("1324669989288")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"user"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"customerId"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"91cfdf5bcb7c"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"name"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"buyer"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"countryCode"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token string"}},[e._v('"US"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(",")]),e._v("\n        "),s("span",{pre:!0,attrs:{class:"token property"}},[e._v('"tzOffset"')]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v(":")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),s("p",[e._v("Use the curl command to POST the data, storing the data in the session bucket with the key of\n"),s("code",[e._v("a7e618d9db25")]),e._v(" (we have to provide this key):")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('curl -v -X POST -d \'\n{ "lastVisit":1324669989288,\n"user":{"customerId":"91cfdf5bcb7c",\n"name":"buyer",\n"countryCode":"US",\n"tzOffset":0}\n}\'\n-H "Content-Type: application/json" http://localhost:8098/buckets/session/keys/a7e618d9db25\n')])])]),s("p",[e._v("The data for the key a7e618d9db25 can be fetched by using the curl command:")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("curl -i http://localhost:8098/buckets/session/keys/a7e618d9db25\n")])])]),s("h3",{attrs:{id:"_8-2-4-structure-of-data"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-4-structure-of-data"}},[e._v("#")]),e._v(" "),s("strong",[e._v("8.2.4. Structure of Data")])]),e._v(" "),s("p",[e._v("Key-value databases don’t care what is stored in the value part of the key-value pair. The value can\nbe a blob, text, JSON, XML, and so on. In Riak, we can use the Content-Type in the POST request to\nspecify the data type.")]),e._v(" "),s("h3",{attrs:{id:"_8-2-5-scaling"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-2-5-scaling"}},[e._v("#")]),e._v(" "),s("strong",[e._v("8.2.5. Scaling")])]),e._v(" "),s("p",[e._v("Many key-value stores scale by using sharding (“Sharding,” p. 38 ). With sharding, the value of the\nkey determines on which node the key is stored. Let’s assume we are sharding by the first character of\nthe key; if the key is f4b19d79587d, which starts with an f, it will be sent to different node than the\nkey ad9c7a396542. This kind of sharding setup can increase performance as more nodes are added to\nthe cluster.")]),e._v(" "),s("p",[e._v("Sharding also introduces some problems. If the node used to store f goes down, the data stored on\nthat node becomes unavailable, nor can new data be written with keys that start with f.")]),e._v(" "),s("p",[e._v("Data stores such as Riak allow you to control the aspects of the CAP Theorem (“The CAP\nTheorem,” p. 53 ): N (number of nodes to store the key-value replicas), R (number of nodes that have\nto have the data being fetched before the read is considered successful), and W (the number of nodes\nthe write has to be written to before it is considered successful).")]),e._v(" "),s("p",[e._v("Let’s assume we have a 5-node Riak cluster. Setting N to 3 means that all data is replicated to at\nleast three nodes, setting R to 2 means any two nodes must reply to a GET request for it to be\nconsidered successful, and setting W to 2 ensures that the PUT request is written to two nodes before\nthe write is considered successful.")]),e._v(" "),s("p",[e._v("These settings allow us to fine-tune node failures for read or write operations. Based on our need,\nwe can change these values for better read availability or write availability. Generally speaking\nchoose a W value to match your consistency needs; these values can be set as defaults during bucket\ncreation.")]),e._v(" "),s("h2",{attrs:{id:"_8-3-suitable-use-cases"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-suitable-use-cases"}},[e._v("#")]),e._v(" 8.3. Suitable Use Cases")]),e._v(" "),s("p",[e._v("Let’s discuss some of the problems where key-value stores are a good fit.")]),e._v(" "),s("h3",{attrs:{id:"_8-3-1-storing-session-information"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-1-storing-session-information"}},[e._v("#")]),e._v(" "),s("strong",[e._v("8.3.1. Storing Session Information")])]),e._v(" "),s("p",[e._v("Generally, every web session is unique and is assigned a unique sessionid value. Applications that\nstore the sessionid on disk or in an RDBMS will greatly benefit from moving to a key-value store,\nsince everything about the session can be stored by a single PUT request or retrieved using GET. This")]),e._v(" "),s("p",[e._v("single-request operation makes it very fast, as everything about the session is stored in a single\nobject. Solutions such as Memcached are used by many web applications, and Riak can be used when\navailability is important.")]),e._v(" "),s("h3",{attrs:{id:"_8-3-2-user-profiles-preferences"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-2-user-profiles-preferences"}},[e._v("#")]),e._v(" "),s("strong",[e._v("8.3.2. User Profiles, Preferences")])]),e._v(" "),s("p",[e._v("Almost every user has a unique userId, username, or some other attribute, as well as preferences\nsuch as language, color, timezone, which products the user has access to, and so on. This can all be\nput into an object, so getting preferences of a user takes a single GET operation. Similarly, product\nprofiles can be stored.")]),e._v(" "),s("h3",{attrs:{id:"_8-3-3-shopping-cart-data"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-3-3-shopping-cart-data"}},[e._v("#")]),e._v(" "),s("strong",[e._v("8.3.3. Shopping Cart Data")])]),e._v(" "),s("p",[e._v("E-commerce websites have shopping carts tied to the user. As we want the shopping carts to be\navailable all the time, across browsers, machines, and sessions, all the shopping information can be\nput into the value where the key is the userid. A Riak cluster would be best suited for these kinds of\napplications.")]),e._v(" "),s("h2",{attrs:{id:"_8-4-when-not-to-use"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-when-not-to-use"}},[e._v("#")]),e._v(" 8.4. When Not to Use")]),e._v(" "),s("p",[e._v("There are problem spaces where key-value stores are not the best solution.")]),e._v(" "),s("h3",{attrs:{id:"_8-4-1-relationships-among-data"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-1-relationships-among-data"}},[e._v("#")]),e._v(" "),s("strong",[e._v("8.4.1. Relationships among Data")])]),e._v(" "),s("p",[e._v("If you need to have relationships between different sets of data, or correlate the data between\ndifferent sets of keys, key-value stores are not the best solution to use, even though some key-value\nstores provide link-walking features.")]),e._v(" "),s("h3",{attrs:{id:"_8-4-2-multioperation-transactions"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-2-multioperation-transactions"}},[e._v("#")]),e._v(" "),s("strong",[e._v("8.4.2. Multioperation Transactions")])]),e._v(" "),s("p",[e._v("If you’re saving multiple keys and there is a failure to save any one of them, and you want to revert or\nroll back the rest of the operations, key-value stores are not the best solution to be used.")]),e._v(" "),s("h3",{attrs:{id:"_8-4-3-query-by-data"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-3-query-by-data"}},[e._v("#")]),e._v(" "),s("strong",[e._v("8.4.3. Query by Data")])]),e._v(" "),s("p",[e._v("If you need to search the keys based on something found in the value part of the key-value pairs, then\nkey-value stores are not going to perform well for you. There is no way to inspect the value on the\ndatabase side, with the exception of some products like Riak Search or indexing engines like Lucene\n[Lucene] or Solr [Solr].")]),e._v(" "),s("h3",{attrs:{id:"_8-4-4-operations-by-sets"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_8-4-4-operations-by-sets"}},[e._v("#")]),e._v(" "),s("strong",[e._v("8.4.4. Operations by Sets")])]),e._v(" "),s("p",[e._v("Since operations are limited to one key at a time, there is no way to operate upon multiple keys at the\nsame time. If you need to operate upon multiple keys, you have to handle this from the client side.")])])}),[],!1,null,null,null);t.default=n.exports}}]);