(window.webpackJsonp=window.webpackJsonp||[]).push([[394],{1348:function(e,t,n){"use strict";n.r(t);var i=n(7),a=Object(i.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_11-design-it-twice"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_11-design-it-twice"}},[e._v("#")]),e._v(" 11.  Design it Twice")]),e._v(" "),n("p",[e._v("Designing software is hard, so it’s unlikely that your first thoughts about\nhow to structure a module or system will produce the best design. You’ll\nend up with a much better result if you consider multiple options for each\nmajor design decision: design it twice.")]),e._v(" "),n("p",[e._v("Suppose you are designing the class that will manage the text of a file\nfor a GUI text editor. The first step is to define the interface that the class\nwill present to the rest of the editor; rather than picking the first idea that\ncomes to mind, consider several possibilities. One choice is a line-oriented\ninterface, with operations to insert, modify, and delete whole lines of text.\nAnother option is an interface based on individual character insertions and\ndeletions. A third choice is a string-oriented interface, which operates on\narbitrary ranges of characters that may cross line boundaries. You don’t\nneed to pin down every feature of each alternative; it’s sufficient at this\npoint to sketch out a few of the most important methods.")]),e._v(" "),n("p",[e._v("Try to pick approaches that are radically different from each other;\nyou’ll learn more that way. Even if you are certain that there is only one\nreasonable approach, consider a second design anyway, no matter how bad\nyou think it will be. It will be instructive to think about the weaknesses of\nthat design and contrast them with the features of other designs.")]),e._v(" "),n("p",[e._v("After you have roughed out the designs for the alternatives, make a list\nof the pros and cons of each one. The most important consideration for an\ninterface is ease of use for higher level software. In the example above,\nboth the line-oriented interface and the character-oriented interface will\nrequire extra work in software that uses the text class. The line-oriented\ninterface will require higher level software to split and join lines during\npartial-line and multi-line operations such as cutting and pasting the\nselection. The character-oriented interface will require loops to implement\noperations that modify more than a single character. It is also worth\nconsidering other factors:\nDoes one alternative have a simpler interface than another? In the text\nexample, all of the text interfaces are relatively simple.\nIs one interface more general-purpose than another?\nDoes one interface enable a more efficient implementation than\nanother? In the text example, the character-oriented approach is\nlikely to be significantly slower than the others, because it requires a\nseparate call into the text module for each character.\nOnce you have compared alternative designs, you will be in a better\nposition to identify the best design. The best choice may be one of the\nalternatives, or you may discover that you can combine features of\nmultiple alternatives into a new design that is better than any of the\noriginal choices.")]),e._v(" "),n("p",[e._v("Sometimes none of the alternatives is particularly attractive; when this\nhappens, see if you can come up with additional schemes. Use the\nproblems you identified with the original alternatives to drive the new\ndesign(s). If you were designing the text class and considered only the\nline-oriented and character-oriented approaches, you might notice that\neach of the alternatives is awkward because it requires higher level\nsoftware to perform additional text manipulations. That’s a red flag: if\nthere’s going to be a text class, it should handle all of the text\nmanipulation. In order to eliminate the additional text manipulations, the\ntext interface needs to match more closely the operations happening in\nhigher level software. These operations don’t always correspond to single\ncharacters or single lines. This line of reasoning should lead you to a\nrange-oriented API for text, which eliminates the problem with the earlier\ndesigns.")]),e._v(" "),n("p",[e._v("The design-it-twice principle can be applied at many levels in a\nsystem. For a module, you can use this approach first to pick the interface,\nas described above. Then you can apply it again when you are designing\nthe implementation: for the text class, you might consider\nimplementations such as a linked list of lines, fixed-size blocks of\ncharacters, or a “gap buffer.” The goals will be different for the implementation than for the interface: for the implementation, the most important things are simplicity and performance. It’s also useful to\nexplore multiple designs at higher levels in the system, such as when\nchoosing features for a user interface, or when decomposing a system into\nmajor modules. In each case, it’s easier to identify the best approach if you\ncan compare a few alternatives.")]),e._v(" "),n("p",[e._v("Designing it twice does not need to take a lot of extra time. For a\nsmaller module such as a class, you may not need more than an hour or\ntwo to consider alternatives. This is a small amount of time compared to\nthe days or weeks you will spend implementing the class. The initial\ndesign experiments will probably result in a significantly better design,\nwhich will more than pay for the time spent designing it twice. For larger\nmodules you’ll spend more time in the initial design explorations, but the\nimplementation will also take longer, and the benefits of a better design\nwill also be higher.")]),e._v(" "),n("p",[e._v("I have noticed that the design-it-twice principle is sometimes hard for\nreally smart people to embrace. When they are growing up, smart people\ndiscover that their first quick idea about any problem is sufficient for a\ngood grade; there is no need to consider a second or third possibility. This\nmakes it easy to develop bad work habits. However, as these people get\nolder, they get promoted into environments with harder and harder\nproblems. Eventually, everyone reaches a point where your first ideas are\nno longer good enough; if you want to get really great results, you have to\nconsider a second possibility, or perhaps a third, no matter how smart you\nare. The design of large software systems falls in this category: no-one is\ngood enough to get it right with their first try.")]),e._v(" "),n("p",[e._v("Unfortunately, I often see smart people who insist on implementing the\nfirst idea that comes to mind, and this causes them to underperform their\ntrue potential (it also makes them frustrating to work with). Perhaps they\nsubconsciously believe that “smart people get it right the first time,” so if\nthey try multiple designs it would mean they are not smart after all. This is\nnot the case. It isn’t that you aren’t smart; it’s that the problems are really\nhard! Furthermore, that’s a good thing: it’s much more fun to work on a\ndifficult problem where you have to think carefully, rather than an easy\nproblem where you don’t have to think at all.")]),e._v(" "),n("p",[e._v("The design-it-twice approach not only improves your designs, but it\nalso improves your design skills. The process of devising and comparing\nmultiple approaches will teach you about the factors that make designs\nbetter or worse. Over time, this will make it easier for you to rule out bad\ndesigns and hone in on really great ones.")])])}),[],!1,null,null,null);t.default=a.exports}}]);