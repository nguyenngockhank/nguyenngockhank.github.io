(window.webpackJsonp=window.webpackJsonp||[]).push([[181],{1307:function(e,n,a){"use strict";a.r(n);var t=a(7),i=Object(t.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"high-cohesion-and-low-coupling"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#high-cohesion-and-low-coupling"}},[e._v("#")]),e._v(" High Cohesion and Low Coupling")]),e._v(" "),a("table",[a("thead",[a("tr",[a("th",[e._v("Within a Service")]),e._v(" "),a("th",[e._v("Between Services")])])]),e._v(" "),a("tbody",[a("tr",[a("td",[e._v("Single Responsibility Principle")]),e._v(" "),a("td",[e._v("SRP")])]),e._v(" "),a("tr",[a("td",[e._v("Encapsulation and Information Hiding")]),e._v(" "),a("td",[e._v("Containerization")])]),e._v(" "),a("tr",[a("td",[e._v("Dependency Injection")]),e._v(" "),a("td",[e._v("- Orchestration "),a("br"),e._v("- CI/CD "),a("br"),e._v("- Monitoring and Observability")])]),e._v(" "),a("tr",[a("td",[e._v("Use Interfaces and Abstractions")]),e._v(" "),a("td",[e._v("Service Contracts")])]),e._v(" "),a("tr",[a("td",[e._v("Modular Design and Separation of Concerns")]),e._v(" "),a("td",[e._v("- DDD "),a("br"),e._v("- API Gateway")])])])]),e._v(" "),a("h2",{attrs:{id:"within-a-service"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#within-a-service"}},[e._v("#")]),e._v(" Within a service")]),e._v(" "),a("h3",{attrs:{id:"single-responsibility-principle-srp"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#single-responsibility-principle-srp"}},[e._v("#")]),e._v(" Single Responsibility Principle (SRP)")]),e._v(" "),a("p",[e._v("The Single Responsibility Principle states that a class or module should have only one reason to change. This means that each class should be responsible for a single, well-defined task. By keeping classes focused on a specific responsibility, you can achieve high cohesion. If a class has multiple responsibilities, it becomes harder to understand and maintain.")]),e._v(" "),a("p",[e._v("For example, consider a class that handles both user authentication and database operations. Instead, you can separate these responsibilities into two separate classes: one for user authentication and another for database operations. This separation improves the code's cohesion and makes it easier to modify or extend each class independently.")]),e._v(" "),a("h3",{attrs:{id:"encapsulation-and-information-hiding"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#encapsulation-and-information-hiding"}},[e._v("#")]),e._v(" Encapsulation and Information Hiding")]),e._v(" "),a("p",[e._v("Encapsulation is the practice of bundling data and methods together within a class, while information hiding involves restricting access to internal implementation details. By encapsulating related data and methods, you can achieve high cohesion within a class. Additionally, by hiding implementation details, you reduce the coupling between classes, as other classes only need to interact with the public interface.")]),e._v(" "),a("p",[e._v("For example, consider a class that represents a bank account. Instead of exposing the account balance as a public variable, encapsulate it within the class and provide public methods to interact with it, such as getBalance() and deposit(amount). This way, other classes can interact with the account without directly accessing its internal state, reducing coupling.")]),e._v(" "),a("h3",{attrs:{id:"dependency-injection"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#dependency-injection"}},[e._v("#")]),e._v(" Dependency Injection")]),e._v(" "),a("p",[e._v("Dependency Injection is a technique that promotes loose coupling by allowing dependencies to be injected into a class from the outside. Instead of creating dependencies within a class, you pass them as parameters or use a dependency injection framework to manage them. This approach reduces the coupling between classes, as they only depend on abstractions rather than concrete implementations.")]),e._v(" "),a("p",[e._v("For example, instead of instantiating a database connection within a class, you can pass it as a parameter to the class constructor or use a dependency injection framework to manage it. This way, the class can work with different database implementations without being tightly coupled to a specific one.")]),e._v(" "),a("h3",{attrs:{id:"use-interfaces-and-abstractions"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#use-interfaces-and-abstractions"}},[e._v("#")]),e._v(" Use Interfaces and Abstractions")]),e._v(" "),a("p",[e._v("Using interfaces and abstractions is another effective way to achieve low coupling. By programming to interfaces rather than concrete implementations, you can decouple classes from each other. This allows for easier substitution of implementations and promotes modular design.")]),e._v(" "),a("p",[e._v("For example, instead of directly depending on a specific implementation of a data access layer, you can define an interface that represents the required functionality. Classes that depend on the data access layer can then depend on the interface, allowing for different implementations to be used interchangeably.")]),e._v(" "),a("h3",{attrs:{id:"modular-design-and-separation-of-concerns"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#modular-design-and-separation-of-concerns"}},[e._v("#")]),e._v(" Modular Design and Separation of Concerns")]),e._v(" "),a("p",[e._v("Breaking down your code into smaller, modular components that each have a specific responsibility can help achieve high cohesion and low coupling. Each module should be focused on a single concern and have minimal dependencies on other modules. This way, changes to one module have minimal impact on others.")]),e._v(" "),a("p",[e._v("For example, in a web application, you can separate the user interface, business logic, and data access layers into separate modules. This separation allows each module to be developed, tested, and maintained independently, reducing coupling and improving cohesion.")]),e._v(" "),a("h2",{attrs:{id:"between-services"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#between-services"}},[e._v("#")]),e._v(" Between Services")]),e._v(" "),a("h3",{attrs:{id:"single-responsibility-principle-srp-2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#single-responsibility-principle-srp-2"}},[e._v("#")]),e._v(" Single Responsibility Principle (SRP)")]),e._v(" "),a("p",[e._v("Each microservice should have a single responsibility or purpose. This ensures that the service is focused and does not have unnecessary dependencies on other services. By adhering to SRP, you can achieve high cohesion within each microservice.")]),e._v(" "),a("h3",{attrs:{id:"domain-driven-design-ddd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#domain-driven-design-ddd"}},[e._v("#")]),e._v(" Domain-Driven Design (DDD)")]),e._v(" "),a("p",[e._v("Apply DDD principles to identify and define the boundaries of each microservice based on the business domain. This helps in creating cohesive services that encapsulate related business logic and data. By aligning microservices with the domain, you can minimize dependencies and achieve high cohesion.")]),e._v(" "),a("h3",{attrs:{id:"service-contracts"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#service-contracts"}},[e._v("#")]),e._v(" Service Contracts")]),e._v(" "),a("p",[e._v("Define clear and well-defined service contracts between microservices. This includes specifying the input and output data formats, communication protocols, and error handling mechanisms. By having explicit contracts, you can achieve loose coupling between microservices, as they can evolve independently without breaking each other.")]),e._v(" "),a("h3",{attrs:{id:"event-driven-architecture-eda"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-driven-architecture-eda"}},[e._v("#")]),e._v(" Event-Driven Architecture (EDA)")]),e._v(" "),a("p",[e._v("Utilize event-driven patterns to decouple microservices. Instead of direct synchronous communication, microservices can communicate through events. This allows services to react to events asynchronously, reducing the coupling between them. Event-driven architecture promotes loose coupling and enables scalability and fault tolerance.")]),e._v(" "),a("h3",{attrs:{id:"api-gateway"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#api-gateway"}},[e._v("#")]),e._v(" API Gateway")]),e._v(" "),a("p",[e._v("Implement an API gateway as a single entry point for client applications to interact with microservices. The API gateway can handle authentication, routing, and request aggregation. By centralizing these responsibilities, the microservices can focus on their core functionalities, leading to higher cohesion and lower coupling.")]),e._v(" "),a("h3",{attrs:{id:"containerization-and-orchestration"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#containerization-and-orchestration"}},[e._v("#")]),e._v(" Containerization and Orchestration")]),e._v(" "),a("p",[e._v("Use containerization technologies like Docker and container orchestration platforms like Kubernetes. Containerization provides isolation and encapsulation, allowing microservices to be deployed independently. Orchestration platforms enable scaling, load balancing, and fault tolerance, reducing the coupling between microservices.")]),e._v(" "),a("h3",{attrs:{id:"continuous-integration-and-deployment-ci-cd"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#continuous-integration-and-deployment-ci-cd"}},[e._v("#")]),e._v(" Continuous Integration and Deployment (CI/CD)")]),e._v(" "),a("p",[e._v("Implement CI/CD pipelines to automate the build, test, and deployment processes. This ensures that changes in one microservice do not impact others, promoting low coupling. By automating the deployment process, you can quickly iterate and release new versions of microservices independently.")]),e._v(" "),a("h3",{attrs:{id:"monitoring-and-observability"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#monitoring-and-observability"}},[e._v("#")]),e._v(" Monitoring and Observability")]),e._v(" "),a("p",[e._v("Implement monitoring and observability solutions to gain insights into the behavior and performance of microservices. This helps in identifying dependencies and bottlenecks, allowing you to optimize and refactor services for better cohesion and lower coupling.")])])}),[],!1,null,null,null);n.default=i.exports}}]);