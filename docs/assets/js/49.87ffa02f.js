(window.webpackJsonp=window.webpackJsonp||[]).push([[49],{611:function(e,t){e.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAE8AAAAhCAIAAAAXqGH7AAAACXBIWXMAAAsSAAALEgHS3X78AAADGElEQVRYw+1ZPUzjMBR+hxjbtaLMZa/cFfbCDJ5D1bUeGA0jQowoc5WW4RazIsNYpZ3Tzg1zktmNWLnhoajXn9i9JkGU+4aqSr86sb/3vvfswEeekFKCGabT6Uf+2IM8cXx8TAgBAM/ztl+RDJD3cgZBAACEkCAIVhI8z+OcK6UK0BYKuIfrugDAGCtmSinYT0QOw7Df70dRVCqV4jiOouj8/Pzi4mL78Dk5OXEcp9Vq1Wq1TqcDX4gkeQgh89ll27bjOBmuK2MMAKSUOemmlGKMCSE0kYyRtuCKrutm65NKKa1jbYPpdKodHJRSAJCtjP/sWMt2zTknhFBK03PecRxcSkoppXSdTiCEAADD22+PwWBg4lhKKc45hj3qoXU4XBeNJzPGtKS//rAG5tHhOA4AcM7TH32e4LqudlhCSPqYnw+vJWUub3owYwZu5Bqof7pFffZScRwXVgLG4/HV1dXz83O1Wl3HGY1GAHBwcLBwfTabDYfD6+vr8Xg8HA4bjUav18OfoigCgFqtpiFzzk2yIpNIDoKAUqr1CHykBenwE9NeCCGlxFIy337iyCvJ+H3PsiwAuLm5CcMQl8T3/aenp007zcvLy3RVwzBst9sPDw8pqiLq9ToAvLy8AIDv+71eD9Uul8uHh4fIOT09jeMYa3iiLQA8Pv5+e3tbJr+/vzPGAPMEDY0QggU6c4s2VDVR0rZtLCdCiPm4k1Im1YhzPhgMklTHh5/P9mUyFFNmU2rgRri7u0MrCoJAa662bS+Qi9gDnZ2dpasqpTTsKCmlhBDbtk34y2QoQFVtAFNKTaoglhnzdFgm5ztb7OZMYDJbrMMbtc1rd3x5wLKsZrNpeMqh5ZRKJSwkJlhJ/pVSQncPe/CT8H+2u4v9wu7k+z42gM1m8/7+PoqibrdbLpd3VtvX19c4jvv9/u3trRACG9rd1Pbo6Ain1+128crynu7bn54vNDd4SuZ5XqvVKv48ubjZ4jYl2cF+yUl6cbPFDTfnfGET9zXvCvLGZDIRQmTy8uEbePJkMqlUKj+lu7Asy3xLlBP+AASs5fHvfH4tAAAAAElFTkSuQmCC"},612:function(e,t,o){e.exports=o.p+"assets/img/image--002.c18dec8f.jpg"},995:function(e,t,o){"use strict";o.r(t);var n=o(7),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_2-the-nature-of-complexity"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-the-nature-of-complexity"}},[e._v("#")]),e._v(" 2. The Nature of Complexity")]),e._v(" "),n("p",[e._v("This book is about how to design software systems to minimize their\ncomplexity. The first step is to understand the enemy. Exactly what is\n“complexity”? How can you tell if a system is unnecessarily complex?\nWhat causes systems to become complex? This chapter will address those\nquestions at a high level; subsequent chapters will show you how to\nrecognize complexity at a lower level, in terms of specific structural\nfeatures.")]),e._v(" "),n("p",[e._v("The ability to recognize complexity is a crucial design skill. It allows\nyou to identify problems before you invest a lot of effort in them, and it\nallows you to make good choices among alternatives. It is easier to tell\nwhether a design is simple than it is to create a simple design, but once\nyou can recognize that a system is too complicated, you can use that\nability to guide your design philosophy towards simplicity. If a design\nappears complicated, try a different approach and see if that is simpler.\nOver time, you will notice that certain techniques tend to result in simpler\ndesigns, while others correlate with complexity. This will allow you to\nproduce simpler designs more quickly.")]),e._v(" "),n("p",[e._v("This chapter also lays out some basic assumptions that provide a\nfoundation for the rest of the book. Later chapters take the material of this\nchapter as given and use it to justify a variety of refinements and\nconclusions.")]),e._v(" "),n("h2",{attrs:{id:"_2-1-complexity-dened"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-complexity-dened"}},[e._v("#")]),e._v(" 2.1 Complexity dened")]),e._v(" "),n("p",[e._v("For the purposes of this book, I define “complexity” in a practical way.\n"),n("strong",[e._v("Complexity is anything related to the structure of a software system that makes it hard to understand and modify the system.")]),e._v(" Complexity can take many forms. For example, it might be hard to understand how a\npiece of code works; it might take a lot of effort to implement a small\nimprovement, or it might not be clear which parts of the system must be\nmodified to make the improvement; it might be difficult to fix one bug\nwithout introducing another. If a software system is hard to understand\nand modify, then it is complicated; if it is easy to understand and modify,\nthen it is simple.")]),e._v(" "),n("p",[e._v("You can also think of complexity in terms of cost and benefit. In a\ncomplex system, it takes a lot of work to implement even small\nimprovements. In a simple system, larger improvements can be\nimplemented with less effort.")]),e._v(" "),n("p",[e._v("Complexity is what a developer experiences at a particular point in\ntime when trying to achieve a particular goal. It doesn’t necessarily relate\nto the overall size or functionality of the system. People often use the word\n“complex” to describe large systems with sophisticated features, but if\nsuch a system is easy to work on, then, for the purposes of this book, it is\nnot complex. Of course, almost all large and sophisticated software\nsystems are in fact hard to work on, so they also meet my definition of\ncomplexity, but this need not necessarily be the case. It is also possible for\na small and unsophisticated system to be quite complex.")]),e._v(" "),n("p",[e._v("Complexity is determined by the activities that are most common. If a\nsystem has a few parts that are very complicated, but those parts almost\nnever need to be touched, then they don’t have much impact on the overall\ncomplexity of the system. To characterize this in a crude mathematical\nway:")]),e._v(" "),n("p",[n("img",{attrs:{src:o(611),alt:"Image"}})]),e._v(" "),n("p",[e._v("The overall complexity of a system (C) is determined by the complexity of each part p (cp) weighted by the fraction of time developers spend working on that part (tp). Isolating complexity in a place where it\nwill never be seen is almost as good as eliminating the complexity\nentirely.")]),e._v(" "),n("p",[e._v("Complexity is more apparent to readers than writers. If you write a\npiece of code and it seems simple to you, but other people think it is")]),e._v(" "),n("p",[e._v("complex, then it is complex. When you find yourself in situations like this,\nit’s worth probing the other developers to find out why the code seems\ncomplex to them; there are probably some interesting lessons to learn\nfrom the disconnect between your opinion and theirs. Your job as a\ndeveloper is not just to create code that you can work with easily, but to\ncreate code that others can also work with easily.")]),e._v(" "),n("h2",{attrs:{id:"_2-2-symptoms-of-complexity"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-symptoms-of-complexity"}},[e._v("#")]),e._v(" 2.2 Symptoms of complexity")]),e._v(" "),n("p",[e._v("Complexity manifests itself in three general ways, which are described in\nthe paragraphs below. Each of these manifestations makes it harder to\ncarry out development tasks.")]),e._v(" "),n("p",[n("strong",[e._v("Change amplification")]),e._v(": The first symptom of complexity is that a\nseemingly simple change requires code modifications in many different\nplaces. For example, consider a Web site containing several pages, each of\nwhich displays a banner with a background color. In many early Web sites,\nthe color was specified explicitly on each page, as shown in Figure 2.1(a).\nIn order to change the background for such a Web site, a developer might\nhave to modify every existing page by hand; this would be nearly\nimpossible for a large site with thousands of pages. Fortunately, modern\nWeb sites use an approach like that in Figure 2.1(b), where the banner\ncolor is specified once in a central place, and all of the individual pages\nreference that shared value. With this approach, the banner color of the\nentire Web site can be changed with a single modification. One of the\ngoals of good design is to reduce the amount of code that is affected by\neach design decision, so design changes don’t require very many code\nmodifications.")]),e._v(" "),n("p",[n("strong",[e._v("Cognitive load")]),e._v(": The second symptom of complexity is cognitive load,\nwhich refers to how much a developer needs to know in order to complete\na task. A higher cognitive load means that developers have to spend more\ntime learning the required information, and there is a greater risk of bugs\nbecause they have missed something important. For example, suppose a\nfunction in C allocates memory, returns a pointer to that memory, and\nassumes that the caller will free the memory. This adds to the cognitive\nload of developers using the function; if a developer fails to free the\nmemory, there will be a memory leak. If the system can be restructured so that the caller doesn’t need to worry about freeing the memory (the same module that allocates the memory also takes responsibility for freeing it), it will reduce the cognitive load. Cognitive load arises in many ways, such\nas APIs with many methods, global variables, inconsistencies, and dependencies between modules.")]),e._v(" "),n("p",[e._v("System designers sometimes assume that complexity can be measured\nby lines of code. They assume that if one implementation is shorter than\nanother, then it must be simpler; if it only takes a few lines of code to\nmake a change, then the change must be easy. However, this view ignores\nthe costs associated with cognitive load. I have seen frameworks that\nallowed applications to be written with only a few lines of code, but it was\nextremely difficult to figure out what those lines were. "),n("strong",[e._v("Sometimes an approach that requires more lines of code is actually simpler, because it reduces cognitive load.")])]),e._v(" "),n("p",[n("img",{attrs:{src:o(612),alt:"Image"}})]),e._v(" "),n("p",[n("strong",[e._v("Figure 2.1")]),e._v(": "),n("em",[e._v("Each page in a Web site displays a colored banner. In (a) the background color for the banner is specified explicitly in each page. In (b) a shared variable holds the background color and each page references that variable. In (c) some pages display an additional color for emphasis, which is a darker shade of the banner background color; if the background color changes, the emphasis color must also change.")])]),e._v(" "),n("p",[n("strong",[e._v("Unknown unknowns")]),e._v(": The third symptom of complexity is that it is\nnot obvious which pieces of code must be modified to complete a task, or\nwhat information a developer must have to carry out the task successfully.\nFigure 2.1(c) illustrates this problem. The Web site uses a central variable\nto determine the banner background color, so it appears to be easy to change. However, a few Web pages use a darker shade of the background color for emphasis, and that darker color is specified explicitly in the\nindividual pages. If the background color changes, then the the emphasis\ncolor must change to match. Unfortunately, developers are unlikely to\nrealize this, so they may change the central bannerBg variable without updating the emphasis color. Even if a developer is aware of the problem, it won’t be obvious which pages use the emphasis color, so the developer\nmay have to search every page in the Web site.")]),e._v(" "),n("p",[e._v("Of the three manifestations of complexity, unknown unknowns are the\nworst. An unknown unknown means that there is something you need to\nknow, but there is no way for you to find out what it is, or even whether\nthere is an issue. You won’t find out about it until bugs appear after you\nmake a change. Change amplification is annoying, but as long as it is clear\nwhich code needs to be modified, the system will work once the change\nhas been completed. Similarly, a high cognitive load will increase the cost\nof a change, but if it is clear which information to read, the change is still\nlikely to be correct. With unknown unknowns, it is unclear what to do or\nwhether a proposed solution will even work. The only way to be certain is\nto read every line of code in the system, which is impossible for systems\nof any size. Even this may not be sufficient, because a change may depend\non a subtle design decision that was never documented.")]),e._v(" "),n("p",[e._v("One of the most important goals of good design is for a system to be "),n("em",[e._v("obvious")]),e._v(". This is the opposite of high cognitive load and unknown unknowns. In an obvious system, a developer can quickly understand how\nthe existing code works and what is required to make a change. An obvious system is one where a developer can make a quick guess about what to do, without thinking very hard, and yet be confident that the guess is correct. "),n("RouterLink",{attrs:{to:"/kungfu/philosophy/c18.html"}},[e._v("Chapter 18")]),e._v(" discusses techniques for making code more obvious.")],1),e._v(" "),n("h2",{attrs:{id:"_2-3-causes-of-complexity"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-causes-of-complexity"}},[e._v("#")]),e._v(" 2.3  Causes of complexity")]),e._v(" "),n("p",[e._v("Now that you know the high-level symptoms of complexity and why complexity makes software development difficult, the next step is to understand what causes complexity, so that we can design systems to avoid the problems. Complexity is caused by two things: "),n("em",[e._v("dependencies")]),e._v(" and "),n("em",[e._v("obscurity")]),e._v(". This section discusses these factors at a high level; subsequent chapters will discuss how they relate to lower-level design decisions.")]),e._v(" "),n("p",[e._v("For the purposes of this book, a dependency exists when a given piece\nof code cannot be understood and modified in isolation; the code relates in\nsome way to other code, and the other code must be considered and/or\nmodified if the given code is changed. In the Web site example of Figure\n2.1(a), the background color creates dependencies between all of the pages.\nAll of the pages need to have the same background, so if the background is\nchanged for one page, then it must be changed for all of them. Another\nexample of dependencies occurs in network protocols. Typically there is\nseparate code for the sender and receiver for the protocol, but they must\neach conform to the protocol; changing the code for the sender almost\nalways requires corresponding changes at the receiver, and vice versa. The\nsignature of a method creates a dependency between the implementation\nof that method and the code that invokes it: if a new parameter is added to\na method, all of the invocations of that method must be modified to\nspecify that parameter.")]),e._v(" "),n("p",[e._v("Dependencies are a fundamental part of software and can’t be\ncompletely eliminated. In fact, we intentionally introduce dependencies as\npart of the software design process. Every time you write a new class you\ncreate dependencies around the API for that class. However, one of the\ngoals of software design is to reduce the number of dependencies and to\nmake the dependencies that remain as simple and obvious as possible.")]),e._v(" "),n("p",[e._v("Consider the Web site example. In the old Web site with the\nbackground specified separately on each page, all of the Web pages were\ndependent on each other. The new Web site fixed this problem by\nspecifying the background color in a central place and providing an API\nthat individual pages use to retrieve that color when they are rendered. The\nnew Web site eliminated the dependency between the pages, but it created\na new dependency around the API for retrieving the background color.\nFortunately, the new dependency is more obvious: it is clear that each\nindividual Web page depends on the bannerBg color, and a developer can")]),e._v(" "),n("p",[e._v("easily find all the places where the variable is used by searching for its\nname. Furthermore, compilers help to manage API dependencies: if the\nname of the shared variable changes, compilation errors will occur in any\ncode that still uses the old name. The new Web site replaced a nonobvious\nand difficult-to-manage dependency with a simpler and more obvious one.")]),e._v(" "),n("p",[e._v("The second cause of complexity is obscurity. Obscurity occurs when\nimportant information is not obvious. A simple example is a variable\nname that is so generic that it doesn’t carry much useful information (e.g.,\ntime). Or, the documentation for a variable might not specify its units, so")]),e._v(" "),n("p",[e._v("the only way to find out is to scan code for places where the variable is\nused. Obscurity is often associated with dependencies, where it is not\nobvious that a dependency exists. For example, if a new error status is\nadded to a system, it may be necessary to add an entry to a table holding\nstring messages for each status, but the existence of the message table\nmight not be obvious to a programmer looking at the status declaration.\nInconsistency is also a major contributor to obscurity: if the same variable\nname is used for two different purposes, it won’t be obvious to developer\nwhich of these purposes a particular variable serves.")]),e._v(" "),n("p",[e._v("In many cases, obscurity comes about because of inadequate\ndocumentation; Chapter 13 deals with this topic. However, obscurity is\nalso a design issue. If a system has a clean and obvious design, then it will\nneed less documentation. The need for extensive documentation is often a\nred flag that the design isn’t quite right. The best way to reduce obscurity\nis by simplifying the system design.")]),e._v(" "),n("p",[e._v("Together, dependencies and obscurity account for the three\nmanifestations of complexity described in Section 2.2. Dependencies lead\nto change amplification and a high cognitive load. Obscurity creates\nunknown unknowns, and also contributes to cognitive load. If we can find\ndesign techniques that minimize dependencies and obscurity, then we can\nreduce the complexity of software.")]),e._v(" "),n("h2",{attrs:{id:"_2-4-complexity-is-incremental"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-complexity-is-incremental"}},[e._v("#")]),e._v(" 2.4 Complexity is incremental")]),e._v(" "),n("p",[e._v("Complexity isn’t caused by a single catastrophic error; it accumulates in\nlots of small chunks. A single dependency or obscurity, by itself, is\nunlikely to affect significantly the maintainability of a software system.\nComplexity comes about because hundreds or thousands of small\ndependencies and obscurities build up over time. Eventually, there are so\nmany of these small issues that every possible change to the system is\naffected by several of them.")]),e._v(" "),n("p",[e._v("The incremental nature of complexity makes it hard to control. It’s\neasy to convince yourself that a little bit of complexity introduced by your\ncurrent change is no big deal. However, if every developer takes this\napproach for every change, complexity accumulates rapidly. Once\ncomplexity has accumulated, it is hard to eliminate, since fixing a single\ndependency or obscurity will not, by itself, make a big difference. In order\nto slow the growth of complexity, you must adopt a “zero tolerance”\nphilosophy, as discussed in Chapter 3.")]),e._v(" "),n("h2",{attrs:{id:"_2-5-conclusion"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_2-5-conclusion"}},[e._v("#")]),e._v(" 2.5 Conclusion")]),e._v(" "),n("p",[e._v("Complexity comes from an accumulation of dependencies and obscurities.\nAs complexity increases, it leads to change amplification, a high cognitive\nload, and unknown unknowns. As a result, it takes more code\nmodifications to implement each new feature. In addition, developers\nspend more time acquiring enough information to make the change safely\nand, in the worst case, they can’t even find all the information they need.\nThe bottom line is that complexity makes it difficult and risky to modify\nan existing code base.")])])}),[],!1,null,null,null);t.default=a.exports}}]);