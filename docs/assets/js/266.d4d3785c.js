(window.webpackJsonp=window.webpackJsonp||[]).push([[266],{850:function(e,t,n){"use strict";n.r(t);var a=n(7),s=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"a-philosophy-of-software-design"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#a-philosophy-of-software-design"}},[e._v("#")]),e._v(" A Philosophy of Software Design")]),e._v(" "),n("h1",{attrs:{id:"john-ousterhout"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#john-ousterhout"}},[e._v("#")]),e._v(" John Ousterhout")]),e._v(" "),n("h1",{attrs:{id:"stanford-university"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#stanford-university"}},[e._v("#")]),e._v(" Stanford University")]),e._v(" "),n("p",[e._v("A Philosophy of Software Design\nby John Ousterhout")]),e._v(" "),n("p",[e._v("Copyright © 2018 John K. Ousterhout.\nAll rights reserved. No part of this book may be reproduced, in any form or by any means,\nwithout permission in writing from the author.\nPublished by Yaknyam Press, Palo Alto, CA.")]),e._v(" "),n("p",[e._v("Cover design by Pete Nguyen and Shirin Oreizy (www.hellonextstep.com).")]),e._v(" "),n("p",[e._v("Printing History:\nApril 2018:                First Edition (v1.0)\nNovember 2018:        First Edition (v1.01)")]),e._v(" "),n("p",[e._v("ISBN 978-1-7321022-0-")]),e._v(" "),n("p",[e._v("Digital book(s) (epub and mobi) produced by Booknook.biz.")]),e._v(" "),n("h1",{attrs:{id:"contents"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#contents"}},[e._v("#")]),e._v(" Contents")]),e._v(" "),n("p",[e._v("Preface")]),e._v(" "),n("p",[e._v("1     Introduction")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("1.1 How to use this book\n")])])]),n("p",[e._v("2     The Nature of Complexity")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("2.1 Complexity defined\n2.2 Symptoms of complexity\n2.3 Causes of complexity\n2.4 Complexity is incremental\n2.5 Conclusion\n")])])]),n("p",[e._v("3     Working Code Isn’t Enough")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("3.1 Tactical programming\n3.2 Strategic programming\n3.3 How much to invest?\n3.4 Startups and investment\n3.5 Conclusion\n")])])]),n("p",[e._v("4     Modules Should Be Deep")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("4.1 Modular design\n4.2 What’s in an interface?\n4.3 Abstractions\n4.4 Deep modules\n4.5 Shallow modules\n4.6 Classitis\n4.7 Examples: Java and Unix I/O\n4.8 Conclusion\n")])])]),n("p",[e._v("5     Information Hiding (and Leakage)")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("5.1 Information hiding\n5.2 Information leakage\n5.3 Temporal decomposition\n5.4 Example: HTTP server\n5.5 Example: too many classes\n5.6 Example: HTTP parameter handling\n5.7 Example: defaults in HTTP responses\n5.8 Information hiding within a class\n5.9 Taking it too far\n5.10 Conclusion\n")])])]),n("p",[e._v("6     General-Purpose Modules are Deeper")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("6.1 Make classes somewhat general-purpose\n6.2 Example: storing text for an editor\n6.3 A more general-purpose API\n6.4 Generality leads to better information hiding\n6.5 Questions to ask yourself\n6.6 Conclusion\n")])])]),n("p",[e._v("7     Different Layer, Different Abstraction")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("7.1 Pass-through methods\n7.2 When is interface duplication OK?\n7.3 Decorators\n7.4 Interface versus implementation\n7.5 Pass-through variables\n7.6 Conclusion\n")])])]),n("p",[e._v("8     Pull Complexity Downwards")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("8.1 Example: editor text class\n8.2 Example: configuration parameters\n8.3 Taking it too far\n8.4 Conclusion\n")])])]),n("p",[e._v("9     Better Together Or Better Apart?")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("9.1 Bring together if information is shared\n9.2 Bring together if it will simplify the interface\n9.3 Bring together to eliminate duplication\n9.4 Separate general-purpose and special-purpose code\n9.5 Example: insertion cursor and selection\n9.6 Example: separate class for logging\n9.7 Example: editor undo mechanism\n9.8 Splitting and joining methods\n9.9 Conclusion\n")])])]),n("p",[e._v("10   Define Errors Out Of Existence")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("10.1 Why exceptions add complexity\n10.2 Too many exceptions\n10.3 Define errors out of existence\n10.4 Example: file deletion in Windows\n10.5 Example: Java substring method\n10.6 Mask exceptions\n10.7 Exception aggregation\n10.8 Just crash?\n10.9 Design special cases out of existence\n10.10 Taking it too far\n10.11 Conclusion\n")])])]),n("p",[e._v("11   Design it Twice")]),e._v(" "),n("p",[e._v("12   Why Write Comments? The Four Excuses")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("12.1 Good code is self-documenting\n12.2 I don’t have time to write comments\n12.3 Comments get out of date and become misleading\n12.4 All the comments I have seen are worthless\n12.5 Benefits of well-written comments\n")])])]),n("p",[e._v("13   Comments Should Describe Things that Aren’t Obvious from the Code")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("13.1 Pick conventions\n13.2 Don’t repeat the code\n13.3 Lower-level comments add precision\n13.4 Higher-level comments enhance intuition\n13.5 Interface documentation\n13.6 Implementation comments: what and why, not how\n13.7 Cross-module design decisions\n13.8 Conclusion\n13.9 Answers to questions from Section 13.\n")])])]),n("p",[e._v("14   Choosing Names")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("14.1 Example: bad names cause bugs\n14.2 Create an image\n14.3 Names should be precise\n14.4 Use names consistently\n14.5 A different opinion: Go style guide\n14.6 Conclusion\n")])])]),n("p",[e._v("15   Write The Comments First")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("15.1 Delayed comments are bad comments\n15.2 Write the comments first\n15.3 Comments are a design tool\n15.4 Early comments are fun comments\n15.5 Are early comments expensive?\n15.6 Conclusion\n")])])]),n("p",[e._v("16   Modifying Existing Code")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("16.1 Stay strategic\n16.2 Maintaining comments: keep the comments near the code\n16.3 Comments belong in the code, not the commit log\n16.4 Maintaining comments: avoid duplication\n16.5 Maintaining comments: check the diffs\n16.6 Higher-level comments are easier to maintain\n")])])]),n("p",[e._v("17   Consistency")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("17.1 Examples of consistency\n17.2 Ensuring consistency\n17.3 Taking it too far\n17.4 Conclusion\n")])])]),n("p",[e._v("18   Code Should be Obvious")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("18.1 Things that make code more obvious\n18.2 Things that make code less obvious\n18.3 Conclusion\n")])])]),n("p",[e._v("19   Software Trends")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("19.1 Object-oriented programming and inheritance\n19.2 Agile development\n19.3 Unit tests\n19.4 Test-driven development\n19.5 Design patterns\n19.6 Getters and setters\n19.7 Conclusion\n")])])]),n("p",[e._v("20   Designing for Performance")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("20.1 How to think about performance\n20.2 Measure before modifying\n20.3 Design around the critical path\n20.4 An example: RAMCloud Buffers\n20.5 Conclusion\n")])])]),n("p",[e._v("21   Conclusion")]),e._v(" "),n("p",[e._v("Index")]),e._v(" "),n("p",[e._v("Summary of Design Principles")]),e._v(" "),n("p",[e._v("Summary of Red Flags")]),e._v(" "),n("h1",{attrs:{id:"preface"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#preface"}},[e._v("#")]),e._v(" Preface")]),e._v(" "),n("p",[e._v("People have been writing programs for electronic computers for more than\n80 years, but there has been surprisingly little conversation about how to\ndesign those programs or what good programs should look like. There has\nbeen considerable discussion about software development processes such\nas agile development and about development tools such as debuggers,\nversion control systems, and test coverage tools. There has also been\nextensive analysis of programming techniques such as object-oriented\nprogramming and functional programming, and of design patterns and\nalgorithms. All of these discussions have been valuable, but the core\nproblem of software design is still largely untouched. David Parnas’\nclassic paper “On the Criteria to be used in Decomposing Systems into\nModules” appeared in 1971, but the state of the art in software design has\nnot progressed much beyond that paper in the ensuing 45 years.")]),e._v(" "),n("p",[e._v("The most fundamental problem in computer science is problem\ndecomposition: how to take a complex problem and divide it up into pieces\nthat can be solved independently. Problem decomposition is the central\ndesign task that programmers face every day, and yet, other than the work\ndescribed here, I have not been able to identify a single class in any\nuniversity where problem decomposition is a central topic. We teach for")]),e._v(" "),n("p",[e._v("loops and object-oriented programming, but not software design.")]),e._v(" "),n("p",[e._v("In addition, there is a huge variation in quality and productivity among\nprogrammers, but we have made little attempt to understand what makes\nthe best programmers so much better or to teach those skills in our classes.\nI have talked with several people I consider to be great programmers, but\nmost of them had difficulty articulating specific techniques that give them\ntheir advantage. Many people assume that software design skill is an\ninnate talent that cannot be taught. However, there is quite a bit of\nscientific evidence that outstanding performance in many fields is related\nmore to high-quality practice than innate ability (see, for example, Talent\nis Overrated by Geoff Colvin).")]),e._v(" "),n("p",[e._v("For many years these issues have perplexed and frustrated me. I have\nwondered whether software design can be taught, and I have hypothesized\nthat design skill is what separates great programmers from average ones. I\nfinally decided that the only way to answer these questions was to attempt\nto teach a course on software design. The result is CS 190 at Stanford\nUniversity. In this class I put forth a set of principles of software design.\nStudents then work through a series of projects to assimilate and practice\nthe principles. The class is taught in a fashion similar to a traditional\nEnglish writing class. In an English class, students use an iterative process\nwhere they write a draft, get feedback, and then rewrite to make\nimprovements. In CS 190, students develop a substantial piece of software\nfrom scratch. We then go through extensive code reviews to identify\ndesign problems, and students revise their projects to fix the problems.\nThis allows students to see how their code can be improved by applying\ndesign principles.")]),e._v(" "),n("p",[e._v("I have now taught the software design class three times, and this book\nis based on the design principles that emerged from the class. The\nprinciples are fairly high level and border on the philosophical (“Define\nerrors out of existence”), so it is hard for students to understand the ideas\nin the abstract. Students learn best by writing code, making mistakes, and\nthen seeing how their mistakes and the subsequent fixes relate to the\nprinciples.")]),e._v(" "),n("p",[e._v("At this point you may well be wondering: what makes me think I know\nall the answers about software design? To be honest, I don’t. There were no\nclasses on software design when I learned to program, and I never had a\nmentor to teach me design principles. At the time I learned to program,\ncode reviews were virtually nonexistent. My ideas about software design\ncome from personal experience writing and reading code. Over my career\nI have written about 250,000 lines of code in a variety of languages. I’ve\nworked on teams that created three operating systems from scratch,\nmultiple file and storage systems, infrastructure tools such as debuggers,\nbuild systems, and GUI toolkits, a scripting language, and interactive\neditors for text, drawings, presentations, and integrated circuits. Along the\nway I’ve experienced firsthand the problems of large systems and\nexperimented with various design techniques. In addition, I’ve read a")]),e._v(" "),n("p",[e._v("considerable amount of code written by other people, which has exposed\nme to a variety of approaches, both good and bad.")]),e._v(" "),n("p",[e._v("Out of all of this experience, I’ve tried to extract common threads,\nboth about mistakes to avoid and techniques to use. This book is a\nreflection of my experiences: every problem described here is one that I\nhave experienced personally, and every suggested technique is one that I\nhave used successfully in my own coding.")]),e._v(" "),n("p",[e._v("I don’t expect this book to be the final word on software design; I’m\nsure there are valuable techniques that I’ve missed, and some of my\nsuggestions may turn out to be bad ideas in the long run. However, I hope\nthat the book will start a conversation about software design. Compare the\nideas in this book with your own experiences and decide for yourself\nwhether the approaches described here really do reduce software\ncomplexity. This book is an opinion piece, so some readers will disagree\nwith some of my suggestions. If you do disagree, try to understand why.\nI’m interested in hearing about things that work for you, things that don’t\nwork, and any other ideas you may have about software design. I hope that\nthe ensuing conversations will improve our collective understanding of\nsoftware design. I will incorporate what I learn in future editions of this\nbook.")]),e._v(" "),n("p",[e._v("The best way to communicate with me about the book is to send email\nto the following address:")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("software-design-book@googlegroups.com\n")])])]),n("p",[e._v("I’m interested in hearing specific feedback about the book, such as bugs or\nsuggestions for improvement, as well as general thoughts and experiences\nrelated to software design. I’m particularly interested in compelling\nexamples that I can use in future editions of the book. The best examples\nillustrate an important design principle and are simple enough to explain\nin a paragraph or two. If you would like to see what other people are\nsaying on the email address and participate in discussions, you can join the\nGoogle Group software-design-book.")]),e._v(" "),n("p",[e._v("If for some reason the software-design-book Google Group should\ndisappear in the future, search on the Web for my home page; it will")]),e._v(" "),n("p",[e._v("contain updated instructions for how to communicate about the book.\nPlease don’t send book-related email to my personal email address.")]),e._v(" "),n("p",[e._v("I recommend that you take the suggestions in this book with a grain of\nsalt. The overall goal is to reduce complexity; this is more important than\nany particular principle or idea you read here. If you try an idea from this\nbook and find that it doesn’t actually reduce complexity, then don’t feel\nobligated to keep using it (but, do let me know about your experience; I’d\nlike to get feedback on what works and what doesn’t).")]),e._v(" "),n("p",[e._v("Many people have offered criticisms or made suggestions that\nimproved the quality of the book. The following people offered helpful\ncomments on various drafts of the book: Jeff Dean, Sanjay Ghemawat,\nJohn Hartman, Brian Kernighan, James Koppel, Amy Ousterhout, Kay\nOusterhout, Rob Pike, Partha Ranganathan, Keith Schwartz, and Alex\nSnaps. Christos Kozyrakis suggested the terms “deep” and “shallow” for\nclasses and interfaces, replacing previous terms “thick” and “thin”, which\nwere somewhat ambiguous. I am indebted to the students in CS 190; the\nprocess of reading their code and discussing it with them has helped to\ncrystallize my thoughts about design.")])])}),[],!1,null,null,null);t.default=s.exports}}]);