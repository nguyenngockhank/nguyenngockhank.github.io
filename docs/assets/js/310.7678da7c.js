(window.webpackJsonp=window.webpackJsonp||[]).push([[310],{932:function(e,t,n){"use strict";n.r(t);var a=n(7),o=Object(a.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"_10-dene-errors-out-of-existence"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-dene-errors-out-of-existence"}},[e._v("#")]),e._v(" 10.  Dene Errors Out Of Existence")]),e._v(" "),n("p",[e._v("Exception handling is one of the worst sources of complexity in software\nsystems. Code that deals with special conditions is inherently harder to\nwrite than code that deals with normal cases, and developers often define\nexceptions without considering how they will be handled. This chapter\ndiscusses why exceptions contribute disproportionately to complexity, then\nit shows how to simplify exception handling. The key overall lesson from\nthis chapter is to reduce the number of places where exceptions must be\nhandled; in many cases the semantics of operations can be modified so\nthat the normal behavior handles all situations and there is no exceptional\ncondition to report (hence the title of this chapter).")]),e._v(" "),n("h2",{attrs:{id:"_10-1-why-exceptions-add-complexity"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-1-why-exceptions-add-complexity"}},[e._v("#")]),e._v(" 10.1  Why exceptions add complexity")]),e._v(" "),n("p",[e._v("I use the term exception to refer to any uncommon condition that alters the\nnormal flow of control in a program. Many programming languages\ninclude a formal exception mechanism that allows exceptions to be thrown\nby lower-level code and caught by enclosing code. However, exceptions\ncan occur even without using a formal exception reporting mechanism,\nsuch as when a method returns a special value indicating that it didn’t\ncomplete its normal behavior. All of these forms of exceptions contribute\nto complexity.")]),e._v(" "),n("p",[e._v("A particular piece of code may encounter exceptions in several\ndifferent ways:\nA caller may provide bad arguments or configuration information.\nAn invoked method may not be able to complete a requested\noperation. For example, an I/O operation may fail, or a required\nresource may not be available.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("In a distributed system, network packets may be lost or delayed,\nservers may not respond in a timely fashion, or peers may\ncommunicate in unexpected ways.\nThe code may detect bugs, internal inconsistencies, or situations it is\nnot prepared to handle.\n")])])]),n("p",[e._v("Large systems have to deal with many exceptional conditions, particularly\nif they are distributed or need to be fault-tolerant. Exception handling can\naccount for a significant fraction of all the code in a system.")]),e._v(" "),n("p",[e._v("Exception handling code is inherently more difficult to write than\nnormal-case code. An exception disrupts the normal flow of the code; it\nusually means that something didn’t work as expected. When an exception\noccurs, the programmer can deal with it in two ways, each of which can be\ncomplicated. The first approach is to move forward and complete the work\nin progress in spite of the exception. For example, if a network packet is\nlost, it can be resent; if data is corrupted, perhaps it can be recovered from\na redundant copy. The second approach is to abort the operation in\nprogress and report the exception upwards. However, aborting can be\ncomplicated because the exception may have occurred at a point where\nsystem state is inconsistent (a data structure might have been partially\ninitialized); the exception handling code must restore consistency, such as\nby unwinding any changes made before the exception occurred.")]),e._v(" "),n("p",[e._v("Furthermore, exception handling code creates opportunities for more\nexceptions. Consider the case of resending a lost network packet. Perhaps\nthe packet wasn’t actually lost, but was simply delayed. In this case,\nresending the packet will result in duplicate packets arriving at the peer;\nthis introduces a new exceptional condition that the peer must handle. Or,\nconsider the case of recovering lost data from a redundant copy: what if\nthe redundant copy has also been lost? Secondary exceptions occurring\nduring recovery are often more subtle and complex than the primary\nexceptions. If an exception is handled by aborting the operation in\nprogress, then this must be reported to the caller as another exception. To\nprevent an unending cascade of exceptions, the developer must eventually\nfind a way to handle exceptions without introducing more exceptions.")]),e._v(" "),n("p",[e._v("Language support for exceptions tends to be verbose and clunky, which\nmakes exception handling code hard to read. For example, consider the")]),e._v(" "),n("p",[e._v("following code, which reads a collection of tweets from a file using Java’s\nsupport for object serialization and deserialization:\ntry (\nFileInputStream fileStream =")]),e._v(" "),n("p",[e._v("new FileInputStream(fileName);\nBufferedInputStream bufferedStream =")]),e._v(" "),n("p",[e._v("new BufferedInputStream(fileStream);\nObjectInputStream objectStream =")]),e._v(" "),n("p",[e._v("new ObjectInputStream(bufferedStream);\n) {\nfor (int i = 0; i < tweetsPerFile; i++) {")]),e._v(" "),n("p",[e._v("tweets.add((Tweet) objectStream.readObject());\n}\n}\ncatch (FileNotFoundException e) {")]),e._v(" "),n("p",[e._v("...\n}\ncatch (ClassNotFoundException e) {\n...\n}\ncatch (EOFException e) {")]),e._v(" "),n("p",[e._v("// Not a problem: not all tweet files have full\n// set of tweets.\n}\ncatch (IOException e) {")]),e._v(" "),n("p",[e._v("...\n}\ncatch (ClassCastException e) {\n...\n}")]),e._v(" "),n("p",[e._v("Just the basic try-catch boilerplate accounts for more lines of code than\nthe code for normal-case operation, without even considering the code that\nactually handles the exceptions. It is hard to relate the exception handling\ncode to the normal-case code: for example, it’s not obvious where each")]),e._v(" "),n("p",[e._v("exception is generated. An alternative approach is to break up the code\ninto many distinct try blocks; in the extreme case there could be a try for")]),e._v(" "),n("p",[e._v("each line of code that can generate an exception. This would make it clear\nwhere exceptions occur, but the try blocks themselves break up the flow of\nthe code and make it harder to read; in addition, some exception handling\ncode might end up duplicated in multiple try blocks.")]),e._v(" "),n("p",[e._v("It’s difficult to ensure that exception handling code really works. Some\nexceptions, such as I/O errors, can’t easily be generated in a test\nenvironment, so it’s hard to test the code that handles them. Exceptions\ndon’t occur very often in running systems, so exception handling code\nrarely executes. Bugs can go undetected for a long time, and when the\nexception handling code is finally needed, there’s a good chance that it\nwon’t work (one of my favorite sayings: “code that hasn’t been executed\ndoesn’t work”). A recent study found that more than 90% of catastrophic\nfailures in distributed data-intensive systems were caused by incorrect\nerror handling^1. When exception handling code fails, it’s difficult to debug\nthe problem, since it occurs so infrequently.")]),e._v(" "),n("h2",{attrs:{id:"_10-2-too-many-exceptions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-2-too-many-exceptions"}},[e._v("#")]),e._v(" 10.2  Too many exceptions")]),e._v(" "),n("p",[e._v("Programmers exacerbate the problems related to exception handling by\ndefining unnecessary exceptions. Most programmers are taught that it’s\nimportant to detect and report errors; they often interpret this to mean “the\nmore errors detected, the better.” This leads to an over-defensive style\nwhere anything that looks even a bit suspicious is rejected with an\nexception, which results in a proliferation of unnecessary exceptions that\nincrease the complexity of the system.")]),e._v(" "),n("p",[e._v("I made this mistake myself in the design of the Tcl scripting language.\nTcl contains an unset command that can be used to remove a variable. I")]),e._v(" "),n("p",[e._v("defined unset so that it throws an error if the variable doesn’t exist. At the\ntime I thought that it must be a bug if someone tries to delete a variable\nthat doesn’t exist, so Tcl should report it. However, one of the most\ncommon uses of unset is to clean up temporary state created by some")]),e._v(" "),n("p",[e._v("previous operation. It’s often hard to predict exactly what state was\ncreated, particularly if the operation aborted partway through. Thus, the")]),e._v(" "),n("p",[e._v("simplest thing is to delete all of the variables that might possibly have\nbeen created. The definition of unset makes this awkward: developers end")]),e._v(" "),n("p",[e._v("up enclosing calls to unset in catch statements to catch and ignore errors\nthrown by unset. In retrospect, the definition of the unset command is one")]),e._v(" "),n("p",[e._v("of the biggest mistakes I made in the design of Tcl.")]),e._v(" "),n("p",[e._v("It’s tempting to use exceptions to avoid dealing with difficult\nsituations: rather than figuring out a clean way to handle it, just throw an\nexception and punt the problem to the caller. Some might argue that this\napproach empowers callers, since it allows each caller to handle the\nexception in a different way. However, if you are having trouble figuring\nout what to do for the particular situation, there’s a good chance that the\ncaller won’t know what to do either. Generating an exception in a situation\nlike this just passes the problem to someone else and adds to the system’s\ncomplexity.")]),e._v(" "),n("p",[e._v("The exceptions thrown by a class are part of its interface; classes with\nlots of exceptions have complex interfaces, and they are shallower than\nclasses with fewer exceptions. An exception is a particularly complex\nelement of an interface. It can propagate up through several stack levels\nbefore being caught, so it affects not just the method’s caller, but\npotentially also higher-level callers (and their interfaces).")]),e._v(" "),n("p",[e._v("Throwing exceptions is easy; handling them is hard. Thus, the\ncomplexity of exceptions comes from the exception handling code. The\nbest way to reduce the complexity damage caused by exception handling is\nto reduce the number of places where exceptions have to be handled.\nThe rest of this chapter will discuss four techniques for reducing the\nnumber of exception handlers.")]),e._v(" "),n("h2",{attrs:{id:"_10-3-dene-errors-out-of-existence"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-3-dene-errors-out-of-existence"}},[e._v("#")]),e._v(" 10.3  Dene errors out of existence")]),e._v(" "),n("p",[e._v("The best way to eliminate exception handling complexity is to define your\nAPIs so that there are no exceptions to handle: define errors out of\nexistence. This may seem sacrilegious, but it is very effective in practice.\nConsider the Tcl unset command discussed above. Rather than throwing an")]),e._v(" "),n("p",[e._v("error when unset is asked to delete an unknown variable, it should have\nsimply returned without doing anything. I should have changed the")]),e._v(" "),n("p",[e._v("definition of unset slightly: rather than deleting a variable, unset should")]),e._v(" "),n("p",[e._v("ensure that a variable no longer exists. With the first definition, unset\ncan’t do its job if the variable doesn’t exist, so generating an exception\nmakes sense. With the second definition, it is perfectly natural for unset to")]),e._v(" "),n("p",[e._v("be invoked with the name of a variable that doesn’t exist. In this case, its\nwork is already done, so it can simply return. There is no longer an error\ncase to report.")]),e._v(" "),n("h2",{attrs:{id:"_10-4-example-le-deletion-in-windows"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-4-example-le-deletion-in-windows"}},[e._v("#")]),e._v(" 10.4  Example: le deletion in Windows")]),e._v(" "),n("p",[e._v("File deletion provides another example of how errors can be defined away.\nThe Windows operating system does not permit a file to be deleted if it is\nopen in a process. This is a continual source of frustration for developers\nand users. In order to delete a file that is in use, the user must search\nthrough the system to find the process that has the file open, and then kill\nthat process. Sometimes users give up and reboot their system, just so they\ncan delete a file.")]),e._v(" "),n("p",[e._v("The Unix operating system defines file deletion more elegantly. In\nUnix, if a file is open when it is deleted, Unix does not delete the file\nimmediately. Instead, it marks the file for deletion, then the delete\noperation returns successfully. The file name has been removed from its\ndirectory, so no other processes can open the old file and a new file with\nthe same name can be created, but the existing file data persists. Processes\nthat already have the file open can continue to read it and write it\nnormally. Once the file has been closed by all of the accessing processes,\nits data is freed.")]),e._v(" "),n("p",[e._v("The Unix approach defines away two different kinds of errors. First,\nthe delete operation no longer returns an error if the file is currently in\nuse; the delete succeeds, and the file will eventually be deleted. Second,\ndeleting a file that’s in use does not create exceptions for the processes\nusing the file. One possible approach to this problem would have been to\ndelete the file immediately and mark all of the opens of the file to disable\nthem; any attempts by other processes to read or write the deleted file\nwould fail. However, this approach would create new errors for those")]),e._v(" "),n("p",[e._v("processes to handle. Instead, Unix allows them to keep accessing the file\nnormally; delaying the file deletion defines errors out of existence.")]),e._v(" "),n("p",[e._v("It may seem strange that Unix allows a process to continue to read and\nwrite a doomed file, but I have never encountered a situation where this\ncaused significant problems. The Unix definition of file deletion is much\nsimpler to work with, both for developers and users, than the Windows\ndefinition.")]),e._v(" "),n("h2",{attrs:{id:"_10-5-example-java-substring-method"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-5-example-java-substring-method"}},[e._v("#")]),e._v(" 10.5  Example: Java substring method")]),e._v(" "),n("p",[e._v("As a final example, consider the Java String class and its substring")]),e._v(" "),n("p",[e._v("method. Given two indexes into a string, substring returns the substring\nstarting at the character given by the first index and ending with the\ncharacter just before the second index. However, if either index is outside\nthe range of the string, then substring throws IndexOutOfBoundsException.")]),e._v(" "),n("p",[e._v("This exception is unnecessary and complicates the use of this method. I\noften find myself in a situation where one or both of the indices may be\noutside the range of the string, and I would like to extract all of the\ncharacters in the string that overlap the specified range. Unfortunately, this\nrequires me to check each of the indices and round them up to zero or\ndown to the end of the string; a one-line method call now becomes 5–10\nlines of code.")]),e._v(" "),n("p",[e._v("The Java substring method would be easier to use if it performed this\nadjustment automatically, so that it implemented the following API:\n“returns the characters of the string (if any) with index greater than or\nequal to beginIndex and less than endIndex.” This is a simple and natural")]),e._v(" "),n("p",[e._v("API, and it defines the IndexOutOfBoundsException exception out of\nexistence. The method’s behavior is now well-defined even if one or both\nof the indexes are negative, or if beginIndex is greater than endIndex. This")]),e._v(" "),n("p",[e._v("approach simplifies the API for the method while increasing its\nfunctionality, so it makes the method deeper. Many other languages have\ntaken the error-free approach; for example, Python returns an empty result\nfor out-of-range list slices.")]),e._v(" "),n("p",[e._v("When I argue for defining errors out of existence, people sometimes\ncounter that throwing errors will catch bugs; if errors are defined out of")]),e._v(" "),n("p",[e._v("existence, won’t that result in buggier software? Perhaps this is why the\nJava developers decided that substring should throw exceptions. The")]),e._v(" "),n("p",[e._v("error-ful approach may catch some bugs, but it also increases complexity,\nwhich results in other bugs. In the error-ful approach, developers must\nwrite additional code to avoid or ignore the errors, and this increases the\nlikelihood of bugs; or, they may forget to write the additional code, in\nwhich case unexpected errors may be thrown at runtime. In contrast,\ndefining errors out of existence simplifies APIs and it reduces the amount\nof code that must be written.")]),e._v(" "),n("div",{staticClass:"language- extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[e._v("Overall, the best way to reduce bugs is to make software simpler.\n")])])]),n("h2",{attrs:{id:"_10-6-mask-exceptions"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-6-mask-exceptions"}},[e._v("#")]),e._v(" 10.6  Mask exceptions")]),e._v(" "),n("p",[e._v("The second technique for reducing the number of places where exceptions\nmust be handled is exception masking. With this approach, an exceptional\ncondition is detected and handled at a low level in the system, so that\nhigher levels of software need not be aware of the condition. Exception\nmasking is particularly common in distributed systems. For instance, in a\nnetwork transport protocol such as TCP, packets can be dropped for\nvarious reasons such as corruption and congestion. TCP masks packet loss\nby resending lost packets within its implementation, so all data eventually\ngets through and clients are unaware of the dropped packets.")]),e._v(" "),n("p",[e._v("A more controversial example of masking occurs in the NFS network\nfile system. If an NFS file server crashes or fails to respond for any\nreason, clients reissue their requests to the server over and over again until\nthe problem is eventually resolved. The low-level file system code on the\nclient does not report any exceptions to the invoking application. The\noperation in progress (and hence the application) just hangs until the\noperation can complete successfully. If the hang lasts more than a short\ntime, the NFS client prints messages on the user’s console of the form\n“NFS server xyzzy not responding still trying.”")]),e._v(" "),n("p",[e._v("NFS users often complain about the fact that their applications hang\nwhile waiting for an NFS server to resume normal operation. Many people\nhave suggested that NFS should abort operations with an exception rather\nthan hanging. However, reporting exceptions would make things worse, not")]),e._v(" "),n("p",[e._v("better. There’s not much an application can do if it loses access to its files.\nOne possibility would be for the application to retry the file operation, but\nthis would still hang the application, and it’s easier to perform the retry in\none place in the NFS layer, rather than at every file system call in every\napplication (a compiler shouldn’t have to worry about this!). The other\nalternative is for applications to abort and return errors to their callers. It’s\nunlikely that the callers would know what to do either, so they would abort\nas well, resulting in a collapse of the user’s working environment. Users\nstill wouldn’t be able to get any work done while the file server was down,\nand they would have to restart all of their applications once the file server\ncame back to life.")]),e._v(" "),n("p",[e._v("Thus, the best alternative is for NFS to mask the errors and hang\napplications. With this approach, applications don’t need any code to deal\nwith server problems, and they can resume seamlessly once the server\ncomes back to life. If users get tired of waiting, they can always abort\napplications manually.")]),e._v(" "),n("p",[e._v("Exception masking doesn’t work in all situations, but it is a powerful\ntool in the situations where it works. It results in deeper classes, since it\nreduces the class’s interface (fewer exceptions for users to be aware of)\nand adds functionality in the form of the code that masks the exception.\nException masking is an example of pulling complexity downward.")]),e._v(" "),n("h2",{attrs:{id:"_10-7-exception-aggregation"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-7-exception-aggregation"}},[e._v("#")]),e._v(" 10.7  Exception aggregation")]),e._v(" "),n("p",[e._v("The third technique for reducing complexity related to exceptions is\nexception aggregation. The idea behind exception aggregation is to handle\nmany exceptions with a single piece of code; rather than writing distinct\nhandlers for many individual exceptions, handle them all in one place with\na single handler.")]),e._v(" "),n("p",[e._v("Consider how to handle missing parameters in a Web server. A Web\nserver implements a collection of URLs. When the server receives an\nincoming URL, it dispatches to a URL-specific service method to process\nthat URL and generate a response. The URL contains various parameters\nthat are used to generate the response. Each service method will call a\nlower-level method (let’s call it getParameter) to extract the parameters")]),e._v(" "),n("p",[e._v("that it needs from the URL. If the URL does not contain the desired\nparameter, getParameter throws an exception.")]),e._v(" "),n("p",[e._v("When students in a software design class implemented such a server,\nmany of them wrapped each distinct call to getParameter in a separate\nexception handler to catch NoSuchParameter exceptions, as in Figure 10.1.")]),e._v(" "),n("p",[e._v("This resulted in a large number of handlers, all of which did essentially the\nsame thing (generate an error response).")]),e._v(" "),n("p",[e._v("Figure 10.1: The code at the top dispatches to one of several methods in a Web server, each of\nwhich handles a particular URL. Each of those methods (bottom) uses parameters from the\nincoming HTTP request. In this figure, there is a separate exception handler for each call to\ngetParameter; this results in duplicated code.")]),e._v(" "),n("p",[e._v("A better approach is to aggregate the exceptions. Instead of catching\nthe exceptions in the individual service methods, let them propagate up to\nthe top-level dispatch method for the Web server, as in Figure 10.2. A\nsingle handler in this method can catch all of the exceptions and generate\nan appropriate error response for missing parameters.")]),e._v(" "),n("p",[e._v("The aggregation approach can be taken even further in the Web\nexample. There are many other errors besides missing parameters that can\noccur while processing a Web page; for example, a parameter might not\nhave the right syntax (the service method expected an integer, but the")]),e._v(" "),n("p",[e._v("value was “xyz”), or the user might not have permission for the requested\noperation. In each case, the error should result in an error response; the\nerrors differ only in the error message to include in the response\n(“parameter 'quantity' not present in URL” or “bad value 'xyz' for")]),e._v(" "),n("p",[e._v("'quantity' parameter; must be positive integer”). Thus, all conditions\nresulting in an error response can be handled with a single top-level\nexception handler. The error message can be generated at the time the\nexception is thrown and included as a variable in the exception record; for\nexample, getParameter will generate the “parameter 'quantity' not")]),e._v(" "),n("p",[e._v("present in URL” message. The top-level handler extracts the message from\nthe exception and incorporates it into the error response.")]),e._v(" "),n("p",[e._v("Figure 10.2: This code is functionally equivalent to Figure 10.1, but exception handling has been\naggregated: a single exception handler in the dispatcher catches all of the NoSuchParameter\nexceptions from all of the URL-specific methods.")]),e._v(" "),n("p",[e._v("The aggregation described in the preceding paragraph has good\nproperties from the standpoint of encapsulation and information hiding.\nThe top-level exception handler encapsulates knowledge about how to\ngenerate error responses, but it knows nothing about specific errors; it just\nuses the error message provided in the exception. The getParameter\nmethod encapsulates knowledge about how to extract a parameter from a\nURL, and it also knows how to describe extraction errors in a human-\nreadable form. These two pieces of information are closely related, so it\nmakes sense for them to be in the same place. However, getParameter")]),e._v(" "),n("p",[e._v("knows nothing about the syntax of an HTTP error response. As new")]),e._v(" "),n("p",[e._v("functionality is added to the Web server, new methods like getParameter")]),e._v(" "),n("p",[e._v("may be created with their own errors. If the new methods throw exceptions\nin the same way as getParameter (by generating exceptions that inherit\nfrom the same superclass and including an error message in each\nexception), they can plug into the existing system with no other changes:\nthe top-level handler will automatically generate error responses for them.")]),e._v(" "),n("p",[e._v("This example illustrates a generally-useful design pattern for exception\nhandling. If a system processes a series of requests, it’s useful to define an\nexception that aborts the current request, cleans up the system’s state, and\ncontinues with the next request. The exception is caught in a single place\nnear the top of the system’s request-handling loop. This exception can be\nthrown at any point in the processing of a request to abort the request;\ndifferent subclasses of the exception can be defined for different\nconditions. Exceptions of this type should be clearly distinguished from\nexceptions that are fatal to the entire system.")]),e._v(" "),n("p",[e._v("Exception aggregation works best if an exception propagates several\nlevels up the stack before it is handled; this allows more exceptions from\nmore methods to be handled in the same place. This is the opposite of\nexception masking: masking usually works best if an exception is handled\nin a low-level method. For masking, the low-level method is typically a\nlibrary method used by many other methods, so allowing the exception to\npropagate would increase the number of places where it is handled.\nMasking and aggregation are similar in that both approaches position an\nexception handler where it can catch the most exceptions, eliminating\nmany handlers that would otherwise need to be created.")]),e._v(" "),n("p",[e._v("Another example of exception aggregation occurs in the RAMCloud\nstorage system for crash recovery. A RAMCloud system consists of a\ncollection of storage servers that keep multiple copies of each object, so\nthe system can recover from a variety of failures. For example, if a server\ncrashes and loses all of its data, RAMCloud reconstructs the lost data\nusing copies stored on other servers. Errors can also happen on a smaller\nscale; for example, a server may discover that an individual object is\ncorrupted.")]),e._v(" "),n("p",[e._v("RAMCloud does not have separate recovery mechanisms for each\ndifferent kind of error. Instead, RAMCloud “promotes” many smaller")]),e._v(" "),n("p",[e._v("errors into larger ones. RAMCloud could, in principle, handle a corrupted\nobject by restoring that one object from a backup copy. However, it doesn’t\ndo this. Instead, if it discovers a corrupted object it crashes the server\ncontaining the object. RAMCloud uses this approach because crash\nrecovery is quite complex and this approach minimized the number of\ndifferent recovery mechanisms that had to be created. Creating a recovery\nmechanism for crashed servers was unavoidable, so RAMCloud uses the\nsame mechanism for other kinds of recovery as well. This reduced the\namount of code that had to be written, and it also meant that server crash\nrecovery gets invoked more often. As a result, bugs in recovery are more\nlikely to be discovered and fixed.")]),e._v(" "),n("p",[e._v("One disadvantage of promoting a corrupted object into a server crash\nis that it increases the cost of recovery considerably. This is not a problem\nin RAMCloud, since object corruption is quite rare. However, error\npromotion may not make sense for errors that happen frequently. As one\nexample, it would not be practical to crash a server anytime one of its\nnetwork packets is lost.")]),e._v(" "),n("p",[e._v("One way of thinking about exception aggregation is that it replaces\nseveral special-purpose mechanisms, each tailored for a particular\nsituation, with a single general-purpose mechanism that can handle\nmultiple situations. This provides another illustration of the benefits of\ngeneral-purpose mechanisms.")]),e._v(" "),n("h2",{attrs:{id:"_10-8-just-crash"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-8-just-crash"}},[e._v("#")]),e._v(" 10.8  Just crash?")]),e._v(" "),n("p",[e._v("The fourth technique for reducing complexity related to exception\nhandling is to crash the application. In most applications there will be\ncertain errors that it’s not worth trying to handle. Typically, these errors\nare difficult or impossible to handle and don’t occur very often. The\nsimplest thing to do in response to these errors is to print diagnostic\ninformation and then abort the application.")]),e._v(" "),n("p",[e._v("One example is “out of memory” errors that occur during storage\nallocation. Consider the malloc function in C, which returns NULL if it")]),e._v(" "),n("p",[e._v("cannot allocate the desired block of memory. This is an unfortunate\nbehavior, because it assumes that every single caller of malloc will check")]),e._v(" "),n("p",[e._v("the return value and take appropriate action if there is no memory.\nApplications contain numerous calls to malloc, so checking the result after")]),e._v(" "),n("p",[e._v("each call would add significant complexity. If a programmer forgets the\ncheck (which is fairly likely), then the application will dereference a null\npointer if memory runs out, resulting in a crash that camouflages the real\nproblem.")]),e._v(" "),n("p",[e._v("Furthermore, there isn’t much an application can do when it discovers\nthat memory is exhausted. In principle the application could look for\nunneeded memory to free, but if the application had unneeded memory it\ncould already have freed it, which would have prevented the out-of-\nmemory error in the first place. Today’s systems have so much memory\nthat memory almost never runs out; if it does, it usually indicates a bug in\nthe application. Thus, it rarely make sense to try to handle out-of-memory\nerrors; this creates too much complexity for too little benefit.")]),e._v(" "),n("p",[e._v("A better approach is to define a new method ckalloc, which calls\nmalloc, checks the result, and aborts the application with an error message")]),e._v(" "),n("p",[e._v("if memory is exhausted. The application never invokes malloc directly; it\nalways invokes ckalloc.")]),e._v(" "),n("p",[e._v("In newer languages such as C++ and Java, the new operator throws an\nexception if memory is exhausted. There’s not much point in catching this\nexception, since there’s a good chance that the exception handler will also\ntry to allocate memory, which will also fail. Dynamically allocated\nmemory is such a fundamental element of any modern application that it\ndoesn’t make sense for the application to continue if memory is exhausted;\nit’s better to crash as soon as the error is detected.")]),e._v(" "),n("p",[e._v("There are many other examples of errors where crashing the\napplication makes sense. For most programs, if an I/O error occurs while\nreading or writing an open file (such as a disk hard error), or if a network\nsocket cannot be opened, there’s not much the application can do to\nrecover, so aborting with a clear error message is a sensible approach.\nThese errors are infrequent, so they are unlikely to affect the overall\nusability of the application. Aborting with an error message is also\nappropriate if an application encounters an internal error such as an")]),e._v(" "),n("p",[e._v("inconsistent data structure. Conditions like this probably indicate bugs in\nthe program.")]),e._v(" "),n("p",[e._v("Whether or not it is acceptable to crash on a particular error depends\non the application. For a replicated storage system, it isn’t appropriate to\nabort on an I/O error. Instead, the system must use replicated data to\nrecover any information that was lost. The recovery mechanisms will add\nconsiderable complexity to the program, but recovering lost data is an\nessential part of the value the system provides to its users.")]),e._v(" "),n("h2",{attrs:{id:"_10-9-design-special-cases-out-of-existence"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-9-design-special-cases-out-of-existence"}},[e._v("#")]),e._v(" 10.9  Design special cases out of existence")]),e._v(" "),n("p",[e._v("For the same reason that it makes sense to define errors out of existence, it\nalso makes sense to define other special cases out of existence. Special\ncases can result in code that is riddled with if statements, which make the\ncode hard to understand and lead to bugs. Thus, special cases should be\neliminated wherever possible. The best way to do this is by designing the\nnormal case in a way that automatically handles the special cases without\nany extra code.")]),e._v(" "),n("p",[e._v("In the text editor project described in Chapter 6, students had to\nimplement a mechanism for selecting text and copying or deleting the\nselection. Most students introduced a state variable in their selection\nimplementation to indicate whether or not the selection exists. They\nprobably chose this approach because there are times when no selection is\nvisible on the screen, so it seemed natural to represent this notion in the\nimplementation. However, this approach resulted in numerous checks to\ndetect the “no selection” condition and handle it specially.")]),e._v(" "),n("p",[e._v("The selection handling code can be simplified by eliminating the “no\nselection” special case, so that the selection always exists. When there is\nno selection visible on the screen, it can be represented internally with an\nempty selection, whose starting and ending positions are the same. With\nthis approach, the selection management code can be written without any\nchecks for “no selection”. When copying the selection, if the selection is\nempty then 0 bytes will be inserted at the new location (if implemented\ncorrectly, there will be no need to check for 0 bytes as a special case).\nSimilarly, it should be possible to design the code for deleting the")]),e._v(" "),n("p",[e._v("selection so that the empty case is handled without any special-case\nchecks. Consider a selection all on a single line. To delete the selection,\nextract the portion of the line preceding the selection and concatenate it\nwith the portion of the line following the selection to form the new line. If\nthe selection is empty, this approach will regenerate the original line.")]),e._v(" "),n("p",[e._v("This example also illustrates the “different layer, different abstraction”\nidea from Chapter 7. The notion of “no selection” makes sense in terms of\nhow the user thinks about the application’s interface, but that doesn’t mean\nit has to be represented explicitly inside the application. Having a\nselection that always exists, but is sometimes empty and thus invisible,\nresults in a simpler implementation.")]),e._v(" "),n("h2",{attrs:{id:"_10-10-taking-it-too-far"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-10-taking-it-too-far"}},[e._v("#")]),e._v(" 10.10  Taking it too far")]),e._v(" "),n("p",[e._v("Defining away exceptions, or masking them inside a module, only makes\nsense if the exception information isn’t needed outside the module. This\nwas true for the examples in this chapter, such the Tcl unset command and\nthe Java substring method; in the rare situations where a caller cares")]),e._v(" "),n("p",[e._v("about the special cases detected by the exceptions, there are other ways for\nit to get this information.")]),e._v(" "),n("p",[e._v("However, it is possible to take this idea too far. In a module for\nnetwork communication, a student team masked all network exceptions: if\na network error occurred, the module caught it, discarded it, and continued\nas if there were no problem. This meant that applications using the module\nhad no way to find out if messages were lost or a peer server failed;\nwithout this information, it was impossible to build robust applications. In\nthis case, it is essential for the module to expose the exceptions, even\nthough they add complexity to the module’s interface.")]),e._v(" "),n("p",[e._v("With exceptions, as with many other areas in software design, you\nmust determine what is important and what is not important. Things that\nare not important should be hidden, and the more of them the better. But\nwhen something is important, it must be exposed.")]),e._v(" "),n("h2",{attrs:{id:"_10-11-conclusion"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#_10-11-conclusion"}},[e._v("#")]),e._v(" 10.11  Conclusion")]),e._v(" "),n("p",[e._v("Special cases of any form make code harder to understand and increase the\nlikelihood of bugs. This chapter focused on exceptions, which are one of\nthe most significant sources of special-case code, and discussed how to\nreduce the number of places where exceptions must be handled. The best\nway to do this is by redefining semantics to eliminate error conditions. For\nexceptions that can’t be defined away, you should look for opportunities to\nmask them at a low level, so their impact is limited, or aggregate several\nspecial-case handlers into a single more generic handler. Together, these\ntechniques can have a significant impact on overall system complexity.")]),e._v(" "),n("p",[e._v("(^1) Ding Yuan et. al., “Simple Testing Can Prevent Most Critical Failures: An Analysis of\nProduction Failures in Distributed Data-Intensive Systems,” 2014 USENIX Conference on\nOperating System Design and Implementation.")])])}),[],!1,null,null,null);t.default=o.exports}}]);