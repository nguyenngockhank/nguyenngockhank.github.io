(window.webpackJsonp=window.webpackJsonp||[]).push([[498],{1754:function(e,t,r){"use strict";r.r(t);var a=r(7),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[r("h1",{attrs:{id:"concurrent-programming"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#concurrent-programming"}},[e._v("#")]),e._v(" Concurrent Programming")]),e._v(" "),r("h2",{attrs:{id:"increasing-concurrency"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#increasing-concurrency"}},[e._v("#")]),e._v(" Increasing Concurrency")]),e._v(" "),r("p",[r("strong",[e._v("Thread Pool")]),e._v(": A thread pool is a collection of pre-initialized threads that are ready to perform tasks. Instead of creating a new thread for each task, a thread pool allows for the reuse of threads, reducing the overhead of thread creation. This pattern is particularly useful when dealing with a large number of short-lived tasks.")]),e._v(" "),r("p",[r("strong",[e._v("Asynchronous Programming")]),e._v(": Asynchronous programming allows tasks to be executed concurrently without blocking the main thread. By utilizing callbacks, promises, or async/await syntax, tasks can be initiated and executed in the background while the main thread continues with other operations. This pattern is especially effective when dealing with I/O-bound operations, such as network requests or file operations.")]),e._v(" "),r("p",[r("strong",[e._v("Parallel Processing")]),e._v(": Parallel processing involves dividing a task into smaller subtasks that can be executed simultaneously on multiple processing units. This pattern is commonly used in scenarios where a single task can be divided into independent parts that can be processed concurrently. Parallel processing can be achieved using multi-threading or distributed computing frameworks.")]),e._v(" "),r("p",[r("strong",[e._v("Event-driven Architecture")]),e._v(": In an event-driven architecture, components of a system communicate through events. When an event occurs, it triggers the execution of associated event handlers. This pattern allows for loose coupling between components and enables concurrent execution of tasks based on events. Event-driven architectures are commonly used in systems that require high scalability and responsiveness.")]),e._v(" "),r("p",[r("strong",[e._v("Caching")]),e._v(": Caching is a technique that stores frequently accessed data in memory to reduce the need for expensive computations or I/O operations. By caching data, multiple requests can be served concurrently without the need to access the underlying data source. Caching can significantly improve the performance and concurrency of a system, especially in scenarios where data access is a bottleneck.")]),e._v(" "),r("h2",{attrs:{id:"avoid-deadlocks"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#avoid-deadlocks"}},[e._v("#")]),e._v(" Avoid Deadlocks")]),e._v(" "),r("p",[r("strong",[e._v("Resource Ordering")]),e._v(":  establish a strict ordering of resources. By ensuring that all threads or processes request resources in the same order, the possibility of circular wait conditions, which can lead to deadlocks, is eliminated. This technique requires careful analysis and planning to determine the appropriate resource ordering.")]),e._v(" "),r("p",[r("strong",[e._v("Resource Allocation")]),e._v(": can detect and prevent deadlocks. For example, the Banker's algorithm is a well-known algorithm that can be used to allocate resources in a way that avoids deadlocks. It works by considering the available resources, the maximum resources each process can request, and the resources currently allocated to each process.")]),e._v(" "),r("p",[r("strong",[e._v("Locking and Synchronization")]),e._v(": Proper use of locks and synchronization mechanisms can help prevent deadlocks. By ensuring that resources are properly locked and released in a consistent manner, the chances of deadlocks occurring can be reduced. Techniques such as "),r("strong",[e._v("lock ordering")]),e._v(" and "),r("strong",[e._v("lock timeouts")]),e._v(" can be used to further enhance deadlock prevention.")]),e._v(" "),r("p",[r("strong",[e._v("Avoidance of Circular Wait")]),e._v(': Circular wait is a condition where each process is waiting for a resource held by another process in a circular chain. To avoid circular wait, a technique called "'),r("strong",[e._v("resource hierarchy")]),e._v('" can be used. In this technique, resources are assigned a unique identifier, and processes are required to acquire resources in increasing order of their identifiers. This ensures that circular wait conditions cannot occur.')]),e._v(" "),r("p",[r("strong",[e._v("Resource Preemption")]),e._v(": Preemptive resource allocation is a technique where a resource can be forcibly taken away from a process if it is needed by another process. By preempting resources, the possibility of deadlocks can be reduced. However, this technique should be used with caution, as it can introduce its own set of challenges and complexities.")]),e._v(" "),r("p",[r("strong",[e._v("Proper Error Handling")]),e._v(": Proper error handling and recovery mechanisms can also help prevent deadlocks. By detecting and handling errors related to resource allocation and deallocation, the system can avoid situations that can lead to deadlocks.")]),e._v(" "),r("h2",{attrs:{id:"problems-in-concurrency"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#problems-in-concurrency"}},[e._v("#")]),e._v(" Problems in Concurrency")]),e._v(" "),r("p",[r("strong",[e._v("Race Conditions")]),e._v(": A race condition occurs when multiple threads or processes access shared resources simultaneously, leading to unpredictable and incorrect results. For example, if two threads try to update the same variable concurrently, the final value may depend on the order of execution, leading to inconsistent or incorrect results.")]),e._v(" "),r("p",[r("strong",[e._v("Deadlocks")]),e._v(": A deadlock is a situation where two or more threads are blocked indefinitely, waiting for each other to release resources. Deadlocks can occur when multiple threads acquire resources in different orders, creating a circular dependency. This can result in a system freeze or unresponsiveness.")]),e._v(" "),r("p",[r("strong",[e._v("Starvation")]),e._v(": Starvation happens when a thread is unable to access a shared resource indefinitely due to resource contention. This can occur if a high-priority thread continuously acquires a resource, preventing lower-priority threads from accessing it. Starvation can lead to reduced system performance and fairness.")]),e._v(" "),r("p",[r("strong",[e._v("Thread Synchronization")]),e._v(": Synchronizing threads is essential to ensure data consistency and prevent race conditions. However, improper synchronization can introduce problems such as deadlocks or performance bottlenecks. It requires careful design and implementation to achieve the right balance between synchronization and performance.")]),e._v(" "),r("p",[r("strong",[e._v("Performance Bottlenecks")]),e._v(": Concurrency can introduce performance bottlenecks due to increased overhead in managing multiple threads or processes. Excessive context switching, contention for shared resources, or inefficient synchronization can degrade system performance.")]),e._v(" "),r("p",[r("strong",[e._v("Ordering and Visibility")]),e._v(": In concurrent systems, the order of execution and visibility of shared data can be challenging to manage. Inconsistent ordering or visibility can lead to unexpected behavior and bugs. Proper synchronization mechanisms, such as locks or atomic operations, are required to ensure correct ordering and visibility.")]),e._v(" "),r("p",[r("strong",[e._v("Testing and Debugging")]),e._v(": Concurrency-related bugs can be difficult to reproduce and debug due to their non-deterministic nature. Testing and debugging concurrent systems require specialized techniques and tools to identify and fix issues effectively.")]),e._v(" "),r("h2",{attrs:{id:"terms"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#terms"}},[e._v("#")]),e._v(" Terms")]),e._v(" "),r("h3",{attrs:{id:"critical-section"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#critical-section"}},[e._v("#")]),e._v(" Critical section")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("Critical section")]),e._v(" "),r("p",[e._v("Critical section là một đoạn code chỉ được thực thi duy nhất bởi một thread nào đó tại một thời điểm. Nếu có nhiều hơn một thread thực thi đoạn code này sẽ xảy ra lỗi.")])]),e._v(" "),r("p",[e._v("Ví dụ đó có thể là đoạn code truy cập tới các shared resources như file, data, global variables,…")]),e._v(" "),r("h3",{attrs:{id:"race-condition"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#race-condition"}},[e._v("#")]),e._v(" Race condition")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("Race condition")]),e._v(" "),r("p",[e._v("Race condition: là khi nhiều threads access vào một shared source mà không đảm bảo rằng thread này kết thúc thực thi trên dữ liệu trước khi thread kia truy cập dữ liệu. Nghĩa là các threads đồng thời cùng đọc và cùng ghi trên dữ liệu. Có thể hiểu race condition là trường hợp sẽ xảy ra nếu không quản lý tốt critical section.")])]),e._v(" "),r("h3",{attrs:{id:"deadlock"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#deadlock"}},[e._v("#")]),e._v(" Deadlock")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("Deadlock")]),e._v(" "),r("p",[e._v("là hiện tượng hai hay nhiều tác vụ phải chờ đợi lẫn nhau để hoàn thành.")])]),e._v(" "),r("h3",{attrs:{id:"thread-safe"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#thread-safe"}},[e._v("#")]),e._v(" Thread safe")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("Thread safe")]),e._v(" "),r("p",[e._v("một code được gọi là thread safe code khi trong môi trường multi-threading, nó được thực thi mà không xảy ra bất cứ lỗi nào.")])]),e._v(" "),r("h3",{attrs:{id:"atomicity"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#atomicity"}},[e._v("#")]),e._v(" Atomicity")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("Atomicity")]),e._v(" "),r("p",[e._v("một tác vụ hoặc một công việc cụ thể được cho là atomic khi nó không thể bị gián đoạn. Có nghĩa là nó được đảm bảo sẽ được hoàn thành, không có trường hợp trả ra một trạng thái không hợp lệ nào đó (lỗi). Đây cũng là một ví dụ của thread safe.")])]),e._v(" "),r("h2",{attrs:{id:"lamport-s-bakery-algorithm"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#lamport-s-bakery-algorithm"}},[e._v("#")]),e._v(" Lamport's bakery algorithm")]),e._v(" "),r("div",{staticClass:"custom-block tip"},[r("p",{staticClass:"custom-block-title"},[e._v("Lamport's bakery algorithm")]),e._v(" "),r("p",[e._v("Lamport's bakery algorithm is a computer algorithm devised by computer scientist Leslie Lamport, as part of his long study of the formal correctness of concurrent systems, which is intended to improve the safety in the usage of shared resources among multiple threads by means of mutual exclusion.")])]),e._v(" "),r("h2",{attrs:{id:"references"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#references"}},[e._v("#")]),e._v(" References")]),e._v(" "),r("ul",[r("li",[r("a",{attrs:{href:"https://medium.com/@lvhan/concurrent-programming-v%C3%A0-gcd-part-1-c701cf180de6",target:"_blank",rel:"noopener noreferrer"}},[e._v("Concurrent Programming và GCD (Part 1)"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://viblo.asia/p/concurrency-programming-guide-63vKjpYdl2R",target:"_blank",rel:"noopener noreferrer"}},[e._v("Concurrency Programming Guide"),r("OutboundLink")],1)]),e._v(" "),r("li",[r("a",{attrs:{href:"https://viblo.asia/p/parallel-processing-concurrency-va-async-programming-OeVKBdj0lkW",target:"_blank",rel:"noopener noreferrer"}},[e._v("Parallel Processing, Concurrency, và Async Programming"),r("OutboundLink")],1)])]),e._v(" "),r("p",[r("a",{attrs:{href:"https://en.wikipedia.org/wiki/Concurrency_pattern",target:"_blank",rel:"noopener noreferrer"}},[e._v("Concurrency Patterns"),r("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=n.exports}}]);