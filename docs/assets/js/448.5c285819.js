(window.webpackJsonp=window.webpackJsonp||[]).push([[448],{1693:function(e,t,o){"use strict";o.r(t);var s=o(7),n=Object(s.a)({},(function(){var e=this,t=e.$createElement,o=e._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"_1-introduction"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-introduction"}},[e._v("#")]),e._v(" 1. Introduction")]),e._v(" "),o("h2",{attrs:{id:"it-s-all-about-complexity"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#it-s-all-about-complexity"}},[e._v("#")]),e._v(" (It’s All About Complexity)")]),e._v(" "),o("p",[e._v("Writing computer software is one of the purest creative activities in\nthe history of the human race. Programmers aren’t bound by practical\nlimitations such as the laws of physics; we can create exciting virtual\nworlds with behaviors that could never exist in the real world.\nProgramming doesn’t require great physical skill or coordination, like\nballet or basketball. All programming requires is a creative mind and the\nability to organize your thoughts. If you can visualize a system, you can\nprobably implement it in a computer program.")]),e._v(" "),o("p",[e._v("This means that the greatest limitation in writing software is our\nability to understand the systems we are creating. As a program evolves\nand acquires more features, it becomes complicated, with subtle\ndependencies between its components. Over time, complexity\naccumulates, and it becomes harder and harder for programmers to keep\nall of the relevant factors in their minds as they modify the system. This\nslows down development and leads to bugs, which slow development even\nmore and add to its cost. Complexity increases inevitably over the life of\nany program. The larger the program, and the more people that work on it,\nthe more difficult it is to manage complexity.")]),e._v(" "),o("p",[e._v("Good development tools can help us deal with complexity, and many\ngreat tools have been created over the last several decades. But there is a\nlimit to what we can do with tools alone. If we want to make it easier to\nwrite software, so that we can build more powerful systems more cheaply,\nwe must find ways to make software simpler. Complexity will still\nincrease over time, in spite of our best efforts, but simpler designs allow")]),e._v(" "),o("p",[e._v("us to build larger and more powerful systems before complexity becomes\noverwhelming.")]),e._v(" "),o("p",[e._v("There are two general approaches to fighting complexity, both of\nwhich will be discussed in this book. The first approach is to eliminate\ncomplexity by making code simpler and more obvious. For example,\ncomplexity can be reduced by eliminating special cases or using\nidentifiers in a consistent fashion.")]),e._v(" "),o("p",[e._v("The second approach to complexity is to encapsulate it, so that\nprogrammers can work on a system without being exposed to all of its\ncomplexity at once. This approach is called modular design. In modular\ndesign, a software system is divided up into modules, such as classes in an\nobject-oriented language. The modules are designed to be relatively\nindependent of each other, so that a programmer can work on one module\nwithout having to understand the details of other modules.")]),e._v(" "),o("p",[e._v("Because software is so malleable, software design is a continuous\nprocess that spans the entire lifecycle of a software system; this makes\nsoftware design different from the design of physical systems such as\nbuildings, ships, or bridges. However, software design has not always been\nviewed this way. For much of the history of programming, design was\nconcentrated at the beginning of a project, as it is in other engineering\ndisciplines. The extreme of this approach is called the waterfall model, in\nwhich a project is divided into discrete phases such as requirements\ndefinition, design, coding, testing, and maintenance. In the waterfall\nmodel, each phase completes before the next phase starts; in many cases\ndifferent people are responsible for each phase. The entire system is\ndesigned at once, during the design phase. The design is frozen at the end\nof this phase, and the role of the subsequent phases is to flesh out and\nimplement that design.")]),e._v(" "),o("p",[e._v("Unfortunately, the waterfall model rarely works well for software.\nSoftware systems are intrinsically more complex than physical systems; it\nisn’t possible to visualize the design for a large software system well\nenough to understand all of its implications before building anything. As a\nresult, the initial design will have many problems. The problems do not\nbecome apparent until implementation is well underway. However, the\nwaterfall model is not structured to accommodate major design changes at")]),e._v(" "),o("p",[e._v("this point (for example, the designers may have moved on to other\nprojects). Thus, developers try to patch around the problems without\nchanging the overall design. This results in an explosion of complexity.")]),e._v(" "),o("p",[e._v("Because of these issues, most software development projects today use\nan incremental approach such as agile development, in which the initial\ndesign focuses on a small subset of the overall functionality. This subset is\ndesigned, implemented, and then evaluated. Problems with the original\ndesign are discovered and corrected, then a few more features are\ndesigned, implemented and evaluated. Each iteration exposes problems\nwith the existing design, which are fixed before the next set of features is\ndesigned. By spreading out the design in this way, problems with the initial\ndesign can be fixed while the system is still small; later features benefit\nfrom experience gained during the implementation of earlier features, so\nthey have fewer problems.")]),e._v(" "),o("p",[e._v("The incremental approach works for software because software is\nmalleable enough to allow significant design changes partway through\nimplementation. In contrast, major design changes are much more\nchallenging for physical systems: for example, it would not be practical to\nchange the number of towers supporting a bridge in the middle of\nconstruction.")]),e._v(" "),o("p",[e._v("Incremental development means that software design is never done.\nDesign happens continuously over the life of a system: developers should\nalways be thinking about design issues. Incremental development also\nmeans continuous redesign. The initial design for a system or component\nis almost never the best one; experience inevitably shows better ways to do\nthings. As a software developer, you should always be on the lookout for\nopportunities to improve the design of the system you are working on, and\nyou should plan on spending some fraction of your time on design\nimprovements.")]),e._v(" "),o("p",[e._v("If software developers should always be thinking about design issues,\nand reducing complexity is the most important element of software\ndesign, then software developers should always be thinking about\ncomplexity. This book is about how to use complexity to guide the design\nof software throughout its lifetime.")]),e._v(" "),o("p",[e._v("This book has two overall goals. The first is to describe the nature of\nsoftware complexity: what does “complexity” mean, why does it matter,\nand how can you recognize when a program has unnecessary complexity?\nThe book’s second, and more challenging, goal is to present techniques\nyou can use during the software development process to minimize\ncomplexity. Unfortunately, there isn’t a simple recipe that will guarantee\ngreat software designs. Instead, I will present a collection of higher-level\nconcepts that border on the philosophical, such as “classes should be deep”\nor “define errors out of existence.” These concepts may not immediately\nidentify the best design, but you can use them to compare design\nalternatives and guide your exploration of the design space.")]),e._v(" "),o("h2",{attrs:{id:"_1-1-how-to-use-this-book"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-how-to-use-this-book"}},[e._v("#")]),e._v(" 1.1    How to use this book")]),e._v(" "),o("p",[e._v("Many of the design principles described here are somewhat abstract, so\nthey may be hard to appreciate without looking at actual code. It has been\na challenge to find examples that are small enough to include in the book,\nyet large enough to illustrate problems with real systems (if you encounter\ngood examples, please send them to me). Thus, this book may not be\nsufficient by itself for you to learn how to apply the principles.")]),e._v(" "),o("p",[e._v("The best way to use this book is in conjunction with code reviews.\nWhen you read other people’s code, think about whether it conforms to the\nconcepts discussed here and how that relates to the complexity of the code.\nIt’s easier to see design problems in someone else’s code than your own.\nYou can use the red flags described here to identify problems and suggest\nimprovements. Reviewing code will also expose you to new design\napproaches and programming techniques.")]),e._v(" "),o("p",[e._v("One of the best ways to improve your design skills is to learn to\nrecognize red flags: signs that a piece of code is probably more\ncomplicated than it needs to be. Over the course of this book I will point\nout red flags that suggest problems related to each major design issue; the\nmost important ones are summarized at the back of the book. You can then\nuse these when you are coding: when you see a red flag, stop and look for\nan alternate design that eliminates the problem. When you first try this\napproach, you may have to try several design alternatives before you find\none that eliminates the red flag. Don’t give up easily: the more alternatives")]),e._v(" "),o("p",[e._v("you try before fixing the problem, the more you will learn. Over time, you\nwill find that your code has fewer and fewer red flags, and your designs are\ncleaner and cleaner. Your experience will also show you other red flags\nthat you can use to identify design problems (I’d be happy to hear about\nthese).")]),e._v(" "),o("p",[e._v("When applying the ideas from this book, it’s important to use\nmoderation and discretion. Every rule has its exceptions, and every\nprinciple has its limits. If you take any design idea to its extreme, you will\nprobably end up in a bad place. Beautiful designs reflect a balance\nbetween competing ideas and approaches. Several chapters have sections\ntitled “Taking it too far,” which describe how to recognize when you are\noverdoing a good thing.")]),e._v(" "),o("p",[e._v("Almost all of the examples in this book are in Java or C++, and much\nof the discussion is in terms of designing classes in an object-oriented\nlanguage. However, the ideas apply in other domains as well. Almost all of\nthe ideas related to methods can also be applied to functions in a language\nwithout object-oriented features, such as C. The design ideas also apply to\nmodules other than classes, such as subsystems or network services.")]),e._v(" "),o("p",[e._v("With this background, let’s discuss in more detail what causes\ncomplexity, and how to make software systems simpler.")])])}),[],!1,null,null,null);t.default=n.exports}}]);