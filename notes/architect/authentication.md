---
tags: ["HLD", "Authentication"]
---

# Authentication

::: tip
Authentication is the act of proving an assertion, such as the identity of a computer system user.
:::

<TagLinks />

## Terms

![Terms](https://lh3.googleusercontent.com/pw/ABLVV85fV--d3G0js3T341g0t4kXhCpMLeKC0I2lskPpMHNLnN4UF4YNrdKbvFwvU2qXIUqLc_--AnEUyyRfiKUilUmEnjgeIw9axZZ9twAUhPUa6_KnhX9RPDUwrcppRWGOV6IiotQ9d4IIh44nYHSY-7m4pP4V6GbwCzILjbQKPwXLg8vv5JoabI_j9VXe3n3QfRYGKSryIFVahOD0RDphcWOXOyAcs_Puri9rdf7voHPeRVMdvOl9T5IEiXsbIkq-ADAAuh9PEcpEZWgwb0lgJyXoeXpzcLZGZg0xOTnjLD4IcTpfPv82UKQNwUs8kAskl393B3VOwY5VvJSzdmhhJOrTCH7cofL7wIEla2U_fLmaH_3CGS-UxwVxcsjPzsCeQUWZLPAnwi4-rZGhPw9ltTj-tkcKI3xsxUvNbpEbVBokb60aPNVhKcjsdvsqofTsbaW3619Ct7PdqhyXsS8itJOc0sNnTkDCGB4FFg6FvUJW0aKxGiIZAd3mxjp9o4lolAgxOK4yk1feoe70hM0ACqa86E2UM0T4IxmIC3-0FHimhawHd0EPCY_5ws-noofxq6_Ed2Azqrm5F4-yMQyuyhDDhAq76kyIVqR4zcRGogJ7dznXGXDMBpHZKn7u8oRoQre0XAzEglinruGwDTTZ4afCD4KI_fNz8YcMYYHfTNwa9EDkJrvAnEG16EippOZLjtiU8ucsPbK39owk3UunxDVG7Q0rMgc_XGYCgC7rh5PYDa9RWZepO2OYA6klHXbKxJiGI_av1Xm04oXX8EuQVgs5tGrXyjwUi-gRbZp8naNw5f20_i1LjUvoffFWL46n7oIuxFhHKXh9DFnATBXR2h2SoC_MetSppn5P37qQlHsdflg-bT6J-uj39eaPT9zxec9A0x5TekG2JPtjmVsDBjuvL9WOdtJIVpkt-uc5ZA=w428-h561-s-no-gm)

When you login to a website, your identity needs to be managed. Here is how different solutions work:

- Session - The server stores your identity and gives the browser a session ID cookie. This allows the server to track login state. But cookies don't work well across devices.
- Token - Your identity is encoded into a token sent to the browser. The browser sends this token on future requests for authentication. No server session storage is required. But tokens need encryption/decryption.
- JWT - JSON Web Tokens standardize identity tokens using digital signatures for trust. The signature is contained in the token so no server session is needed.
- SSO - Single Sign On uses a central authentication service. This allows a single login to work across multiple sites.
- OAuth2 - Allows limited access to your data on one site by another site, without giving away passwords.
- QR Code - Encodes a random token into a QR code for mobile login. Scanning the code logs you in without typing a password.

## Signal in Request 

There is always a sign in HTTP request to be used for Authenication

- URL: `/post/create?api_key=my_key`
- Cookie: SESSION_ID=CLIENT_TOKEN
- Authorization Header: `Authorization: my_token`
- Custom Header: `Authorization: my_token`
- Body: `content=...&token=my_token`


## Basic Authentication

::: tip
Basic Authentication is a method for an HTTP user agent (e.g., a web browser) to provide a `username` and `password` when making `a request.` 
:::

```
Authorization: Basic <credentials>
```

- The user’s username and password are combined with a `:` (colon) .
- The resulting string is base64 encoded.

**Pros**
- easy, most of browsers & servers support
- easy to integrate with other methods

**Cons**
- Username/password are easy to be leaked because of embeded in every request
- No feature call logout. Except remove browsing history 
- No friendly UI 


## Session-based Authentication

Sometimes, it was also called `cookie-based` authentication. 

::: tip
Session Authentication is a small file, most likely in JSON format, that stores information about the user, such as a unique ID, time of login and expirations, and so on. It is generated and `stored on the server` so that the server can keep track of the user requests.

The user receives some of these details, especially the ID, as cookies that will be sent with every new request, so that the server can recognize the ID and authorize the user’s requests.
:::

Used for monolith system, small website, PHP websites by default, ...


**Pros**
- Inforamtion hiding. Session Id is randomly generated without user infor
- Small size to transfer
- No need to handle at client too much, because all browsers support cookie by default behaviour
- Fully-controlled session. E.g: time to expire for login, force logout, ...

**Cons**
- take up a lot of storage in Server
- difficult to scale out because by default
	- Should configure Session storage to a global storage, all app instances
	- Or should remain the connection of `session id` and the serving `app instance`
- depends on domain 
- `CSRF` attacking


## Token-based Authentication

::: tip
A `token` is an authorization file that cannot be tampered with. It is generated by the server using a **secret key**, sent to and `stored by the user` in their local storage. Like in the case of cookies, the user sends this token to the server with every new request, so that the server can verify its signature and authorize the requests. 
:::

Used for system `Web API`, `Distributed system`, `micro-services`, system has multi-platform `mobile`, `IoT`, `server`,... or UI / API seperation



## Session-based vs Token-based Authentication

Session-based Auth |  Token-based Auth 
------------------ | ----------------
Server stateful, take up a lot of storage in Server | Server stateless, token has attribute `self-contained` 
SessionId at client has no user information | Token contains user information 
Small size to transfer | Bigger size 
Use only on 1 url domain | Token can be sent to many url domains 
No need to handle at client too much, browsers support cookie by default | More complicated handling at client. E.g Store token, refresh token, attach token to each request, ...
Be careful about `CSRF` | Prevent `CSRF`
Use for browsers | Not only browser-to-server but for server-to-server 
Server is difficult to scale out | Easy to scale out

**Criteria Comparision**

Criteria | Session-based Auth |  Token-based Auth 
-------- | ------------------ | ----------------
Which side stores the authentication details | Server  | Client (Browser)
What Client sends to Server to have their requests authorized | A cookie | Token 
What Server does to authorize users’ requests | Look up sesssionId requested by client on storage |  Decrypting the user’s token and verifying its signature
Kind of attacks the method may suffer | `Man-in-middle`, Cross-site request forgery (`CSRF`) | `Man-in-middle`, `Token steal`, breaches of the secret key
Force logout feature by admin | Fully-controlled session | Implemented by coding, make blocklist token, make server becomes stateful


See more: 
[Session vs Token Based Authentication](https://www.geeksforgeeks.org/session-vs-token-based-authentication/)

## Hash based Message Authentication Code (HMAC)

::: tip
Hash-based message authentication code (or HMAC) is a cryptographic authentication technique that uses a hash function and a secret key.

With HMAC, you can achieve authentication and verify that `data is correct` and authentic with shared secrets
:::

![HMAC](https://media.licdn.com/dms/image/C4D12AQGhsdUJ4h4bNw/article-cover_image-shrink_720_1280/0/1593274127772?e=2147483647&v=beta&t=OI9rOEe6eEFMZ-XiNG7L0OnMxsiUyU9XOcoxk3PNM3M)


Two parties want to communicate, but they want to ensure that the contents of their connection remain private. They also distrust the internet, and they need a way to verify that the packets they receive haven't been tampered with. HMAC is a valid solution. 

**How it works**

1. HMACs provides client and server with a `shared private key` that is known only to them.

2. The client makes a unique hash (HMAC) for every request. When the client requests the server, it hashes the requested data with a private key and sends it as a part of the request. Both the message and key are hashed in separate steps making it secure. 

3. When the server receives the request, it makes its own HMAC. Both the HMACS are compared and if both are equal, the client is considered legitimate. 

The formula for HMAC:  
```
HMAC = hashFunc(secret key + message) 
```

**Example** [PUT method Amazon S3 documentation](http://s3.amazonaws.com/doc/s3-developer-guide/RESTAuthentication.html)

```ts
"Authorization: AWS " + AWSAccessKeyId + ":"  + base64(hmac-sha1(VERB + "\n" 
							     + CONTENT-MD5 + "\n" 
							     + CONTENT-TYPE + "\n" 
							     + DATE + "\n" 
							     + CanonicalizedAmzHeaders + "\n" 
							     + CanonicalizedResource))
```

```
PUT /quotes/nelson HTTP/1.0
Authorization: AWS 44CF9590006BF252F707:jZNOcbfWmD/A/f3hSvVzXZjM2HU=
Content-Md5: c8fdb181845a4ca6b8fec737b3581d76
Content-Type: text/html
Date: Thu, 17 Nov 2005 18:49:58 GMT
X-Amz-Meta-Author: foo@bar.com
X-Amz-Magic: abracadabra
```

**Usage scenarios**
- Verification of e-mail address during activation or creation of an account.
- Authentication of form data that is sent to the client browser and then submitted back.
- HMACs can be used for Internet of things (IoT) due to less cost.
- Whenever there is a need to reset the password, a link that can be used once is sent without adding a server state.
- It can take a message of any length and convert it into a fixed-length message digest. That is even if you got a long message, the message digest will be small and thus permits maximizing bandwidth.

See more:
- [What is HMAC?](https://www.geeksforgeeks.org/what-is-hmachash-based-message-authentication-code/)
- [HMAC Definition](https://www.okta.com/identity-101/hmac/)



## Open Authentication (OAuth)

::: tip 
`OAuth` ra đời nhằm giải quyết vấn đề trên và xa hơn nữa, đây là một phương thức chứng thực giúp các ứng dụng có thể chia sẻ tài nguyên với nhau mà không cần chia sẻ thông tin username và password.
:::

- **Ứng dụng**  (website hoặc mobile app)yêu cầu ủy quyền để truy cập vào **Resource Server** (Gmail,Facebook, Twitter hay Github…) thông qua User
- Nếu **User** ủy quyền cho yêu cầu trên, **Ứng dụng** sẽ nhận được *`ủy quyền từ phía User`* (dưới dạng một token string)
- **Ứng dụng** gửi thông tin *`định danh`* (ID) của mình kèm theo *`ủy quyền của User`* tới **Authorization Server**
- Nếu *`thông tin định danh`* được xác thực và ủy quyền hợp lệ, **Authorization Server** sẽ trả về cho **Ứng dụng** *`access_token`*. Đến đây quá trình ủy quyền hoàn tất.
- Nếu *`access_token`* hợp lệ, **Resource Server** sẽ trả về dữ liệu của tài nguyên đã được yêu cầu cho **Ứng dụng**.

![Mô hình OAuth2](@/images/oauth.png)

Tóm tắt [bài viết gốc](https://viblo.asia/p/authentication-story-part-1-authentication-la-lam-gi-63vKj2YMK2R)

## OAuth 2.0

![Flow](https://lh3.googleusercontent.com/pw/ABLVV87fIPgyI8R1LyS-TIK2CtlhJZn_KbbxS0QF3vIOEwrVbJvp1EN2X-7kVIHzhFGcVeX7IOlMNrHD_Gy65aihVcvgWx5gecxc6qWqrXGPlXtoQaGOMpM41HR-j_jtotlx5803gNBFQ16F0kg8DZ25HgV_b8Vt51TDrkN4r9e_bHH9b5aCKgngYxTMBT0NXn4hKZUzqVf7bY1DitbvTTWie44C-ChrVlocCvX_tIwDsNz0Dj3MuFqG46kdda6VHHdnh-bd9-UP8C_QfN56rDHqm1dNSwakQ1Zp7BFF2cRjk_xbPwWyvgMikPX-3faMUR1_w7Hv8SNLOVoDdYQ2I84ZsZOyE_f8288Qqj50TYT3fLlFU55klzR1brmXmbn5UaOCAfAAyIpEWPnf37c3wA_yCqJP1MjLLzolqDsaDnPE6W27zBwx6xjXkOetI6OA1LiI_HJ3qx4GRJcyO_BiskDwS9NdalcDdCbJLBgkSSu39ImQetpY4wg5sEw1ZDQiUr3Gu852RlZzFWmlQkrOINGU3U8K1GBbyIJ643paXRCXTx_8IpMOpxpfmSfiQ5WCoBycdr_u7_bmmckqnJgGuyTZjuAbP7q7jzjB3ug2KayUhpTgcQGnLfH_yBqssKRWu5poZTccR98-WFnNcIvirZxZAiVzumTjRckFikZHo7mTM2uDHq5CoOuCb67nZiiA1ba1YBX9f9_Abx3-4jpssdhuCPlJKdtTkQrYk72-i4fW7k7Xz7VvYQGFmY_lmJ06TwIe3GpOEdDZAToUd-AIR2lk1VeG1-XkVWFZ-2zsjlBXytObyUcg6e4oOui1Ca9jdpdd8eoV-ouwiXpapsU9hgvAYWxY1IL18T7M11V_5jLgtciF_23xiUhKvaRX8Sl2uzI6EzD6bT-m3aEcNsu0v80V8Jr5hxKodzTj37OMPyD_xg=w692-h900-s-no-gm)

OAuth 2.0 (Open Authorization) Explained With Simple Terms.

OAuth 2.0 is a powerful and secure framework that allows different applications to securely interact with each other on behalf of users without sharing sensitive credentials.

The entities involved in OAuth are the User, the Server, and the Identity Provider (IDP).

What Can an OAuth Token Do?

When you use OAuth, you get an OAuth token that represents your identity and permissions. This token can do a few important things:

Single Sign-On (SSO): With an OAuth token, you can log into multiple services or apps using just one login, making life easier and safer.

Authorization Across Systems: The OAuth token allows you to share your authorization or access rights across various systems, so you don't have to log in separately everywhere.

Accessing User Profile: Apps with an OAuth token can access certain parts of your user profile that you allow, but they won't see everything.

Remember, OAuth 2.0 is all about keeping you and your data safe while making your online experiences seamless and hassle-free across different applications and services.

[Read more](https://twitter.com/bytebytego/status/1725770574402928644)

## Passwordless Authentication

When it comes to authentication, there are three factors to consider:
- Knowledge factors: something you know, such as a password
- Ownership factors: something you own, such as a device or phone number
- Inherence factors: something unique to you, such as your biometric features

### One-Time Passwords (OTP)

Step 1: The user wants to log in to a website and is asked to enter a username, cell phone number, or email.

Step 2: The server generates an OTP with an expiration time.

Step 3: The server sends the OTP to the user’s device via SMS or email.

Step 4: The user enters the OTP received in the login box.

Step 5-6: The server compares the generated OTP with the one the user entered. If they match, login is granted.

![otp](./img/otp-flow.png)


### Single Sign-On (SSO)

When a principal tries to access a resource, she is directed to authenticate with an **identity provider**. Once identity provider is satisfied that the principal has been authenticated, it gives informatin to the **service provider**, allowing it to decide whether to grant her access to the resource.

- **Identity provider** could be an externally hosted system, or something inside your own organization. 
    - Goolge, for example, provides an OpenID Connect identity provider.
    - For enterprises, it's common to have your own identity provider, which may be linked to your company's directory service - It could be s.th like *Lightweight Directory Access Protocol (LDAP)* or *Active Directory*


The SSO process mainly relies on a **Central Authentication Service (CAS)** server. Here's a step-by-step breakdown of the SSO process:

1. When we attempt to log in to an application, such as Gmail, we're redirected to the **CAS** server.
2. The **CAS** server verifies our login credentials and creates a **Ticket Granting Ticket (TGT)**. This **TGT** is then stored in a **Ticket Granting Cookie (TGC)** on our browser, **representing our global session.**
3. CAS generates a **Service Ticket (ST)** for our visit to Gmail and redirects us back to Gmail with the **ST**.
4. Gmail uses the **ST** to validate our login with the **CAS** server. After validation, we can access Gmail.

When we want to access another application, like YouTube, the process is simplified:
- Since we already have a **TGC** from our Gmail login, **CAS** recognizes our authenticated status.
- **CAS** generates a new **ST** for YouTube access, and we can use YouTube without inputting our credentials again.

This process reduces the need to remember and enter multiple sets of credentials for different applications.

![otp](./img/sso-youtube-gg.png)

- SSO: Single Sign-On 
- CAS: Central Authentication Service 
- TGT: Ticket Granting Ticket
- TGC: Ticket Granting Cookie
- ST: Service Ticket